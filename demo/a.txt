http://web.jobbole.com/83575/
http://www.html-js.com/article/Accelerated-rendering-in-Chrome-model
http://www.w3cplus.com/animation/animation-performance-guide.html
http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html
http://www.cnblogs.com/PeunZhang/p/3510083.html
http://www.cnblogs.com/coco1s/p/5439619.html

前端需要知道的WEB知识(2)

经常听人说canvas能开启硬件加速加速，3d transform能开启硬件加速，可是，硬件加速到底是什么？它又能干什么？

轮子哥是这么说的

![轮子哥对于硬件加速的评价](http://jiangshanmeta.github.io/blogimg/web/vczh.jpg)

好像有哪里不对。不说废话了开始正题。

熟悉web开发的人都熟悉DOM这个概念，稍微进一步的开发者会了解 在浏览器中，有HTML解析器将HTML转化为DOM，然而web开发者并控制不了解析过程。然后呢，DOM又和CSS规则结合，形成了渲染树，此时，浏览器上依然是什么都没有。随后的部分就牵扯到我要说的硬件加速部分了。向上一张老图表示渲染过程。

![浏览器工作原理](http://jiangshanmeta.github.io/blogimg/browser2.png)

首先要介绍层的概念。Chrome存在几种不同类型的层：RenderLayers(渲染层)，负责DOM子树；GraphicsLayers(图形层)，负责RenderLayers的子树。GraphicsLayers会作为texture（纹理）上传到GPU。这里的纹理可以理解为位图。我们可以这么理解：chrome将DOM元素分割成为多个图层，然后对每个图层进行样式计算形成位图，然后上传到GPU中将多个图层进行合并形成我们看到的网页。在chrome开发模式中可以在rendering setting中选中show layer borders显示图形层。在正常的网页中会看到网页被蓝色线条分割成了多个小块。这些小块可以看成是层的子单元。下面有图有真相。

![chrome](http://jiangshanmeta.github.io/blogimg/web/chrome.png)

然后要说的是重绘和重排的概念。重排会导致重绘，重绘不一定有重排。要尽量减少重绘和重排。这几句话相信搞web开发的人都很熟。想起来当初开始写图片轮播的时候，css3用的不熟，更不要提什么前端性能优化了。那时候是各种暴力控制top、left移动，现在看来性能太差了，简直是有1mol重排重绘，而且javascript相当多时间在忙着处理纯展示的事情。

接着说的是web界的另一句话

> 移动端要想动画性能流畅，应该使用3d硬件加速

终于到正题了。上面那句话很常见，可是为啥那？让我开始串起来吧。

在某些特定情况下，一些DOM元素可以被拆分到独立的层中，这些层拼接起来就是我们所看到的页面。如果一个层的内容没有变化，而仅仅是层与层之间的合成属性变化，比如translate了，那么所需要的仅仅是在GPU内重新合成，不需要重绘。如果是按照我最早写图片轮播的模式来，经历的路程大概是这样的：

计算样式--->为节点生成图形和位置--->将节点填充到图层位图中--->图层位图作为纹理上传到GPU--->GPU合成图层形成我们看到的网页

如果我们出发了重绘重排，形成新页面的路程明显增长，你让浏览器做这么多事情，动画效果能好吗？想想就知道。

那么什么条件能够使得DOM元素被拆分到独立的层呢？

1. 3D 或透视变换(perspective transform) CSS 属性
2. 使用加速视频解码的元素,如<video>
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的元素,如<canvas>
4. 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
5. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
6. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

我们最常见的是使用canvas，一些游戏引擎，比如egret最终是使用全屏的canvas实现游戏的，其能流畅实现动画效果离不开硬件加速。然后是使用3d transform,即使我们只是使用2dtransform，也可以欺骗浏览器说我们要使用3d transform，[这篇译文提到了常见的欺骗手段](http://www.cnblogs.com/PeunZhang/p/3510083.html)。

使用分层确实可以减少重绘重排，那么有什么坑吗？轮子哥说费电，除此之外好要考虑手机浏览器的限制，毕竟不是pc，GPU做不到那么强，你要是不该分层的东西也分层了，GPU要心里苦了。[CSS3硬件加速也有坑](http://web.jobbole.com/83575/)中提到了一种误分层的情况及解决方案。

参考资料

[CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)

[Web动画性能指南](http://www.w3cplus.com/animation/animation-performance-guide.html)

[CSS3 3D 行星运转 && 浏览器渲染原理](http://www.cnblogs.com/coco1s/p/5439619.html)


网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是说某些元素可能不同于它的父元素所在的层次，因为某些原因，webkit需要为该元素和他的子元素建立一个新层。

当一个网页构建层次结构的时候，首先是根节点，此时自然地为它创建一个层，这就是"根层"，如果网页结构简单，很有可能只有根层。

根据数据的流向，将渲染过程分为三个阶段，第一阶段是从网页的URL到构建完DOM树，第二个阶段是从DOM树到构建完webkit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。




















table的那些事

最近我的知乎时间线上出现了这么一个问题:[网页的 Table 布局和 DIV+CSS 布局从哪里可以看出来？Table 布局已经过时了吗？](https://www.zhihu.com/question/20003535)，于是便想着总结一下关于table的一些知识点。先声明一下，这里table是指css table，而不是html table，以下所说的可能用html的形式来写，但都是指的css table。

## 基本概念

#### 关于表格的display值

1. table                对应html中的<table>
2. table-row            对应html中的<tr>
3. table-cell           对应htnl中的<td>
4. table-row-group      对应html中的<tbody>
5. table-header-group   对应html中的<thead>
6. table-footer-group   对应html中的<tfoot>
7. table-caption        对应html中的<caption>
8. table-column         对应html中的<col>
9. table-column-group   对应html中的<colgroup>

最重要的是前三个属性，而最后两个可以认为没什么用处，因为css将其表模型定义为以行为主，也就是说，它认为web开发者会显式声明行，而列是从单元格行的布局推导出来的。

#### 匿名表对象
在html的table，有一些嵌套标签即使你不去写，浏览器也会去帮你填充，css的table也有类似的现象，可以将“遗漏的”组件作为匿名对象插入。插入遵循以下规则：

1. 如果一个table-cell元素的父元素不是table-row元素，则会在该table-cell元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素的所有连续兄弟。
2. 如果一个table-row元素的父元素不是table、table-row-group元素，则会在该table-row元素及其父元素之间插入一个匿名table元素。插入的这个对象将包含该table-row元素的连续兄弟。
3. 如果一个table-column元素的父元素不是table、table-column-group元素，则在该table-column元素及其父元素之间插入一个匿名table元素。
4. 如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名table元素。
5. 如果一个table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在该table元素及其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素及所有不是table-row-group、table-header-group、table-footer-group、table-row、table-caption元素的连续兄弟
6. 如果一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row对象，则在该元素及其子元素之间插入一个匿名table-row对象。这个匿名对象包含该子元素及其所有非table-row对象的连续兄弟
7. 如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象。这个匿名对象包含该子元素及其所有非table-cell元素的连续兄弟

看起来比较理论，大家自己读读就好。

#### 固定布局
熟悉css属性的人对于```table-layout```应该不陌生，这个属性很大程度上影响了table的布局。首先介绍的固定布局，对应的属性值是```fixed```。

要实现固定布局，首先要设定```table-layout```为```fixed```,这是显然的，但是也是不足的，除此之外还要设定table的宽度，否则会按照自动布局进行。

具体实现上包括以下步骤：

1. width属性不是auto的列元素会根据width值设置该列的宽度。
2. 如果一个列的宽度为auto，但是表首行中该列的单元格width不为auto，则根据单元格宽度设置此列宽度。其它行设定的宽度无效。
3. 经过前两步，如果列的宽度依然为auto，会自动确定其大小，使其宽度尽可能相等。

固定布局速度比较快，因为布局不依赖与内容，而是根据表的宽度、列和单元格的width决定。

上面提到的第三点是table实现等分布局的基础。

#### 自动布局

自动布局是table的默认布局，但是因为要根据内容决定布局，所以布局速度较慢。

对于自动布局，具体宽度的计算比较复杂，而且对于中英文分割也比较复杂。所以这里就简要介绍一下：

1. 对于一列的各个单元格，计算最小和最大单元格宽度。
2. 对于各列，计算最小和最大列宽
3. 计算出表的真正宽度和各列宽度。如果表的```width```属性不是auto，则将width属性值与所有列宽之和比较，取较大的作为表的宽度。如果最终宽度大于各列宽度之和，多余宽度各列均分。如果表的```width```属性为auto，则将各列宽度之和作为表的宽度。换句话说，表的宽度恰好足够显示其内容，这一点是**不定宽元素水平居中**的基础。然而，在```width```为```auto```的情况下，一个表可能会很难看，尤其是中文，有的时候可能发现每一列宽度都很小甚至只能写下一个字然后整个文字就竖起来了。目测bootstrap也是因为这个所以给table一个```width:100%```。

#### 关于height

对于web开发者来说，一般很少显式声明一个元素的高度，但是对于table来说，就有点有趣了

先约定一下页面结构

```
<div style="display:table;height:600px;">
    <div style="display:table-row;"></div>
    <div style="display:table-row;"></div>
    <div style="display:table-row;"></div>
</div>
```

如果行高度不限制，三行内容一致，你会发现三行等分了整个表的高度，共同占据了600px的高度，这一点和常规div表现不一致。[在线demo](http://jiangshanmeta.github.io/blogdemo/table/table.html)

如果高度不限制，三行内容不一致，那么三行均分剩余高度。看起来上面说的内容一致的是这里的特殊情况。你不觉得和```flex```有点像吗，```flex-grow```属性就可以分配剩余空间，不过能设置分配系数，比这里强大点。[在线demo（和上面同一个）](http://jiangshanmeta.github.io/blogdemo/table/table.html)

//于是，我无意间实现了简单模拟```flex-grow```属性。

如果高度限制了比例，你会发现这里的比例只是参考比例，如果足够放得下，那么就按照这个比例，如果不够放，那么会调整比例使其恰能放开。[在线demo（依然和上面同一个）](http://jiangshanmeta.github.io/blogdemo/table/table.html)

在上面的情况延伸一下，如果有一个行高度设为了100%，其它行高度会调整为恰好够填充，而这一行会填充满剩余空间。之前提到过这一点可以用来实现sticky footer，[在线demo](http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html)




## table的用处

#### 不定宽元素水平居中
```
.center-table{
  display:table;
  margin-left:auto;
  margin-right:auto;
}
```
原理上面有说，是自动布局```width```属性为```auto```时```display:table```的元素宽度为内容宽度

#### 垂直居中

#### 等分布局/多列布局

#### 等高布局

#### sticky footer

之前[总结过sticky footer的实现](http://jiangshanmeta.github.io/post/stickyfooter/),以及[在线demo](http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html)