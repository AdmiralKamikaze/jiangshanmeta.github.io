http://web.jobbole.com/83575/
http://www.html-js.com/article/Accelerated-rendering-in-Chrome-model
http://www.w3cplus.com/animation/animation-performance-guide.html
http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html
http://www.cnblogs.com/PeunZhang/p/3510083.html
http://www.cnblogs.com/coco1s/p/5439619.html

前端需要知道的WEB知识(2)

经常听人说canvas能开启硬件加速加速，3d transform能开启硬件加速，可是，硬件加速到底是什么？它又能干什么？

轮子哥是这么说的

![轮子哥对于硬件加速的评价](http://jiangshanmeta.github.io/blogimg/web/vczh.jpg)

好像有哪里不对。不说废话了开始正题。

熟悉web开发的人都熟悉DOM这个概念，稍微进一步的开发者会了解 在浏览器中，有HTML解析器将HTML转化为DOM，然而web开发者并控制不了解析过程。然后呢，DOM又和CSS规则结合，形成了渲染树，此时，浏览器上依然是什么都没有。随后的部分就牵扯到我要说的硬件加速部分了。向上一张老图表示渲染过程。

![浏览器工作原理](http://jiangshanmeta.github.io/blogimg/browser2.png)

首先要介绍层的概念。Chrome存在几种不同类型的层：RenderLayers(渲染层)，负责DOM子树；GraphicsLayers(图形层)，负责RenderLayers的子树。GraphicsLayers会作为texture（纹理）上传到GPU。这里的纹理可以理解为位图。我们可以这么理解：chrome将DOM元素分割成为多个图层，然后对每个图层进行样式计算形成位图，然后上传到GPU中将多个图层进行合并形成我们看到的网页。在chrome开发模式中可以在rendering setting中选中show layer borders显示图形层。在正常的网页中会看到网页被蓝色线条分割成了多个小块。这些小块可以看成是层的子单元。下面有图有真相。

![chrome](http://jiangshanmeta.github.io/blogimg/web/chrome.png)

然后要说的是重绘和重排的概念。重排会导致重绘，重绘不一定有重排。要尽量减少重绘和重排。这几句话相信搞web开发的人都很熟。想起来当初开始写图片轮播的时候，css3用的不熟，更不要提什么前端性能优化了。那时候是各种暴力控制top、left移动，现在看来性能太差了，简直是有1mol重排重绘，而且javascript相当多时间在忙着处理纯展示的事情。

接着说的是web界的另一句话

> 移动端要想动画性能流畅，应该使用3d硬件加速

终于到正题了。上面那句话很常见，可是为啥那？让我开始串起来吧。

在某些特定情况下，一些DOM元素可以被拆分到独立的层中，这些层拼接起来就是我们所看到的页面。如果一个层的内容没有变化，而仅仅是层与层之间的合成属性变化，比如translate了，那么所需要的仅仅是在GPU内重新合成，不需要重绘。如果是按照我最早写图片轮播的模式来，经历的路程大概是这样的：

计算样式--->为节点生成图形和位置--->将节点填充到图层位图中--->图层位图作为纹理上传到GPU--->GPU合成图层形成我们看到的网页

如果我们出发了重绘重排，形成新页面的路程明显增长，你让浏览器做这么多事情，动画效果能好吗？想想就知道。

那么什么条件能够使得DOM元素被拆分到独立的层呢？

1. 3D 或透视变换(perspective transform) CSS 属性
2. 使用加速视频解码的元素,如<video>
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的元素,如<canvas>
4. 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
5. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
6. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

我们最常见的是使用canvas，一些游戏引擎，比如egret最终是使用全屏的canvas实现游戏的，其能流畅实现动画效果离不开硬件加速。然后是使用3d transform,即使我们只是使用2dtransform，也可以欺骗浏览器说我们要使用3d transform，[这篇译文提到了常见的欺骗手段](http://www.cnblogs.com/PeunZhang/p/3510083.html)。

使用分层确实可以减少重绘重排，那么有什么坑吗？轮子哥说费电，除此之外好要考虑手机浏览器的限制，毕竟不是pc，GPU做不到那么强，你要是不该分层的东西也分层了，GPU要心里苦了。[CSS3硬件加速也有坑](http://web.jobbole.com/83575/)中提到了一种误分层的情况及解决方案。

参考资料

[CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)

[Web动画性能指南](http://www.w3cplus.com/animation/animation-performance-guide.html)

[CSS3 3D 行星运转 && 浏览器渲染原理](http://www.cnblogs.com/coco1s/p/5439619.html)


网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是说某些元素可能不同于它的父元素所在的层次，因为某些原因，webkit需要为该元素和他的子元素建立一个新层。

当一个网页构建层次结构的时候，首先是根节点，此时自然地为它创建一个层，这就是"根层"，如果网页结构简单，很有可能只有根层。

根据数据的流向，将渲染过程分为三个阶段，第一阶段是从网页的URL到构建完DOM树，第二个阶段是从DOM树到构建完webkit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。

//TODO

CSS中一些比较好玩的属性

#### currentColor
这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话[张鑫旭大神已经给了几个](http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/)

#### user-select
知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用```user-select:none;```，这样对于普通用户连选择都做不到。

不过这个属性兼容性有点差，在[can I use](http://caniuse.com/#search=user-select%3A)上查到的信息是目前还是乖乖加上私有前缀吧。

#### ::selection
在CSS中伪元素常用的只有```::before```和```::after```,```::selection```就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。

本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。





https://www.zhihu.com/question/39817183
https://www.zhihu.com/question/27432017













bootstrap源码解读——carousel.js















bootstrap源码解读——tab.js

tab切换是网页中的常见设计，从实现上讲也并不复杂，基本思路是导航监听事件，然后把之前显示的tab窗口隐藏掉，然后把导航对应的窗口展示出来，并且更新导航条的状态。bootstrap也对此提供了相应的插件支持，基本思路上都差不太多。先说一下依赖的html结构和css代码

```html
<div>
  <!-- Nav tabs -->
  <ul class="nav nav-tabs" role="tablist">
    <li role="presentation" class="active">
    	<a href="#home" aria-controls="home" role="tab" data-toggle="tab">
    		Home
    	</a>
    </li>
    <li role="presentation">
    	<a href="#profile" aria-controls="profile" role="tab" data-toggle="tab">
   			 Profile
    	</a>
    </li>
    <li role="presentation">
    	<a href="#messages" aria-controls="messages" role="tab" data-toggle="tab">
    		Messages
    	</a>
    </li>
    <li role="presentation">
    	<a href="#settings" aria-controls="settings" role="tab" data-toggle="tab">
    		Settings
    	</a>
    </li>
  </ul>

  <!-- Tab panes -->
  <div class="tab-content">
    <div role="tabpanel" class="tab-pane active" id="home">...</div>
    <div role="tabpanel" class="tab-pane" id="profile">...</div>
    <div role="tabpanel" class="tab-pane" id="messages">...</div>
    <div role="tabpanel" class="tab-pane" id="settings">...</div>
  </div>

</div>

```

整体上分为两大块，一部分是导航，一部分是tab窗口，tab窗口的css比较简单，

```
.tab-content > .tab-pane {
  display: none;
}
.tab-content > .active {
  display: block;
}
```
说白了只要控制```active```类就能控制tab窗口的切换。比较复杂的是导航条的样式，基本款式有两种```nav-tabs```和```nav-pills```，这两个都可以配合```nav-justified```类形成两端对齐的导航。其实这些样式层面的东西对于js代码没什么影响，我就说几个比较好玩的。

```
.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs > li {
  float: left;
  margin-bottom: -1px;
}
.nav-tabs > li > a {
  margin-right: 2px;
  line-height: 1.42857143;
  border: 1px solid transparent;
  border-radius: 4px 4px 0 0;
}
.nav-tabs > li.active > a,
.nav-tabs > li.active > a:hover,
.nav-tabs > li.active > a:focus {
  color: #555;
  cursor: default;
  background-color: #fff;
  border: 1px solid #ddd;
  border-bottom-color: transparent;
}
```
tab标签页我觉得是写的比较好的，尤其是对于辅助线的处理上。每一个标签项都是浮动的，显然会有清除浮动影响，没写在这里。那条线是写在整个导航条上的。那么如何实现 当前标签页没有下面那条线的？首先是利用```margin-bottom:-1px```把每个标签项向下移动1px，然后每个标签项都有一个透明的1px边框，这时候标签项的下边框和导航条的下边框正好是重合的，由于颜色是透明的所以可以看得到导航条的边框。对于当前标签页，加了一个白色背景颜色，相当于是用背景色把导航边框色给盖住了。然而，为什么不用边框色盖住呢？非要写一个白色背景色，因为要处理```:hover、:focus```的情况。

样式的东西就写这些，其实我觉得```nav-justified```写得也很好，既实现了所有标签项占据100%空间，又能兼顾标签项内容的长度分配剩余空间，[stackoverflow上面有评论](http://stackoverflow.com/a/27846774)。

说js部分了，利用data形式绑定事件以前已经说过了，然而我怀疑有没有必要整出```'[data-toggle="tab"]'```和```'[data-toggle="pill"]'```两个来。

```
function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.tab')

	  if (!data) $this.data('bs.tab', (data = new Tab(this)))
	  if (typeof option == 'string') data[option]()
	})
}
```
和以往一样是把生成的对象挂到了data上，然后根据传入的参数做一些操作。在```Tab```的原型上主要挂了两个方法```show```和```activate```,```show```方法主要的功能是判断要不要进行tab切换，切换的对象是谁。具体的切换是```activate```方法实现的，这个方法相当于是对切换这个操作剥离出来，导航条标签的切换、tab窗口的切换都通过这个方法实现，这两个切换没有耦合在一起，这一点很不错。

```show```方法里确定要展示的tab窗口是通过tab标签的```data-target```或者```href```实现的，弱弱的说一句，在bootstrap的插件里，有的是```href```有限，有的是```data-target```优先，不过正常人是不会两个都加上的。在```show```方法里还触发了一些事件，相较于之前看过的几个插件，这里的事件复杂在有```relatedTarget```的概念。


在```activate```方法中，首先获取当前活动的元素，然后判断是否要过渡

```
var transition = callback
  && $.support.transition
  && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)
```
然而我不太明白的是为啥一定要有callback才支持过渡。然后就是判断是否要过渡，如果要过渡的首先把当前展示的页面过渡、逐渐淡出，淡出完成后当前的移除```active```类，target元素添加```active```类，如果target元素需要过渡出来的话，还要先强制重绘一次，在添加```in```这个类，否则会直接进入最终状态。