http://web.jobbole.com/83575/
http://www.html-js.com/article/Accelerated-rendering-in-Chrome-model
http://www.w3cplus.com/animation/animation-performance-guide.html
http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html
http://www.cnblogs.com/PeunZhang/p/3510083.html
http://www.cnblogs.com/coco1s/p/5439619.html

前端需要知道的WEB知识(2)

经常听人说canvas能开启硬件加速加速，3d transform能开启硬件加速，可是，硬件加速到底是什么？它又能干什么？

轮子哥是这么说的

![轮子哥对于硬件加速的评价](http://jiangshanmeta.github.io/blogimg/web/vczh.jpg)

好像有哪里不对。不说废话了开始正题。

熟悉web开发的人都熟悉DOM这个概念，稍微进一步的开发者会了解 在浏览器中，有HTML解析器将HTML转化为DOM，然而web开发者并控制不了解析过程。然后呢，DOM又和CSS规则结合，形成了渲染树，此时，浏览器上依然是什么都没有。随后的部分就牵扯到我要说的硬件加速部分了。向上一张老图表示渲染过程。

![浏览器工作原理](http://jiangshanmeta.github.io/blogimg/browser2.png)

首先要介绍层的概念。Chrome存在几种不同类型的层：RenderLayers(渲染层)，负责DOM子树；GraphicsLayers(图形层)，负责RenderLayers的子树。GraphicsLayers会作为texture（纹理）上传到GPU。这里的纹理可以理解为位图。我们可以这么理解：chrome将DOM元素分割成为多个图层，然后对每个图层进行样式计算形成位图，然后上传到GPU中将多个图层进行合并形成我们看到的网页。在chrome开发模式中可以在rendering setting中选中show layer borders显示图形层。在正常的网页中会看到网页被蓝色线条分割成了多个小块。这些小块可以看成是层的子单元。下面有图有真相。

![chrome](http://jiangshanmeta.github.io/blogimg/web/chrome.png)

然后要说的是重绘和重排的概念。重排会导致重绘，重绘不一定有重排。要尽量减少重绘和重排。这几句话相信搞web开发的人都很熟。想起来当初开始写图片轮播的时候，css3用的不熟，更不要提什么前端性能优化了。那时候是各种暴力控制top、left移动，现在看来性能太差了，简直是有1mol重排重绘，而且javascript相当多时间在忙着处理纯展示的事情。

接着说的是web界的另一句话

> 移动端要想动画性能流畅，应该使用3d硬件加速

终于到正题了。上面那句话很常见，可是为啥那？让我开始串起来吧。

在某些特定情况下，一些DOM元素可以被拆分到独立的层中，这些层拼接起来就是我们所看到的页面。如果一个层的内容没有变化，而仅仅是层与层之间的合成属性变化，比如translate了，那么所需要的仅仅是在GPU内重新合成，不需要重绘。如果是按照我最早写图片轮播的模式来，经历的路程大概是这样的：

计算样式--->为节点生成图形和位置--->将节点填充到图层位图中--->图层位图作为纹理上传到GPU--->GPU合成图层形成我们看到的网页

如果我们出发了重绘重排，形成新页面的路程明显增长，你让浏览器做这么多事情，动画效果能好吗？想想就知道。

那么什么条件能够使得DOM元素被拆分到独立的层呢？

1. 3D 或透视变换(perspective transform) CSS 属性
2. 使用加速视频解码的元素,如<video>
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的元素,如<canvas>
4. 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
5. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
6. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

我们最常见的是使用canvas，一些游戏引擎，比如egret最终是使用全屏的canvas实现游戏的，其能流畅实现动画效果离不开硬件加速。然后是使用3d transform,即使我们只是使用2dtransform，也可以欺骗浏览器说我们要使用3d transform，[这篇译文提到了常见的欺骗手段](http://www.cnblogs.com/PeunZhang/p/3510083.html)。

使用分层确实可以减少重绘重排，那么有什么坑吗？轮子哥说费电，除此之外好要考虑手机浏览器的限制，毕竟不是pc，GPU做不到那么强，你要是不该分层的东西也分层了，GPU要心里苦了。[CSS3硬件加速也有坑](http://web.jobbole.com/83575/)中提到了一种误分层的情况及解决方案。

参考资料

[CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)

[Web动画性能指南](http://www.w3cplus.com/animation/animation-performance-guide.html)

[CSS3 3D 行星运转 && 浏览器渲染原理](http://www.cnblogs.com/coco1s/p/5439619.html)


网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是说某些元素可能不同于它的父元素所在的层次，因为某些原因，webkit需要为该元素和他的子元素建立一个新层。

当一个网页构建层次结构的时候，首先是根节点，此时自然地为它创建一个层，这就是"根层"，如果网页结构简单，很有可能只有根层。

根据数据的流向，将渲染过程分为三个阶段，第一阶段是从网页的URL到构建完DOM树，第二个阶段是从DOM树到构建完webkit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。

//TODO

CSS中一些“奇技淫巧”

声明一下，这里的奇技淫巧是指自己用得少觉得新奇而且有实际应用场景的CSS属性，而不是诸如用CSS画个IE8不支持的IE8图标之类的纯粹为了炫技然而实际没什么用途的黑魔法。

#### currentColor
这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话[张鑫旭大神已经给了几个](http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/)

#### user-select
知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用```user-select:none;```，这样对于普通用户连选择都做不到。

不过这个属性兼容性有点差，在[can I use](http://caniuse.com/#search=user-select%3A)上查到的信息是目前还是乖乖加上私有前缀吧。

#### ::selection
在CSS中伪元素常用的只有```::before```和```::after```,```::selection```就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。

本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。

#### pointer-events:none
这个CSS让js和CSS的边界越来越模糊。想象这么一个场景：要做一个活动页，需要全屏的canvas绘制一些东西，这个canvas相当于一个遮罩层，但是我又想遮罩层下面的元素响应各种事件，尤其是点击事件。想通过js完成这件事目测要写一堆，但是对这个遮罩层使用```pointer-events:none```即可让这个遮罩层不响应点击事件。

#### content的attr
伪元素大家应该不陌生了，但是伪元素的content属性我一般用的不多，后来发现一篇文章[美化加载失败的图片](http://web.jobbole.com/86079/)发现了content属性的一些玩法。我们可以通过attr属性引入一些属性的内容，比如```img::after{content:'['attr(src)']'}```，这样就能在图片加载不出来的时候把原始图片地址显示出来（虽然我怀疑用户能否理解）。类似的思路，我们可以显示a标签的href属性```a::after{content:attr(href)}```。

#### direction
这个属性有用的只有两个值：```ltr```、```rtl```，含义分别是从左向右和从右向左。猜也能猜出来默认值是```ltr```。或许你会认为应用```rtl```后会改变文字排版变成从右向左排布，然而那是```writing-mode```的工作（顺便说一句，目前文字排版的常规模式是从左到右从上到下，除了搞两句古诗词的文艺小清新我觉得没人会闲的改变这种模式）。那么这个```direction```改变的是什么的方向？ 改变的是**内联元素块**的左右顺序，而内联元素块内部的元素是当做一个整体看待。换句话说，```direction```属性可以在不改变DOM前后顺序的前提下改变内联元素块的前后顺序，听着好像低配版的flex布局的```order```属性。

干什么用呢？[张鑫旭大神提供了例子](http://www.zhangxinxu.com/wordpress/2016/03/css-direction-introduction-apply/)，在不改变DOM的情况下添加类名改变弹框组件的按钮顺序。
















bootstrap源码解读——carousel.js




php中exit()的一个用法

熟悉最好的编程语言php（手动滑稽）的人应该对于```exit()```或者```die()```函数不陌生，根据有的[手册的说法](http://php.net/manual/zh/function.die.php)这两个函数其实是别名关系，功能上是一样的。一般这两个函数是在调试的时候用的比较多，我的一个同事就比较习惯用```die()```，然而作为前端入行的我显然是更习惯使用```return```的方式进行调试。当然我对php的最主要调试方法是写两行然后用```var_dump()```调试，一小步一小步往前推进。对于```die()```和```exit()```两个函数，有的人认为出错了用前者，提前退出用后者，我觉得没有太大的必要去区分这一点。

关于```die()```和```exit()```两个函数的用法，我觉得这一句话说得很好

> 在设计工具类和工具函数时，die()/exit() 应该严令禁止，因为它们无权决定整个程序的生死。

上面这句话其实也反映了这两个函数与```return```的区别，前者是程序级别的，后者仅仅是函数级别的。对于一般的调试其实无所谓了，但是总有业务场景需要区别使用。

在我们的项目中后端是一个MVC框架，model层会根据前端传过来的各种信息进行初始化，为了容错，经常会有这样的代码

```
if (!$this->dataInfo->is_inited){
	$jsonRst = -1;
	$jsonData = array();
	$jsonData['err']['msg'] ='数据有误';
	echo $this->exportData($jsonData,$jsonRst);
	return false;
}
```

然而，一个controller里的action里面可能会加载多个model，这样上面的代码就经常会重复N变，以至于可能真正的业务部分真的没有几行大部分都是在容错。

显然需要对上面的操作进行封装，如果把上面的代码封装到model里面，我们尝试初始化数据后调用这个函数，会发现返回一个```true```或```false```，然后controller里的函数依然进行，我们要根据返回值再判断一次，虽然确实是少了不少行，但是依然看起来很恶心。类似的，model初始化返回布尔值也是类似的结果。

我们需要在初始化的时候如果没成功，直接停止整个程序，毕竟数据错了其他的逻辑执行也没用。所以我的解决方案是使用```exit()```,这样把检查函数分装到model层的基类中就行了

```
public function check_inited{
	if(!$this->is_inited){
		$jsonRst = -1;
		$jsonData = array();
		$jsonData['err']['msg'] ='数据有误';
		echo $this->exportData($jsonData,$jsonRst);
		exit();
	}
}
```

虽然改动并不多，但是把初始化是数据异常检测及处理封装起来了，能够让controller里更加关心业务逻辑而不是这些恶心的容错。



















