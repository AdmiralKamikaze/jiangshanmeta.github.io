http://web.jobbole.com/83575/
http://www.html-js.com/article/Accelerated-rendering-in-Chrome-model
http://www.w3cplus.com/animation/animation-performance-guide.html
http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html
http://www.cnblogs.com/PeunZhang/p/3510083.html
http://www.cnblogs.com/coco1s/p/5439619.html

前端需要知道的WEB知识(2)

经常听人说canvas能开启硬件加速加速，3d transform能开启硬件加速，可是，硬件加速到底是什么？它又能干什么？

轮子哥是这么说的

![轮子哥对于硬件加速的评价](http://jiangshanmeta.github.io/blogimg/web/vczh.jpg)

好像有哪里不对。不说废话了开始正题。

熟悉web开发的人都熟悉DOM这个概念，稍微进一步的开发者会了解 在浏览器中，有HTML解析器将HTML转化为DOM，然而web开发者并控制不了解析过程。然后呢，DOM又和CSS规则结合，形成了渲染树，此时，浏览器上依然是什么都没有。随后的部分就牵扯到我要说的硬件加速部分了。向上一张老图表示渲染过程。

![浏览器工作原理](http://jiangshanmeta.github.io/blogimg/browser2.png)

首先要介绍层的概念。Chrome存在几种不同类型的层：RenderLayers(渲染层)，负责DOM子树；GraphicsLayers(图形层)，负责RenderLayers的子树。GraphicsLayers会作为texture（纹理）上传到GPU。这里的纹理可以理解为位图。我们可以这么理解：chrome将DOM元素分割成为多个图层，然后对每个图层进行样式计算形成位图，然后上传到GPU中将多个图层进行合并形成我们看到的网页。在chrome开发模式中可以在rendering setting中选中show layer borders显示图形层。在正常的网页中会看到网页被蓝色线条分割成了多个小块。这些小块可以看成是层的子单元。下面有图有真相。

![chrome](http://jiangshanmeta.github.io/blogimg/web/chrome.png)

然后要说的是重绘和重排的概念。重排会导致重绘，重绘不一定有重排。要尽量减少重绘和重排。这几句话相信搞web开发的人都很熟。想起来当初开始写图片轮播的时候，css3用的不熟，更不要提什么前端性能优化了。那时候是各种暴力控制top、left移动，现在看来性能太差了，简直是有1mol重排重绘，而且javascript相当多时间在忙着处理纯展示的事情。

接着说的是web界的另一句话

> 移动端要想动画性能流畅，应该使用3d硬件加速

终于到正题了。上面那句话很常见，可是为啥那？让我开始串起来吧。

在某些特定情况下，一些DOM元素可以被拆分到独立的层中，这些层拼接起来就是我们所看到的页面。如果一个层的内容没有变化，而仅仅是层与层之间的合成属性变化，比如translate了，那么所需要的仅仅是在GPU内重新合成，不需要重绘。如果是按照我最早写图片轮播的模式来，经历的路程大概是这样的：

计算样式--->为节点生成图形和位置--->将节点填充到图层位图中--->图层位图作为纹理上传到GPU--->GPU合成图层形成我们看到的网页

如果我们出发了重绘重排，形成新页面的路程明显增长，你让浏览器做这么多事情，动画效果能好吗？想想就知道。

那么什么条件能够使得DOM元素被拆分到独立的层呢？

1. 3D 或透视变换(perspective transform) CSS 属性
2. 使用加速视频解码的元素,如<video>
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的元素,如<canvas>
4. 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
5. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
6. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

我们最常见的是使用canvas，一些游戏引擎，比如egret最终是使用全屏的canvas实现游戏的，其能流畅实现动画效果离不开硬件加速。然后是使用3d transform,即使我们只是使用2dtransform，也可以欺骗浏览器说我们要使用3d transform，[这篇译文提到了常见的欺骗手段](http://www.cnblogs.com/PeunZhang/p/3510083.html)。

使用分层确实可以减少重绘重排，那么有什么坑吗？轮子哥说费电，除此之外好要考虑手机浏览器的限制，毕竟不是pc，GPU做不到那么强，你要是不该分层的东西也分层了，GPU要心里苦了。[CSS3硬件加速也有坑](http://web.jobbole.com/83575/)中提到了一种误分层的情况及解决方案。

参考资料

[CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)

[Web动画性能指南](http://www.w3cplus.com/animation/animation-performance-guide.html)

[CSS3 3D 行星运转 && 浏览器渲染原理](http://www.cnblogs.com/coco1s/p/5439619.html)


网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是说某些元素可能不同于它的父元素所在的层次，因为某些原因，webkit需要为该元素和他的子元素建立一个新层。

当一个网页构建层次结构的时候，首先是根节点，此时自然地为它创建一个层，这就是"根层"，如果网页结构简单，很有可能只有根层。

根据数据的流向，将渲染过程分为三个阶段，第一阶段是从网页的URL到构建完DOM树，第二个阶段是从DOM树到构建完webkit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。

//TODO

CSS中一些比较好玩的属性

#### currentColor
这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话[张鑫旭大神已经给了几个](http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/)

#### user-select
知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用```user-select:none;```，这样对于普通用户连选择都做不到。

不过这个属性兼容性有点差，在[can I use](http://caniuse.com/#search=user-select%3A)上查到的信息是目前还是乖乖加上私有前缀吧。

#### ::selection
在CSS中伪元素常用的只有```::before```和```::after```,```::selection```就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。

本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。





https://www.zhihu.com/question/39817183
https://www.zhihu.com/question/27432017













bootstrap源码解读——carousel.js
















bootstrap源码解读——collapse.js

最近工作忙，好不容易闲下来身体又出bug了，好久没更新了。接着读bootstrap的代码，今天要说的是collapse.js。这个插件实现的展开与收缩效果。

先看一下data-api
```
$(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
	var $this   = $(this)

	if (!$this.attr('data-target')) e.preventDefault()

	var $target = getTargetFromTrigger($this)
	var data    = $target.data('bs.collapse')
	var option  = data ? 'toggle' : $this.data()

	Plugin.call($target, option)
})
```
具体绑定的方式和之前分析的alert、button差不多，都是利用事件委托机制。具体的回调函数比较复杂了。collapse.js设定了两种绑定展开收缩对象的形式，一种是通过a标签的```href```属性，另一种是通过```data-target```属性，并且还封装了一个小函数```getTargetFromTrigger```找到对应的绑定元素。如果是通过```href```属性指定展开收缩对象的话，需要阻止默认事件，至于阻止的是啥，还用我说嘛。然后的三行就写的比较巧妙了，先获取data上面保存的信息，然后如果之前保存过collapse的实例，给*option*赋值为'toggle',如果没有，赋值为一个对象。为什么要返回一个data的对象？一开始我也没想明白，看到插件的具体内容才想明白为什么要加这个，因为这个插件还负责实现手风琴效果，手风琴效果总归需要一个包裹元素吧，这里的实现是通过```data-parent```来决定这个包裹元素是谁。如果是最简单的展开收缩效果，option里面的只会有toggle，对于手风琴效果会对一个parent，针对这个parent有一些额外的操作。


然后是Plugin的实现
```
function Plugin(option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.collapse')
	  var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

	  if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
	  if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	  if (typeof option == 'string') data[option]()
	})
}
```
bootstrap的插件基本上是按照一个模板出来的。在bootstrap插件里第一次见到使用```$.extend```方法，使用过jquery的人应该了解这是合并对象用的，原生js的一个实现是```Object.assign```，只是有点兼容问题。而且这里重新利用了*toggle*属性，通过判断是否需要调用toggle方法，看Collapse构造函数就会明白这样会保证如果传入的不是```show```或者```hide```这两个字符串，就会*toggle*一次。如果传入的是字符串，会调用相关方法。

上面说的是写法上的巧妙之处，然而重点是这个展开收缩是如何实现的，在文档上有这么一句

> Collapse requires the transitions plugin to be included in your version of Bootstrap.

就是说展开收缩效果是通过CSS3过渡实现的，我曾经想过如果用纯CSS实现这种展开收缩效果，但是由于```height```无法从```auto```过渡到一个具体数字，所以只能用有点hack意味的方案，我最终采用的是过渡```transform```的```scale```，这样有个问题的别的元素会认为这个元素依然是占据原来的大小。bootstrap的解决方案让我觉得很受启发。

当调用```show```方法的时候，先做一些隔离，保证此时操作的元素处于hide状态。这时收缩状态的元素含有一个类```collapse```，对应内容是```display:none```，然后

```
this.$element
  .removeClass('collapse')
  .addClass('collapsing')[dimension](0)
  .attr('aria-expanded', true)
```
移除```collapse```这个类，这时候元素理应正常显示，这一这里强行设定高度为0，等一下我再吐槽这个```dimension```，顺便吐槽```collapsing```这个类。现在这个需要展开的元素高度为0，我们需要确定最终高度，bootstrap的实现我觉得挺巧的
```
var scrollSize = $.camelCase(['scroll', dimension].join('-'))
```
它是利用scrollHeight来确定最终高度的，初始高度、最终高度有了，过渡的最基本的条件就有了。过渡完成后的回调其实也比较有意思
```
var complete = function () {
  this.$element
    .removeClass('collapsing')
    .addClass('collapse in')[dimension]('')
  this.transitioning = 0
  this.$element
    .trigger('shown.bs.collapse')
}
```
移除了```collapsing```这个类，添加```collapse```和```in```两个类，并且把高度设置为默认值。为什么要这么做？因为以后这个展开收缩区域可能会动态添加或者删除内容，此时写死高度就有些不合适了。

对应的```hide```方法基本过程类似，其实只要看明白一个另一个也就差不多了。说一下要说的几点

```
this.$element[dimension](this.$element[dimension]())[0].offsetHeight
```
之前说过，无法实现*height*的从*auto*到一个数值的过渡，我们需要获取元素的具体高度，这里还强行重绘了一次，保证把高度值从auto转换为具体的数值。其他的基本上就是```show```方法的逆过程了。

下面开始预告的吐槽

在上面的解说中，我是直接把```dimension```说成是```height```，我们还是看代码把

```
Collapse.prototype.dimension = function () {
	var hasWidth = this.$element.hasClass('width')
	return hasWidth ? 'width' : 'height'
}
```
dimension就是上面几行代码的返回值，水平方向的展开收缩虽然不多见，但也总归是有，但是呢，你看你的管理过渡的类```collapsing```的内容
```
.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  -webkit-transition-timing-function: ease;
       -o-transition-timing-function: ease;
          transition-timing-function: ease;
  -webkit-transition-duration: .35s;
       -o-transition-duration: .35s;
          transition-duration: .35s;
  -webkit-transition-property: height, visibility;
       -o-transition-property: height, visibility;
          transition-property: height, visibility;
}
```
你们写js的和写css的看来不是一个人啊，根本没实现对于宽度过渡的支持啊，你们。。。。

这其实都是小事，我觉得一个让我很迷惑的问题是为啥```visibility```这个属性也能过渡？于是[张鑫旭大神又解释过这个问题了](http://www.zhangxinxu.com/wordpress/2013/05/transition-visibility-show-hide/)。其中张鑫旭前辈提到了应用场景

> 举个例子，我们要实现淡入淡出效果，显然是需要改变透明度的，但是，元素即使透明度变成0，虽然肉眼看不见，但是，在页面上，元素还是可以点击，还是可以覆盖其他元素的，这显然是有问题的，我们最最希望的是在元素淡出动画结束后，元素可以自动隐藏！

个人觉得他对```opacity:0;```和```visibility:hidden```的区别没有说清楚。这时候就要搬出[stackoverflow上的回答](http://stackoverflow.com/a/273076)。这两个都是不脱离文档流，但是前者依然响应事件，而后者不响应事件。不过回到这个插件里来，并没有用到```visibility```的过渡。


主体内容差不多就完了，关于手风琴效果的具体实现，以及其他的细节自己去看源码吧。



```

```