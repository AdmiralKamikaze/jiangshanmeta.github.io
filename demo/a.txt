http://web.jobbole.com/83575/
http://www.html-js.com/article/Accelerated-rendering-in-Chrome-model
http://www.w3cplus.com/animation/animation-performance-guide.html
http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html
http://www.cnblogs.com/PeunZhang/p/3510083.html
http://www.cnblogs.com/coco1s/p/5439619.html

前端需要知道的WEB知识(2)

经常听人说canvas能开启硬件加速加速，3d transform能开启硬件加速，可是，硬件加速到底是什么？它又能干什么？

轮子哥是这么说的

![轮子哥对于硬件加速的评价](http://jiangshanmeta.github.io/blogimg/web/vczh.jpg)

好像有哪里不对。不说废话了开始正题。

熟悉web开发的人都熟悉DOM这个概念，稍微进一步的开发者会了解 在浏览器中，有HTML解析器将HTML转化为DOM，然而web开发者并控制不了解析过程。然后呢，DOM又和CSS规则结合，形成了渲染树，此时，浏览器上依然是什么都没有。随后的部分就牵扯到我要说的硬件加速部分了。向上一张老图表示渲染过程。

![浏览器工作原理](http://jiangshanmeta.github.io/blogimg/browser2.png)

首先要介绍层的概念。Chrome存在几种不同类型的层：RenderLayers(渲染层)，负责DOM子树；GraphicsLayers(图形层)，负责RenderLayers的子树。GraphicsLayers会作为texture（纹理）上传到GPU。这里的纹理可以理解为位图。我们可以这么理解：chrome将DOM元素分割成为多个图层，然后对每个图层进行样式计算形成位图，然后上传到GPU中将多个图层进行合并形成我们看到的网页。在chrome开发模式中可以在rendering setting中选中show layer borders显示图形层。在正常的网页中会看到网页被蓝色线条分割成了多个小块。这些小块可以看成是层的子单元。下面有图有真相。

![chrome](http://jiangshanmeta.github.io/blogimg/web/chrome.png)

然后要说的是重绘和重排的概念。重排会导致重绘，重绘不一定有重排。要尽量减少重绘和重排。这几句话相信搞web开发的人都很熟。想起来当初开始写图片轮播的时候，css3用的不熟，更不要提什么前端性能优化了。那时候是各种暴力控制top、left移动，现在看来性能太差了，简直是有1mol重排重绘，而且javascript相当多时间在忙着处理纯展示的事情。

接着说的是web界的另一句话

> 移动端要想动画性能流畅，应该使用3d硬件加速

终于到正题了。上面那句话很常见，可是为啥那？让我开始串起来吧。

在某些特定情况下，一些DOM元素可以被拆分到独立的层中，这些层拼接起来就是我们所看到的页面。如果一个层的内容没有变化，而仅仅是层与层之间的合成属性变化，比如translate了，那么所需要的仅仅是在GPU内重新合成，不需要重绘。如果是按照我最早写图片轮播的模式来，经历的路程大概是这样的：

计算样式--->为节点生成图形和位置--->将节点填充到图层位图中--->图层位图作为纹理上传到GPU--->GPU合成图层形成我们看到的网页

如果我们出发了重绘重排，形成新页面的路程明显增长，你让浏览器做这么多事情，动画效果能好吗？想想就知道。

那么什么条件能够使得DOM元素被拆分到独立的层呢？

1. 3D 或透视变换(perspective transform) CSS 属性
2. 使用加速视频解码的元素,如<video>
3. 拥有 3D (WebGL) 上下文或加速的 2D 上下文的元素,如<canvas>
4. 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
5. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
6. 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

我们最常见的是使用canvas，一些游戏引擎，比如egret最终是使用全屏的canvas实现游戏的，其能流畅实现动画效果离不开硬件加速。然后是使用3d transform,即使我们只是使用2dtransform，也可以欺骗浏览器说我们要使用3d transform，[这篇译文提到了常见的欺骗手段](http://www.cnblogs.com/PeunZhang/p/3510083.html)。

使用分层确实可以减少重绘重排，那么有什么坑吗？轮子哥说费电，除此之外好要考虑手机浏览器的限制，毕竟不是pc，GPU做不到那么强，你要是不该分层的东西也分层了，GPU要心里苦了。[CSS3硬件加速也有坑](http://web.jobbole.com/83575/)中提到了一种误分层的情况及解决方案。

参考资料

[CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)

[Web动画性能指南](http://www.w3cplus.com/animation/animation-performance-guide.html)

[CSS3 3D 行星运转 && 浏览器渲染原理](http://www.cnblogs.com/coco1s/p/5439619.html)


网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是说某些元素可能不同于它的父元素所在的层次，因为某些原因，webkit需要为该元素和他的子元素建立一个新层。

当一个网页构建层次结构的时候，首先是根节点，此时自然地为它创建一个层，这就是"根层"，如果网页结构简单，很有可能只有根层。

根据数据的流向，将渲染过程分为三个阶段，第一阶段是从网页的URL到构建完DOM树，第二个阶段是从DOM树到构建完webkit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。









bootstrap源码解读——栅格系统

bootstrap的CSS部分中最出名的应该就是栅格系统了，它解决了网页中常见的多列布局问题。对应的实现其实并不是特别复杂，主要包括以下知识点：

1. 盒模型
2. 浮动
3. 相对定位
4. 响应式布局

## 基本概念
栅格系统的行（row）必须包裹在```.container```或者```container-fluid```中。
```
.container {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}
@media (min-width: 768px) {
  .container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .container {
    width: 1170px;
  }
}
.container-fluid {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}

```
从代码中看出bootstrap中移动优先的理念，默认的都是小屏下的样式，再逐步通过媒体查询实现大屏下的样式。```container```和```container-fluid```在小屏下的行为是一致的，但是在pad屏或者更大的屏幕下，前者表现为有固定宽度居中显示，而后者一直保持宽度100%，虽然我很好奇后者为什么要添加上```margin-left:auto;margin-right:auto;```

而列的样式比较有趣
```
.row {
  margin-right: -15px;
  margin-left: -15px;
}
```

row要包含在container中，container包含了15px的左右padding，row却用左右各-15px的margin撑了出去，抵消了container的padding，写这个框架的人在想什么？问题的答案在于列的样式以及列嵌套。在列的通用样式里，有这样的设置：

```
padding-right: 15px;
padding-left: 15px;
```
如果我们想要实现列嵌套，例如如下代码：
```
<div class="row">
  <div class="col-sm-9">
    Level 1: .col-sm-9
    <div class="row">
      <div class="col-xs-8 col-sm-6">
        Level 2: .col-xs-8 .col-sm-6
      </div>
      <div class="col-xs-4 col-sm-6">
        Level 2: .col-xs-4 .col-sm-6
      </div>
    </div>
  </div>
</div>
```
我们需要内层的row抵消掉外层的col的padding。


## 盒模型部分

默认情况下box-sizing为content-box，bootstrap上来就重置了盒模型为border-box。为什么要这么做呢？因为栅格系统的每一列的宽度都是根据百分比计算得到的，如果使用默认的content-box，如果有的列加上border或者padding，布局直接会乱掉。基本上等分布局的实现离不开这一设置。

```
* {
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}
```

## 浮动部分
如果让你实现多列布局，你想怎么办？最容易想到的就是浮动啊。bootstrap确实是使用浮动实现多列布局的。

部分代码如下

```
.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {
  float: left;
}
```
既然使用了浮动，那么就免不了要处理浮动带来的盒子塌陷问题。具体实现如下：

```
.container:after,
.container-fluid:after,
.row:after{
  display: table;
  content: " ";
  clear: both;
}
```

有的时候我们需要对列进行偏移，bootstrap提供了```col-*-offset-*```一系列类，实现原理是通过margin-left。


## 相对定位部分

一开始读bootstrap 源码的时候，发现列的公共样式里面有这么一条：

```
position: relative;
```
一般来说相对定位是和绝对定位结合使用的，这里有没有绝对定位是干什么的呢？当我读到关于列顺序的代码的时候我就明白了。

相对定位的元素，如果是使用top left right bottom ，其定位是相对于原来的位置进行定位。举个例子
```
.col-xs-push-6 {
  left: 50%;
}
```
应用此类后col相对于原来的位置向右偏移了50%。看起来是在模拟flex布局的order。然而我真的没在生产环境里用过，真的没有。

## 响应式布局

作为一个前端框架，bootstrap显然要处理不同屏幕下的显示问题，所以使用了响应式布局。处于移动优先这一概念的考虑，bootstrap默认设施都是在手机小屏下，然后通过媒体查询实现其他较大屏幕的样式设置。当浏览器宽度超过了分界点，如果没有设置此区间的新样式，按照更小屏幕的样式显示。

其实对于手机端来说，bootstrap一方面可能太重了，另一方面响应式布局也不见得是万能的。这就是另一个话题了。

对于bootstrap的css，目前觉得也就是它的栅格系统有必要说一下，其他的再说吧。



bootstrap源码解读——button.js

button.js我个人觉得是属于从一开始就没想明白要做什么。和其他的bootstrap的插件一样，button也能用data的形式调用插件，但是我真心没想明白使用data调用的有什么实际用途。反而我觉得手动调用的对我来说更有实际意义，所以这里只说[button.js改变状态的部分](http://v3.bootcss.com/javascript/#buttons-stateful)。

在web应用中免不了用户触发ajax请求，比如提交表单（实际项目中没有用表单的直接提交，而是使用了ajax提交表单），点击加载更多。在ajax过程中我们需要告诉用户正在进行中，需要等待。在实际项目中为了实现这一个需求我们使用了一个插件blockUI,可以自行百度一下，我觉得挺好用的。另一种方案是改变button的状态，把他标记为不可点击。

整体形式是标准的bootstrap插件的形式，关于如何绑定方法，如何防冲突，这些都在 [bootstrap源码解读——alert.js](http://jiangshanmeta.github.io/post/bootstrap/alert/)中分析过了，没有必要去做过多的说明。

```
function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data('bs.button')
    var options = typeof option == 'object' && option

    if (!data) $this.data('bs.button', (data = new Button(this, options)))

    if (option == 'toggle') data.toggle()
    else if (option) data.setState(option)
  })
}
```
和alert.js类似，这里也是采用data的形式进行缓存```Button```实例，我们不需要去关心```toggle```的实现，因为我连应用场景都没想到，我们只需关心调用```setState```方法。setState传入的参数其实只有```loading```和```reset```是有效的。

```
Button.prototype.setState = function (state) {
  var d    = 'disabled'
  var $el  = this.$element
  var val  = $el.is('input') ? 'val' : 'html'
  var data = $el.data()

  state += 'Text'

  if (data.resetText == null) $el.data('resetText', $el[val]())

  // push to event loop to allow forms to submit
  setTimeout($.proxy(function () {
    $el[val](data[state] == null ? this.options[state] : data[state])

    if (state == 'loadingText') {
      this.isLoading = true
      $el.addClass(d).attr(d, d)
    } else if (this.isLoading) {
      this.isLoading = false
      $el.removeClass(d).removeAttr(d)
    }
  }, this), 0)
}
```
读起来并不是很难懂，一个要注意的地方是```setTimeout```，这个函数一方面会改变```this```的指向，我以前也分析过[javascript的this坑](http://jiangshanmeta.github.io/post/jsthis/)，另一方面是定时器的原理，不是相隔多长时间后执行，而是相隔多长时间后加入任务队列，这个[我以前也提及过](http://jiangshanmeta.github.io/post/browser/)。另一个要注意的点是data的使用，利用data保存button中原来的内容就不说了，很常规的一个写法。比较有趣的是对于加载时显示内容的处理。文档上说加载时保存的信息保存在了```data-loading-text```中，但是我们在代码中读取的时候是以```loadingText```的形式读写，这就比较有意思了，一个中划线没了，然后一个大小写改变了。查了查MDN找到了答案：

data-*,*可以被任何符合以下限制的the producton rule of xml names(xml的命名规则)代替：

1. 名字不能以xml开头，除此之外其他任何情形都可是使用这3个字母；
2. 名字不能含有分号；
3. 名字不能含有大写字母。

注意：HTMLElement.dataset是一个 StringMap。一个名叫data-test-value的自定义属性可以通过HTMLElment.dataset.testValue来访问，属性的名字中的中线(U+002D)被挨着它字母的大写字母代替了（驼峰命名）。

自定义的data 属性名称转化成 DOMStringMap 的键值时会遵循下面的规则：

1. 前缀  data- 被去除(包括减号)；
2. 对于每个在ASCII小写字母 a到 z前面的减号 (U+002D)，减号会被去除，并且字母会转变成对应的大写字母。其他字符（包含其他减号）都不发生变化


具体链接: [data-*](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-data-*),[dataset](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset)





