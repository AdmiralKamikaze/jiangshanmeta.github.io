<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Css on jsmeta</title>
    <link>http://jiangshanmeta.github.io/tags/css/</link>
    <description>Recent content in Css on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Aug 2016 20:03:58 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/tags/css/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>上网的不科学指南</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/summarize/</link>
      <pubDate>Tue, 16 Aug 2016 20:03:58 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/summarize/</guid>
      <description>&lt;p&gt;看计算机网络已经有一段时间了，对于应用层、传输层、网络层、链路层也有了基本的了解。但是感觉自己学的比较零碎，缺乏一个整体的概念，所以想写一篇总结，把这些东西串起来。&lt;/p&gt;

&lt;p&gt;想要上网的话，首先要通过&lt;strong&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;&lt;/strong&gt;获得一个IP地址。&lt;/p&gt;

&lt;p&gt;客户端这里首先生成一个DHCP发现报文，然后把这个报文交给传输层传输层的&lt;code&gt;UDP&lt;/code&gt;，DHCP有固定的源端口号和目的端口号。&lt;code&gt;UDP&lt;/code&gt;封装好之后，交给网络层去处理，网络层的IP报文需要填写目的IP地址和源IP地址，然而目前自身的IP待分配、目的IP地址也未知，这里就需要两个特殊的IP地址了，源IP地址为&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，目的IP地址为&lt;code&gt;255.255.255.255&lt;/code&gt;表示广播地址。网络层处理完交给数据链路层处理，需要源MAC地址和目的MAC地址，现在连DHCP服务器是谁都不知道怎么确定MAC地址？答案和刚提到的广播IP地址类似，目的MAC地址填上广播MAC地址&lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;局域网内部的每一台主机都能收到这个报文，但是只有DHCP服务器才会做出响应。对于DHCP服务器，数据自下传递到上层，然后把分配的IP地址、DNS服务器地址、默认网关地址、子网掩码 作为DHCP ACK报文，然后向下逐层封装。形成IP报文的时候目的地址依然为广播地址。在这里说一句无论是DHCP发现报文还是DHCP ACK报文，中间都经过&lt;code&gt;链路层交换机&lt;/code&gt;，链路层交换机会根据源MAC地址和输入链路的接口在交换机表中记录一条记录，作为转发的基础。&lt;/p&gt;

&lt;p&gt;现在我们这台主机获得了自己的IP地址，顺便还有默认DNS服务器地址、默认网关地址、子网掩码。当我们在地址栏中输入一个url的时候，比如 &lt;a href=&#34;http://jiangshanmeta.github.io&#34;&gt;http://jiangshanmeta.github.io&lt;/a&gt; ，就需要通过&lt;code&gt;DNS&lt;/code&gt;服务（至少对于chrome调用DNS不见得一定在输入url然后确认之后，我们没有必要关心这个调用的时机）。DNS服务器地址是在DHCP返回的，有可能和我们的主机在一个子网内，也可能不在一个子网内，这需要结合两者的IP地址和&lt;strong&gt;子网掩码&lt;/strong&gt;判断，通常不要指望在一个子网内。要和子网外部进行通信需要通过网关，我们已经有了默认网关地址（一个IP地址），但是数据链路层需要MAC地址，因而我们需要&lt;code&gt;ARP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;ARP是根据IP地址返回MAC地址，它也是利用广播，子网内每台主机都会收到ARP报文，但是只有IP地址对应的才会返回MAC地址。通过ARP获得默认网关MAC地址，这样在主机那里各层发送DNS报文所需要的基本信息就有了，DNS交给UDP、UDP交给IP然后交给链路层封装成帧，所形成的数据帧传递到路由器，路由器这里根据由&lt;code&gt;路由协议&lt;/code&gt;（这么复杂的协议我说这么一句话真的好吗）决定的转发表决定转发的输出链路，根据转发表提供的下一跳IP地址利用ARP获得新的目的MAC地址重写数据链路层（在路由器网络层首部和数据链路层都会有一些首部字段被修改，目的MAC地址是每经过一次路由器就修改，但是目的IP地址相一般不会修改，除非是经过了&lt;code&gt;NAT&lt;/code&gt;）。本地DNS服务器获得请求之后，可能&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;经过一系列请求&lt;/a&gt;，也可能直接根据缓存返回要查询的IP地址。这样我们的主机获得了请求域名的IP地址，对网页的请求的准备工作基本完成了。&lt;/p&gt;

&lt;p&gt;现在需要发起HTTP请求了，以我上面提到的网址为例就是发送一个GET请求，应用层把http报文交给TCP，TCP相比较上面提到的传输层协议UDP，提供可靠传输功能。它需要首先建立连接，然后才能传递上层传来的数据。再往下层的东西上面已经提及了，通过网关出子网，然后经过各种路由转发最终到达目标服务器，目标服务器根据请求的url提供文件，然后又是一层层封装路由转发解封装到达应用层，这样我们得到了请求的文件，比如html，剩下的就是浏览器如何解析返回的数据了，这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;这样我基本上把所学到的计算机网络知识串了起来，包括&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;DNS&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/&#34;&gt;http&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;传输层&lt;/a&gt;的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/&#34;&gt;TCP&lt;/a&gt;和UDP、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;、网络层的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/ip/&#34;&gt;网际协议&lt;/a&gt;和路由协议、NAT、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/mac/&#34;&gt;链路层MAC地址、ARP协议（这是个跨层的协议）、链路层交换机&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;每一层都有了一定的了解，下面的任务是转入http协议的学习和设计模式的学习了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>终于bootstrap满足不了我了——用flex实现一个栅格系统</title>
      <link>http://jiangshanmeta.github.io/post/css/flex/</link>
      <pubDate>Sat, 13 Aug 2016 14:16:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/flex/</guid>
      <description>&lt;p&gt;bootstrap样式方面我觉得最重要的就是栅格系统了，然而在实际项目中觉得有些情况它所能提供的满足不了我的需求了。最近感受比较深的就是列表展示页面，每一个列表项对应的图片文字大小所需空间不一致，我的一个解决方案是利用CSS文字强制只显示一行或多行（不知道如何实现的自行百度），然后图片&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;放在一个正方形的盒子里展示&lt;/a&gt;，确实是一个解决问题的方法但我觉得不够优雅。其实根本问题出现在bootstrap的栅格系统是基于浮动的，每一个列高度不一致导致布局错乱显然是不可避免的。bootstrap也考虑到了这个问题，他们的解决方案是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;建议联合使用 .clearfix 和 响应式工具类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说的没错，只要在每行之间加上一个&lt;code&gt;.clearfix&lt;/code&gt;确实能解决问题。但是我显然是动态输出页面的啊，我还要手动写个计数器然后输出这个清除浮动的标签，总觉得略折腾。&lt;/p&gt;

&lt;p&gt;那既然问题是不等高造成的做个等高布局怎么样？ 说的就和等高布局好做似的。padding撑出去+margin缩回来方案hack意味太浓，table的同行单元格等高这一属性可以利用但是我还要输出表示行的标签，折腾程度差不多，响应式处理起来更折腾，那似乎就剩下flex了。但是对于flex float又直接失效。&lt;/p&gt;

&lt;p&gt;于是我想着干脆用flex模拟一个bootstrap的栅格系统，对于熟悉flex布局和bootstrap的同学这并不难。&lt;/p&gt;

&lt;p&gt;首先是container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
	box-sizing:border-box;
}
.flex-container {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
@media (min-width: 768px) {
  .flex-container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .flex-container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .flex-container {
    width: 1170px;
  }
}
.flex-container-fluid {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是每一列的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-12 {
	flex:0 0 100%;
}
.flex-col-xs-11 {
	flex:0 0 91.66666667%;
}
.flex-col-xs-10 {
	flex:0 0 83.33333333%;
}
.flex-col-xs-9 {
	flex:0 0 75%;
}
.flex-col-xs-8 {
	flex:0 0 66.66666667%;
}
.flex-col-xs-7 {
	flex:0 0 58.33333333%;
}
.flex-col-xs-6 {
	flex:0 0 50%;
}
.flex-col-xs-5 {
	flex:0 0 41.66666667%;
}
.flex-col-xs-4 {
	flex:0 0 33.33333333%;
}
.flex-col-xs-3 {
	flex:0 0 25%;
}
.flex-col-xs-2 {
	flex:0 0 16.66666667%;
}
.flex-col-xs-1 {
	flex:0 0 8.33333333%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是列的响应式处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media (min-width: 768px) {
	.flex-col-sm-12 {
		flex:0 0 100%;
	}
	.flex-col-sm-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-sm-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-sm-9 {
		flex:0 0 75%;
	}
	.flex-col-sm-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-sm-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-sm-6 {
		flex:0 0 50%;
	}
	.flex-col-sm-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-sm-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-sm-3 {
		flex:0 0 25%;
	}
	.flex-col-sm-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-sm-1 {
		flex:0 0 8.33333333%;
	}
}


@media (min-width: 992px) {
	.flex-col-md-12 {
		flex:0 0 100%;
	}
	.flex-col-md-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-md-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-md-9 {
		flex:0 0 75%;
	}
	.flex-col-md-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-md-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-md-6 {
		flex:0 0 50%;
	}
	.flex-col-md-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-md-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-md-3 {
		flex:0 0 25%;
	}
	.flex-col-md-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-md-1 {
		flex:0 0 8.33333333%;
	}

}

@media (min-width: 1200px) {
	.flex-col-lg-12 {
		flex:0 0 100%;
	}
	.flex-col-lg-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-lg-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-lg-9 {
		flex:0 0 75%;
	}
	.flex-col-lg-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-lg-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-lg-6 {
		flex:0 0 50%;
	}
	.flex-col-lg-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-lg-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-lg-3 {
		flex:0 0 25%;
	}
	.flex-col-lg-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-lg-1 {
		flex:0 0 8.33333333%;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列偏移部分，只列出了xs部分，没写响应式部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-offset-12 {
  margin-left: 100%;
}
.flex-col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.flex-col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.flex-col-xs-offset-9 {
  margin-left: 75%;
}
.flex-col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.flex-col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.flex-col-xs-offset-6 {
  margin-left: 50%;
}
.flex-col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.flex-col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.flex-col-xs-offset-3 {
  margin-left: 25%;
}
.flex-col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.flex-col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.flex-col-xs-offset-0 {
  margin-left: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列排序，和bootstrap一样，基于&lt;code&gt;position:relative&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-1,
.flex-col-xs-2,
.flex-col-xs-3,
.flex-col-xs-4,
.flex-col-xs-5,
.flex-col-xs-6,
.flex-col-xs-7,
.flex-col-xs-8,
.flex-col-xs-9,
.flex-col-xs-10,
.flex-col-xs-11,
.flex-col-xs-12{
	position:relative;
}

.flex-col-xs-pull-12 {
  right: 100%;
}
.flex-col-xs-pull-11 {
  right: 91.66666667%;
}
.flex-col-xs-pull-10 {
  right: 83.33333333%;
}
.flex-col-xs-pull-9 {
  right: 75%;
}
.flex-col-xs-pull-8 {
  right: 66.66666667%;
}
.flex-col-xs-pull-7 {
  right: 58.33333333%;
}
.flex-col-xs-pull-6 {
  right: 50%;
}
.flex-col-xs-pull-5 {
  right: 41.66666667%;
}
.flex-col-xs-pull-4 {
  right: 33.33333333%;
}
.flex-col-xs-pull-3 {
  right: 25%;
}
.flex-col-xs-pull-2 {
  right: 16.66666667%;
}
.flex-col-xs-pull-1 {
  right: 8.33333333%;
}
.flex-col-xs-pull-0 {
  right: auto;
}
.flex-col-xs-push-12 {
  left: 100%;
}
.flex-col-xs-push-11 {
  left: 91.66666667%;
}
.flex-col-xs-push-10 {
  left: 83.33333333%;
}
.flex-col-xs-push-9 {
  left: 75%;
}
.flex-col-xs-push-8 {
  left: 66.66666667%;
}
.flex-col-xs-push-7 {
  left: 58.33333333%;
}
.flex-col-xs-push-6 {
  left: 50%;
}
.flex-col-xs-push-5 {
  left: 41.66666667%;
}
.flex-col-xs-push-4 {
  left: 33.33333333%;
}
.flex-col-xs-push-3 {
  left: 25%;
}
.flex-col-xs-push-2 {
  left: 16.66666667%;
}
.flex-col-xs-push-1 {
  left: 8.33333333%;
}
.flex-col-xs-push-0 {
  left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个基于flex的栅格系统就差不多了，包含响应式布局、列偏移、列排序，其实还可以列嵌套，我其实还可以宣称自己基于移动优先的理念之类的。和bootstrap的栅格系统相比，还差点兼容性以及gutter的概念，这个没什么难的，就这样吧。&lt;/p&gt;

&lt;p&gt;还有，女神叫我出去浪，我却在这写博客，终于明白为什么我会孤独一生了。&lt;/p&gt;

&lt;p&gt;update 2016/08/17&lt;/p&gt;

&lt;p&gt;还是把&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.less&#34;&gt;less文件&lt;/a&gt;  和 &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.css&#34;&gt;编译出来的CSS文件放到这里吧&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS中一些“奇技淫巧”</title>
      <link>http://jiangshanmeta.github.io/post/css/csstricks/</link>
      <pubDate>Sun, 31 Jul 2016 20:28:36 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/csstricks/</guid>
      <description>

&lt;p&gt;声明一下，这里的奇技淫巧是指自己用得少觉得新奇而且有实际应用场景的CSS属性，而不是诸如用CSS画个IE8不支持的IE8图标之类的纯粹为了炫技然而实际没什么用途的黑魔法。&lt;/p&gt;

&lt;h4 id=&#34;1-currentcolor:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;1.currentColor&lt;/h4&gt;

&lt;p&gt;这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/&#34;&gt;张鑫旭大神已经给了几个&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-user-select:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;2.user-select&lt;/h4&gt;

&lt;p&gt;知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用&lt;code&gt;user-select:none;&lt;/code&gt;，这样对于普通用户连选择都做不到。&lt;/p&gt;

&lt;p&gt;不过这个属性兼容性有点差，在&lt;a href=&#34;http://caniuse.com/#search=user-select%3A&#34;&gt;can I use&lt;/a&gt;上查到的信息是目前还是乖乖加上私有前缀吧。&lt;/p&gt;

&lt;h4 id=&#34;3-selection:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;3.::selection&lt;/h4&gt;

&lt;p&gt;在CSS中伪元素常用的只有&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;,&lt;code&gt;::selection&lt;/code&gt;就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。&lt;/p&gt;

&lt;p&gt;本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。&lt;/p&gt;

&lt;h4 id=&#34;4-pointer-events-none:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;4.pointer-events:none&lt;/h4&gt;

&lt;p&gt;这个CSS让js和CSS的边界越来越模糊。想象这么一个场景：要做一个活动页，需要全屏的canvas绘制一些东西，这个canvas相当于一个遮罩层，但是我又想遮罩层下面的元素响应各种事件，尤其是点击事件。想通过js完成这件事目测要写一堆，但是对这个遮罩层使用&lt;code&gt;pointer-events:none&lt;/code&gt;即可让这个遮罩层不响应点击事件。&lt;/p&gt;

&lt;h4 id=&#34;5-content的attr:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;5.content的attr&lt;/h4&gt;

&lt;p&gt;伪元素大家应该不陌生了，但是伪元素的content属性我一般用的不多，后来发现一篇文章&lt;a href=&#34;http://web.jobbole.com/86079/&#34;&gt;美化加载失败的图片&lt;/a&gt;发现了content属性的一些玩法。我们可以通过attr属性引入一些属性的内容，比如&lt;code&gt;img::after{content:&#39;[&#39;attr(src)&#39;]&#39;}&lt;/code&gt;，这样就能在图片加载不出来的时候把原始图片地址显示出来（虽然我怀疑用户能否理解）。类似的思路，我们可以显示a标签的href属性&lt;code&gt;a::after{content:attr(href)}&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;6-direction:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;6.direction&lt;/h4&gt;

&lt;p&gt;这个属性有用的只有两个值：&lt;code&gt;ltr&lt;/code&gt;、&lt;code&gt;rtl&lt;/code&gt;，含义分别是从左向右和从右向左。猜也能猜出来默认值是&lt;code&gt;ltr&lt;/code&gt;。或许你会认为应用&lt;code&gt;rtl&lt;/code&gt;后会改变文字排版变成从右向左排布，然而那是&lt;code&gt;writing-mode&lt;/code&gt;的工作（顺便说一句，目前文字排版的常规模式是从左到右从上到下，除了搞两句古诗词的文艺小清新我觉得没人会闲的改变这种模式）。那么这个&lt;code&gt;direction&lt;/code&gt;改变的是什么的方向？ 改变的是&lt;strong&gt;内联元素块&lt;/strong&gt;的左右顺序，而内联元素块内部的元素是当做一个整体看待。换句话说，&lt;code&gt;direction&lt;/code&gt;属性可以在不改变DOM前后顺序的前提下改变内联元素块的前后顺序，听着好像低配版的flex布局的&lt;code&gt;order&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;干什么用呢？&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/03/css-direction-introduction-apply/&#34;&gt;张鑫旭大神提供了例子&lt;/a&gt;，在不改变DOM的情况下添加类名改变弹框组件的按钮顺序。&lt;/p&gt;

&lt;h4 id=&#34;7-padding:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;7.padding&lt;/h4&gt;

&lt;p&gt;关于padding作为前端应该都不陌生，但是padding本身也是具有奇技淫巧的。&lt;/p&gt;

&lt;p&gt;之前我利用padding实现了&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;自适应的正方形和长宽比一定的长方形&lt;/a&gt;，今天学了一手新的，结合&lt;code&gt;padding&lt;/code&gt;以及&lt;code&gt;background-clip&lt;/code&gt;绘制图形。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/csstricks/padding.html&#34;&gt;在线demo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;在bootstrap导航条组件中，有一个三道杠的图标，他们的实现是使用三个span元素做的，根据张鑫旭大神的思路，这里使用一个div就完成了。对于这个需求，其实也可以通过伪元素来实现。&lt;/p&gt;

&lt;p&gt;另外还有一些视频进度条的圆环，我结合伪元素、圆角、padding、background-clip也实现了。对于这一需求，也可以通过&lt;code&gt;box-shadow&lt;/code&gt;来实现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>图文混排布局的一个小tip</title>
      <link>http://jiangshanmeta.github.io/post/tabletip/</link>
      <pubDate>Tue, 28 Jun 2016 23:14:10 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/tabletip/</guid>
      <description>&lt;p&gt;如果想实现一个左图右文布局，可以使用浮动，这是很普遍的一点。但是如果如果右侧文字很少，会显得右侧很空，这时候我们会希望一些文字能够拿到下面来，差不多和图片齐平，显然浮动无法实现，一个很直接的想法是需要等高布局。等高布局比较靠谱的解决方案是利用&lt;a href=&#34;http://jiangshanmeta.github.io/post/table/&#34;&gt;css table&lt;/a&gt;，利用同一行中单元格等高这一特性来实现。但是说实话table真的很难驯服，再加上图文混排出幺蛾子的概率很高。如果按照默认样式的可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/table/tabletip.png&#34; alt=&#34;乱的布局&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要实现上面的结果其实还做过一些处理，因为图可能很大，但是我只希望图片区占有一定比例，其他的所以采用&lt;code&gt;table-layout:fixed&lt;/code&gt;属性加上百分比的宽度，具体的分析上面那个连接给出了说明。&lt;/p&gt;

&lt;p&gt;为什么文字会这么靠下呢，因为&lt;code&gt;vertical-align&lt;/code&gt;属性默认值为&lt;code&gt;baseline&lt;/code&gt;,把右侧文字区的&lt;code&gt;vertical-align&lt;/code&gt;设为&lt;code&gt;top&lt;/code&gt;就好了。然后想放在下面的文字就绝对定位就好了，别忘了给右侧文字区域加上&lt;code&gt;position:ralative&lt;/code&gt;，基本常识了。&lt;/p&gt;

&lt;p&gt;这样基本上差不多了，可以上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;了。&lt;/p&gt;

&lt;p&gt;稍微精益求精的可以发现左侧图片区的高度比图片高度大那么一点，换句话说就是图片下面还有一定空间，这一因为行高，可行的解决方案有如下几个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图片设置为&lt;code&gt;display:block;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片区行高设置&lt;code&gt;line-height:0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片&lt;code&gt;vertical-align&lt;/code&gt;设置为&lt;code&gt;top&lt;/code&gt; || &lt;code&gt;bottom&lt;/code&gt; || &lt;code&gt;middle&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是第二天就用到相关知识了。老板想做类似的东西，左侧依然是图片区，中间是文字区，右侧是一个垂直居中的箭头。这个设计确实挺常见的。然后我就把上面的实现说了一下，然后最右侧加了一个&lt;code&gt;vertical-align:middle&lt;/code&gt;,我实现的demo和上面的demo放在一个页面里了。老板听完我的实现后就默默地决定最右边的那个箭头放背景图里然后默默切图去了。嘤嘤嘤。&lt;/p&gt;

&lt;p&gt;update 2016/07/19&lt;/p&gt;

&lt;p&gt;看到&lt;a href=&#34;http://www.w3cplus.com/css/media-object-vs-flag-object.html&#34;&gt;一篇文章&lt;/a&gt;是讲这一类布局的，还起了一个高大上的名字叫做&lt;strong&gt;媒体对象&lt;/strong&gt;，话说bootstrap里也有类似实现。里面也提到了这种利用table布局的方式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>table那些事</title>
      <link>http://jiangshanmeta.github.io/post/table/</link>
      <pubDate>Mon, 27 Jun 2016 21:09:14 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/table/</guid>
      <description>

&lt;p&gt;最近我的知乎时间线上出现了这么一个问题:&lt;a href=&#34;https://www.zhihu.com/question/20003535&#34;&gt;网页的 Table 布局和 DIV+CSS 布局从哪里可以看出来？Table 布局已经过时了吗？&lt;/a&gt;，于是便想着总结一下关于table的一些知识点。先声明一下，这里table是指css table，而不是html table，以下所说的可能用html的形式来写，但都是指的css table。&lt;/p&gt;

&lt;h2 id=&#34;基本概念:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;基本概念&lt;/h2&gt;

&lt;h4 id=&#34;关于表格的display值:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于表格的display值&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;table                对应html中的&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row            对应html中的&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-cell           对应htnl中的&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row-group      对应html中的&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-header-group   对应html中的&lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-footer-group   对应html中的&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-caption        对应html中的&lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column         对应html中的&lt;code&gt;&amp;lt;col&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column-group   对应html中的&lt;code&gt;&amp;lt;colgroup&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最重要的是前三个属性，而最后两个可以认为没什么用处，因为css将其表模型定义为以行为主，也就是说，它认为web开发者会显式声明行，而列是从单元格行的布局推导出来的。&lt;/p&gt;

&lt;h4 id=&#34;匿名表对象:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;匿名表对象&lt;/h4&gt;

&lt;p&gt;在html的table，有一些嵌套标签即使你不去写，浏览器也会去帮你填充，css的table也有类似的现象，可以将“遗漏的”组件作为匿名对象插入。插入遵循以下规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一个table-cell元素的父元素不是table-row元素，则会在该table-cell元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素的所有连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的父元素不是table、table-row-group元素，则会在该table-row元素及其父元素之间插入一个匿名table元素。插入的这个对象将包含该table-row元素的连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-column元素的父元素不是table、table-column-group元素，则在该table-column元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在该table元素及其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素及所有不是table-row-group、table-header-group、table-footer-group、table-row、table-caption元素的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row对象，则在该元素及其子元素之间插入一个匿名table-row对象。这个匿名对象包含该子元素及其所有非table-row对象的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象。这个匿名对象包含该子元素及其所有非table-cell元素的连续兄弟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看起来比较理论，大家自己读读就好。&lt;/p&gt;

&lt;h4 id=&#34;固定布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;固定布局&lt;/h4&gt;

&lt;p&gt;熟悉css属性的人对于&lt;code&gt;table-layout&lt;/code&gt;应该不陌生，这个属性很大程度上影响了table的布局。首先介绍的固定布局，对应的属性值是&lt;code&gt;fixed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要实现固定布局，首先要设定&lt;code&gt;table-layout&lt;/code&gt;为&lt;code&gt;fixed&lt;/code&gt;,这是显然的，但是也是不足的，除此之外还要设定table的宽度，否则会按照自动布局进行。&lt;/p&gt;

&lt;p&gt;具体实现上包括以下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;width属性不是auto的列元素会根据width值设置该列的宽度。&lt;/li&gt;
&lt;li&gt;如果一个列的宽度为auto，但是表首行中该列的单元格width不为auto，则根据单元格宽度设置此列宽度。其它行设定的宽度无效。&lt;/li&gt;
&lt;li&gt;经过前两步，如果列的宽度依然为auto，会自动确定其大小，使其宽度尽可能相等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;固定布局速度比较快，因为布局不依赖与内容，而是根据表的宽度、列和单元格的width决定。&lt;/p&gt;

&lt;p&gt;上面提到的第三点是table实现等分布局的基础。&lt;/p&gt;

&lt;h4 id=&#34;自动布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;自动布局&lt;/h4&gt;

&lt;p&gt;自动布局是table的默认布局，但是因为要根据内容决定布局，所以布局速度较慢。&lt;/p&gt;

&lt;p&gt;对于自动布局，具体宽度的计算比较复杂，而且对于中英文分割也比较复杂。所以这里就简要介绍一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于一列的各个单元格，计算最小和最大单元格宽度。&lt;/li&gt;
&lt;li&gt;对于各列，计算最小和最大列宽&lt;/li&gt;
&lt;li&gt;计算出表的真正宽度和各列宽度。如果表的&lt;code&gt;width&lt;/code&gt;属性不是auto，则将width属性值与所有列宽之和比较，取较大的作为表的宽度。如果最终宽度大于各列宽度之和，多余宽度各列均分。如果表的&lt;code&gt;width&lt;/code&gt;属性为auto，则将各列宽度之和作为表的宽度。换句话说，表的宽度恰好足够显示其内容，这一点是&lt;strong&gt;不定宽元素水平居中&lt;/strong&gt;的基础。然而，在&lt;code&gt;width&lt;/code&gt;为&lt;code&gt;auto&lt;/code&gt;的情况下，一个表可能会很难看，尤其是中文，有的时候可能发现每一列宽度都很小甚至只能写下一个字然后整个文字就竖起来了。目测bootstrap也是因为这个所以给table一个&lt;code&gt;width:100%&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;关于height:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于height&lt;/h4&gt;

&lt;p&gt;对于web开发者来说，一般很少显式声明一个元素的高度，但是对于table来说，就有点有趣了&lt;/p&gt;

&lt;p&gt;先约定一下页面结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;display:table;height:600px;&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果行高度不限制，三行内容一致，你会发现三行等分了整个表的高度，共同占据了600px的高度，这一点和常规div表现不一致。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果高度不限制，三行内容不一致，那么三行均分剩余高度。看起来上面说的内容一致的是这里的特殊情况。你不觉得和&lt;code&gt;flex&lt;/code&gt;有点像吗，&lt;code&gt;flex-grow&lt;/code&gt;属性就可以分配剩余空间，不过能设置分配系数，比这里强大点。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;//于是，我无意间实现了简单模拟&lt;code&gt;flex-grow&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;如果高度限制了比例，你会发现这里的比例只是参考比例，如果足够放得下，那么就按照这个比例，如果不够放，那么会调整比例使其恰能放开。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（依然和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上面的情况延伸一下，如果有一个行高度设为了100%，其它行高度会调整为恰好够填充，而这一行会填充满剩余空间。之前提到过这一点可以用来实现sticky footer，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;table的用处:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;table的用处&lt;/h2&gt;

&lt;h4 id=&#34;不定宽元素水平居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;不定宽元素水平居中&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-table{
  display:table;
  margin-left:auto;
  margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面有说，是自动布局&lt;code&gt;width&lt;/code&gt;属性为&lt;code&gt;auto&lt;/code&gt;时&lt;code&gt;display:table&lt;/code&gt;的元素宽度为内容宽度&lt;/p&gt;

&lt;h4 id=&#34;垂直居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;垂直居中&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&#34;http://jiangshanmeta.github.io/post/center/&#34;&gt;我的总结&amp;ndash;居中的实现&lt;/a&gt;中提到到过，利用的是&lt;code&gt;vertical-align:middle&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;等分布局-多列布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等分布局/多列布局&lt;/h4&gt;

&lt;p&gt;这两类基本布局我更习惯用浮动实现，对于&lt;code&gt;table&lt;/code&gt;实现没有什么特别大的爱好，等分布局需要&lt;code&gt;table-layout:fixed;&lt;/code&gt;这一属性。&lt;/p&gt;

&lt;h4 id=&#34;等高布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等高布局&lt;/h4&gt;

&lt;p&gt;如果不用table，实现等高布局的最简单方式应该是&lt;code&gt;flex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还是直接上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;吧，我这里实现了图文混排下的等高。&lt;/p&gt;

&lt;h4 id=&#34;sticky-footer:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;sticky footer&lt;/h4&gt;

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/stickyfooter/&#34;&gt;总结过sticky footer的实现&lt;/a&gt;,以及&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/08/12&lt;/p&gt;

&lt;p&gt;说一个实际用到的场景吧，我们的前端框架是bootstrap，它的栅格系统是实现多列布局的常用工具，我以前&lt;a href=&#34;http://jiangshanmeta.github.io/post/bootstrap/grid/&#34;&gt;讲过它的具体实现&lt;/a&gt;，简单地说是基于浮动布局的。用栅格系统做展示列表的时候，如果每一列的高度不一致（毕竟指望各列图片文字高度一致属于别想了），熟悉浮动的同学应该能脑补出来会出现什么样的悲剧，那我最终的解决方案是使用表格中同一行中单元格等高这一属性解决问题的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——栅格系统</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/grid/</link>
      <pubDate>Sat, 25 Jun 2016 19:23:09 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/grid/</guid>
      <description>

&lt;p&gt;bootstrap的CSS部分中最出名的应该就是栅格系统了，它解决了网页中常见的多列布局问题。对应的实现其实并不是特别复杂，主要包括以下知识点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;盒模型&lt;/li&gt;
&lt;li&gt;浮动&lt;/li&gt;
&lt;li&gt;相对定位&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;基本概念:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;栅格系统的行（row）必须包裹在&lt;code&gt;.container&lt;/code&gt;或者&lt;code&gt;container-fluid&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}
@media (min-width: 768px) {
  .container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .container {
    width: 1170px;
  }
}
.container-fluid {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中看出bootstrap中移动优先的理念，默认的都是小屏下的样式，再逐步通过媒体查询实现大屏下的样式。&lt;code&gt;container&lt;/code&gt;和&lt;code&gt;container-fluid&lt;/code&gt;在小屏下的行为是一致的，但是在pad屏或者更大的屏幕下，前者表现为有固定宽度居中显示，而后者一直保持宽度100%，虽然我很好奇后者为什么要添加上&lt;code&gt;margin-left:auto;margin-right:auto;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而列的样式比较有趣&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.row {
  margin-right: -15px;
  margin-left: -15px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;row要包含在container中，container包含了15px的左右padding，row却用左右各-15px的margin撑了出去，抵消了container的padding，写这个框架的人在想什么？问题的答案在于列的样式以及列嵌套。在列的通用样式里，有这样的设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;padding-right: 15px;
padding-left: 15px;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想要实现列嵌套，例如如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-sm-9&amp;quot;&amp;gt;
    Level 1: .col-sm-9
    &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;col-xs-8 col-sm-6&amp;quot;&amp;gt;
        Level 2: .col-xs-8 .col-sm-6
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;col-xs-4 col-sm-6&amp;quot;&amp;gt;
        Level 2: .col-xs-4 .col-sm-6
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要内层的row抵消掉外层的col的padding。&lt;/p&gt;

&lt;h2 id=&#34;盒模型部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;盒模型部分&lt;/h2&gt;

&lt;p&gt;默认情况下box-sizing为content-box，bootstrap上来就重置了盒模型为border-box。为什么要这么做呢？因为栅格系统的每一列的宽度都是根据百分比计算得到的，如果使用默认的content-box，如果有的列加上border或者padding，布局直接会乱掉。基本上等分布局的实现离不开这一设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* {
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;浮动部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;浮动部分&lt;/h2&gt;

&lt;p&gt;如果让你实现多列布局，你想怎么办？最容易想到的就是浮动啊。bootstrap确实是使用浮动实现多列布局的。&lt;/p&gt;

&lt;p&gt;部分代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {
  float: left;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然使用了浮动，那么就免不了要处理浮动带来的盒子塌陷问题。具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container:after,
.container-fluid:after,
.row:after{
  display: table;
  content: &amp;quot; &amp;quot;;
  clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的时候我们需要对列进行偏移，bootstrap提供了&lt;code&gt;col-*-offset-*&lt;/code&gt;一系列类，实现原理是通过margin-left。&lt;/p&gt;

&lt;h2 id=&#34;相对定位部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;相对定位部分&lt;/h2&gt;

&lt;p&gt;一开始读bootstrap 源码的时候，发现列的公共样式里面有这么一条：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position: relative;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说相对定位是和绝对定位结合使用的，这里有没有绝对定位是干什么的呢？当我读到关于列顺序的代码的时候我就明白了。&lt;/p&gt;

&lt;p&gt;相对定位的元素，如果是使用top left right bottom ，其定位是相对于原来的位置进行定位。举个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.col-xs-push-6 {
  left: 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用此类后col相对于原来的位置向右偏移了50%。看起来是在模拟flex布局的order。然而我真的没在生产环境里用过，真的没有。&lt;/p&gt;

&lt;h2 id=&#34;响应式布局:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;响应式布局&lt;/h2&gt;

&lt;p&gt;作为一个前端框架，bootstrap显然要处理不同屏幕下的显示问题，所以使用了响应式布局。处于移动优先这一概念的考虑，bootstrap默认设施都是在手机小屏下，然后通过媒体查询实现其他较大屏幕的样式设置。当浏览器宽度超过了分界点，如果没有设置此区间的新样式，按照更小屏幕的样式显示。&lt;/p&gt;

&lt;p&gt;其实对于手机端来说，bootstrap一方面可能太重了，另一方面响应式布局也不见得是万能的。这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;对于bootstrap的css，目前觉得也就是它的栅格系统有必要说一下，其他的再说吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何将页脚固定在页面底部</title>
      <link>http://jiangshanmeta.github.io/post/stickyfooter/</link>
      <pubDate>Fri, 24 Jun 2016 20:05:51 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/stickyfooter/</guid>
      <description>

&lt;p&gt;在一个网页中通常会有页脚的设置。如果页面内容较少，看起来页脚就像是浮了起来，在浏览器的下面还有一块白色，显得非常难看。我不会告诉你我最近看到的新鲜的页面里还有这种问题，都是同行，给人个面子，不给链接了。那么如何解决这一问题呢？&lt;/p&gt;

&lt;h2 id=&#34;javascript方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;javascript方案&lt;/h2&gt;

&lt;p&gt;不难，请自行百度。然而我总是想能用css解决的绝对不用js。先约定一下页面结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
	&amp;lt;header id=&amp;quot;header&amp;quot;&amp;gt;

	&amp;lt;/header &amp;gt;
	&amp;lt;main id=&amp;quot;header&amp;quot;&amp;gt;

	&amp;lt;/main&amp;gt;
	&amp;lt;footer id=&amp;quot;footer&amp;quot;&amp;gt;

	&amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公共的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;table方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;table方案&lt;/h2&gt;

&lt;p&gt;这里所说的table并不是说html table，而是css table。在css的display属性中，有一堆关于table的值，比如&lt;code&gt;table&lt;/code&gt;,&lt;code&gt;table-row&lt;/code&gt;,&lt;code&gt;table-cell&lt;/code&gt;。这些值可以帮助我们像表格一样布局而不使用html table。这里用到的是&lt;code&gt;table&lt;/code&gt;和&lt;code&gt;table-row&lt;/code&gt;两个值。&lt;/p&gt;

&lt;p&gt;我们可以把整个body视为一个table，然后header、main、footer三部分视为table-row。并且让main占据100%高度。可能你觉得很奇怪如果main高度设为100%，那么header和footer的高度岂不是零了？但是table有许多神奇的特性，header和footer会正常显示。这里的header和footer的高度会变成恰能放下内容的高度，main占据剩余空间。因为table的话无论是宽度还是高度计算都比较复杂，web开发者所设置的width或者height都是参考值。&lt;/p&gt;

&lt;p&gt;这样你会发现依然没有实现固定在底部。因为body的高度现在是由内容决定的，我们要设置body的最小高度设为视口高度。可以采用100vh这么一个方案，如果担心兼容性问题，可以把高度设为百分比。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body{
	display:table;
	width:100%;
	min-height:100vh;
}
#main{
	display:table-row;
	height:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在线demo：&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;固定在底部的页脚——table方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flex方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;flex方案&lt;/h2&gt;

&lt;p&gt;flex作为布局神器，基本上你想到的用flex都能做。这里所需要的是两个属性&lt;code&gt;flex-direction&lt;/code&gt;和&lt;code&gt;flex-grow&lt;/code&gt;。我们需要把body作为 flex盒子，并把flex盒子方向设为column，把我们的主体内容的扩展属性设为1，header和footer不扩展，这样就会让主体内容自动填充空余部分。&lt;/p&gt;

&lt;p&gt;代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body{
	display:flex;
	flex-direction:column;
	min-height:100vh;
}
#main{
	flex-grow:1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在线demo：&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/flex.html&#34;&gt;固定在底部的页脚——flex方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结:57c3c18f56fe86510d201aa293fed882&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于如何实现固定在底部的页脚，其实也有许多方案，但是有各种各样的问题，比如footer的高度必须是固定的。我上面所说的两种纯CSS方案都不需要固定footer的高度，基本上可以直接拿到生产环境里用。另外，关于css table的使用自己还需要多多学习，希望近期能够写篇总结。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于CSS3 transition 的几个小tip</title>
      <link>http://jiangshanmeta.github.io/post/transitiontip/</link>
      <pubDate>Tue, 21 Jun 2016 20:19:53 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/transitiontip/</guid>
      <description>

&lt;p&gt;关于CSS3的transition一般写过一阵的基本玩法也都会了，这里收集一些transition的小细节&lt;/p&gt;

&lt;h2 id=&#34;关于伪元素的过渡:fe079bb6a643aa02f488f646a5d5f38e&#34;&gt;关于伪元素的过渡&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/pseudo/&#34;&gt;之前总结过伪元素的一些应用&lt;/a&gt;，但是没有提及如何使用伪元素进行过渡。
直接修改伪元素的属性或者给伪元素添加类名都是很折腾的。常见的改变伪元素的方案是给其父元素添加类名或者利用父元素的伪类。提到伪类，那么能否直接对伪元素本身应用伪类？比如:hover，希望伪元素hover的时候状态改变。然而尝试的结果是否定的。目前对其父元素添加类名或者伪类是对伪元素应用过渡的最简单可行的方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/transitiontip/pseudo.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;模拟input宽度的改变:fe079bb6a643aa02f488f646a5d5f38e&#34;&gt;模拟input宽度的改变&lt;/h2&gt;

&lt;p&gt;如果想利用硬件加速，避免重绘，我们一般要避免width、height、margin之类的属性过渡。然而，有的时候我们确实需要宽度变化的过渡，比如输入框在获取焦点的时候变长，失去焦点后宽度又恢复原状。&lt;a href=&#34;http://t.imooc.com/learn/42&#34;&gt;慕课网一个美化表单案例&lt;/a&gt;就提到了这么一种需求。想实现这一需求可以使用width、padding属性的过渡实现，但是免不了大量的重绘，从前端性能优化的角度来看实现地并不优雅。&lt;/p&gt;

&lt;p&gt;其实换一种思路，我们不见得让输入框真的变长，只要是输入框看起来变长了就行，毕竟我们的目的是加一个动画效果提升用户体验。于是就有了这么一个障眼法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;clipped&amp;quot; &amp;gt;
	&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
	&amp;lt;div class=&amp;quot;clip&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.clipped{
	position:relative;
	width:154px;
}
.clipped .clip{
	position:absolute;
	right:0;
	top:0;
	width:50px;
	height:25px;
	border:2px solid #ccc;
	border-left:0;
	border-radius:4px;
	/*pointer-events:none;*/
	z-index:-1;
	transition:0.4s linear;
}
.clipped input{
	width:150px;
	height:25px;
	border:2px solid #ccc;
	border-radius:4px;
	border-right:0px;
	
}
.clipped input:focus{
	outline:none;
	
}
.clipped input:focus ~.clip{
	transform:translate3d(40px,0,0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/transitiontip/clipping.html&#34;&gt;在线demo&lt;/a&gt;
基本原理是一个绝对定位的div，定位到输入框的右边，模拟输入框右边的样子，input框获得焦点的时候把这个div transform。具体的看代码。如果可以的话想用伪元素实现这个div，然而input并不支持伪元素。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解贝塞尔曲线之如何实现匀加/减速动画</title>
      <link>http://jiangshanmeta.github.io/post/cubicbezier/</link>
      <pubDate>Tue, 14 Jun 2016 19:24:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/cubicbezier/</guid>
      <description>

&lt;p&gt;如果要实现web动画，通常有三个方式，第一是使用gif图，第二是使用CSS3中的transition和animation，第三是使用javascript。gif图一般交给美术去制作，不需要coding，js实现web动画是一个比较成熟的方案了，它的特点是兼容性好，能控制的动画效果多，适合制作复杂的动画效果。随着CSS3的浏览器支持程度越来越高，使用CSS3写web动画也成为一个流行的方式。&lt;/p&gt;

&lt;p&gt;为了控制动画进行过程，CSS3为我们提供了缓动函数，分别为transition-timing-function和animition-timing-function (以下统称timing-function),通常用的是几个关键字属性：linear、ease、ease-in、ease-out、ease-in-out。&lt;/p&gt;

&lt;p&gt;linear是线性动画；ease是默认的动画效果，特点是先快后慢，时间50%的时候已经完成80%的动画效果了；ease-in是动画进行过程中一直加速；ease-out是动画进行过程中一直减速；ease-in-out和ease很相似，都是先加速后减速，但是时间50%的时候完成动画的50%；一般来说，如果没太大的追求这些关键字就足够了。有这种想法的可以直接点击右上角的那个X了。&lt;/p&gt;

&lt;p&gt;稍微高级一点的玩法是使用cubic-bezier,通过指定贝塞尔曲线的两个控制点控制缓动函数。其实三次贝塞尔曲线有四个控制点，然而对于CSS来说第一个控制点是(0,0)，第四个控制点是(1,1)，所以留给我们操作的只有两个控制点了。而且这两个控制点也是有限制的，横坐标∈[0,1]，纵坐标可以大于1。上面几个关键字其实是预定义好的贝塞尔曲线。&lt;/p&gt;

&lt;p&gt;这个贝塞尔曲线就是我们今天的主角。原始需求是：实现匀加/减速动画。最一开始的想法是使用js控制，好像也没什么难度，会高中物理的就能解决。后来我就想能不能用CSS实现这一效果，毕竟我的一个原则是能用CSS实现的绝对不用js。&lt;/p&gt;

&lt;p&gt;先上图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/beziercurve.jpg&#34; alt=&#34;贝塞尔曲线的物理含义&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用这张图说明一下对应的物理含义。横轴是时间进度，纵轴是动画进度。有高中物理水平的就能看得出来这不就是 *路程-时间曲线*嘛。所以曲线一阶导数的物理含义就是速度，二阶导数的物理含义就是加速度。想要实现匀加/减速动画，只要使二阶导数是一个不为零的常数就好了。&lt;/p&gt;

&lt;h4 id=&#34;前方高能预警-大量数学出没-请做好战斗准备:eec53d87b272616feb247dfa262869de&#34;&gt;前方高能预警，大量数学出没，请做好战斗准备&lt;/h4&gt;

&lt;p&gt;三次贝塞尔曲线公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/cubicbezier.jpg&#34; alt=&#34;三次贝塞尔曲线公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于CSS的限制 P0为(0,0)，P3为(1,1)将其带入方程并展开，可以得到对x,y方向的两个方程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation1.jpg&#34; alt=&#34;x,y方向的两个方程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们得到的是两个参数方程。要想得到y对x的二阶导数，需要下面的公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/derivative.jpg&#34; alt=&#34;参数方程二阶导数公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看不懂过程就不要在乎这些细节了，公式推导里有一步我应该曾经明白但我现在不明白。直接看结论，我们需要两个参数方程对t的一阶导数和二阶导数&lt;/p&gt;

&lt;p&gt;于是便有了下面的几个式子&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation2.jpg&#34; alt=&#34;一阶导数和二阶导数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;带入不明觉厉的公式，我们可以观察到，分母最高次项是六次，而分子最高次项是三次，要使结果为一个常数，六次项的系数要为零&lt;/p&gt;

&lt;p&gt;于是我们得到了第一个公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation3.jpg&#34; alt=&#34;第一个公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;将第一个公式带入二阶导数中，我们会发现分母最高次项为3，分子最高此项为2，和上面类似的思路，我们可以得到第二个公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation4.jpg&#34; alt=&#34;第二个公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两个方程联立我们可以解得&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation5.jpg&#34; alt=&#34;第一个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样分母就是一个常数了，分子还有一个一次项，所以&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation6.jpg&#34; alt=&#34;第二个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation7.jpg&#34; alt=&#34;第三个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意到&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/conclusion.jpg&#34; alt=&#34;第四个结论&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解CSS3中width新的几个关键字成员</title>
      <link>http://jiangshanmeta.github.io/post/css3width/</link>
      <pubDate>Mon, 30 May 2016 21:39:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css3width/</guid>
      <description>

&lt;p&gt;最近看了&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/&#34;&gt;张鑫旭大神的一片文章&lt;/a&gt;,介绍了&lt;code&gt;width&lt;/code&gt;属性的几个关键字成员：&lt;code&gt;fill-available&lt;/code&gt;、&lt;code&gt;max-content&lt;/code&gt;、&lt;code&gt;min-content&lt;/code&gt;、&lt;code&gt;fit-content&lt;/code&gt;。如果有不熟悉基本概念的链接都有了自己点过去看。他的那篇文章偏重于概念介绍，我想介绍一些细节以及应用&lt;/p&gt;

&lt;h2 id=&#34;fill-available:3de20cc74c1f43aee615802a184084e5&#34;&gt;fill-available&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.fill-available{
	width:fill-available;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个关键字使得盒子尽可能填充满剩余空间，听起来很像是&lt;code&gt;width:100%;&lt;/code&gt;。那么直接用&lt;code&gt;width:100%;&lt;/code&gt;行吗,至少没有兼容问题啊？&lt;/p&gt;

&lt;p&gt;其实是分情况的。如果对这个盒子设置了&lt;code&gt;box-sizing:border-box&lt;/code&gt;,那真的无所谓，用什么都行。但是默认的&lt;code&gt;box-sizing&lt;/code&gt;是*content-box*在这种情况下如果有margin padding border的，此时使用&lt;code&gt;width:100%&lt;/code&gt;就会面临超出父盒子的问题，但是&lt;code&gt;width:fill-available&lt;/code&gt;就没有这个问题。&lt;/p&gt;

&lt;p&gt;//像我们这种基于bootstrap改改用的，已经有了&lt;code&gt;*{box-sizing:border-box;}&lt;/code&gt;，所以好像没什么用。&lt;/p&gt;

&lt;h2 id=&#34;max-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;max-content&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;max-content的行为表现可以这么理解，假设我们的容器有足够的宽度，足够的空间，此时，所占据的宽度是就是max-content所表示的尺寸。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说实话至今我没想起来这个能用来干什么。如果内容很长，会出现横向滚动条，对于web横向滚动条并不是什么好的设计。如果内容并不多，它的表现和下面的fit-content是一致的。真·找不到应用场景。&lt;/p&gt;

&lt;h2 id=&#34;min-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;min-content&lt;/h2&gt;

&lt;p&gt;这个就比较有意思了，我们可以用来自适应内部元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;&amp;quot; class=&amp;quot;responsive-wrap&amp;quot;&amp;gt;
	&amp;lt;img src=&amp;quot;http://jiangshanmeta.github.io/demo/myWork/csssecrets/2.jpg&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以往常见的图片展示效果是规定外层div的大小，然后图片大小跟着外层div来。bootstrap里的一个实现是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;img-responsive{
	display: block;
	max-width: 100%;
	height: auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我偏要父元素的宽度跟着子元素走，以往我可能会这么做：给外层div加个&lt;code&gt;display:table;&lt;/code&gt;利用其尺寸收缩的特性。有点hack的味道在这里。而且这么做健壮性不够，如果我想给图片下面加上几行描述，尤其是字数要长长长，这时候&lt;code&gt;display:table;&lt;/code&gt;的效果，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/css3width/table.html&#34;&gt;点开自己看&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果把div的width设为min-content,就能在长描述的存在下，依然做到父元素大小跟着图片大小走。结果请点击上面链接&lt;/p&gt;

&lt;h2 id=&#34;fit-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;fit-content&lt;/h2&gt;

&lt;p&gt;这个属性的性质和上面说的&lt;code&gt;display:table;&lt;/code&gt;最终表现可以说一模一样。我没找到区别。&lt;/p&gt;

&lt;h2 id=&#34;结束语:3de20cc74c1f43aee615802a184084e5&#34;&gt;结束语&lt;/h2&gt;

&lt;p&gt;好像也就min-content用处多点，其他的我还在想能做什么特别而且能用到的事情&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>结构与样式相分离之CSS图形</title>
      <link>http://jiangshanmeta.github.io/post/cssshape/</link>
      <pubDate>Sun, 29 May 2016 18:19:27 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/cssshape/</guid>
      <description>&lt;p&gt;做前端的应该都听说过“结构与样式相分离”这一句话。最简单的理解是HTML负责结构，CSS负责样式。然而，自己在实际项目中并没有很好地应用这句话，经常为了实现某个特殊样式加上一堆div。&lt;/p&gt;

&lt;p&gt;比如说之前实现的一个效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/cssshape1.png&#34; alt=&#34;彩色的边框&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当时实现这个效果的基本思路是用border画出外面的环，由于角度问题，所以还要加上一个transform转45deg，这样边框就画出来了，但是内部的人物头像也随着父元素，所以也要加上一个transform抵消父元素转动的影响。&lt;/p&gt;

&lt;p&gt;这样虽然实现了，但是总感觉不够优雅，加的额外的HTML和CSS略多，而仅仅是为了实现一个环。&lt;/p&gt;

&lt;p&gt;再次安利一下我最近看的书&lt;strong&gt;CSS Secrets&lt;/strong&gt;，这本书还没看完，但是给我不少启发。之前写过一篇&lt;a href=&#34;http://jiangshanmeta.github.io/post/pseudo/&#34;&gt;小的总结&lt;/a&gt;，谈到了伪元素的一些应用。我想，用伪元素做一些装饰性的工作，可以减少冗余的div和CSS，增强重用性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;img-outer-circle&amp;quot;&amp;gt;
	&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.img-outer-circle{
	position:relative;
	width:135px;
	height:135px;
}
.img-outer-circle::before{
	content:&#39;&#39;;
	position:absolute;
	top:-10px;
	left:-10px;
	right:-10px;
	bottom:-10px;
	border-radius:50%;
	border-width:5px;
	border-style:solid;
	border-color:#3d8ceb #3d8ceb #f1cb2f #f1cb2f ;
	-webkit-transform:rotate(-45deg);
	transform:rotate(-45deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，HTML还是以前的，因为像是&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;这样的自闭合标签没有伪元素这一说法，不能直接加在图片上。CSS上实现边框的思路还是和以前一样，但是因为不是对整个div进行transform，所以不用对图片再进行处理了。目前看不出来什么特别的优势。但是试想如果来了需求，说要给图片加个出场动画，如果用animation实现的话，免不了各种transform，transform各种影响，免不了出些奇奇怪怪的bug。//不要问我怎么知道的&lt;/p&gt;

&lt;p&gt;这里提一句，本来是想用&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;的伪元素写一个边框的，但是没能实现，上面的理由说的太简单了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/21296044&#34;&gt;知乎上有个相关问题&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-&amp;lt;img&amp;gt;```也不是完全不能应用伪元素，比如[利用伪元素美化加载失败的图片](http://web.jobbole.com/86079/)&#34;&gt;

伪元素能做的装饰性的东西其实很多，上面是伪元素结合border做了一个彩色的边框，其实还可以做一些三角形、菱形、梯形之类的。三角形和菱形就不说了，简单说一下梯形。

在**CSS Secrets**这本书中，作者采用的方法伪元素+transform3d，伪元素的方案我是赞同的，但是transform3d一方面有些兼容性问题，另一方面3d效果理解起来比较困难，尤其是结合transform-origin的3d效果。于是，我决定用border一条路走到黑。

因为border经常用来实现各种图形，我[结合Vue实现了一个查看border能做什么的demo](http://jiangshanmeta.github.io/demo/myWork/org/vue/v_box.html)，想象力再丰富也比不上直接拖拖拽拽看效果来的快。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.tab{
    position:relative;
    display:inline-block;
    padding-right:8px;
    padding-left:8px;
    margin-right:25px;
    text-align:center;
}&lt;/p&gt;

&lt;p&gt;.tab::before{
    z-index:-1;
    content:&amp;ldquo;;
    position:absolute;
    top:0;
    left:-10px;
    right:-10px;
    bottom:0;
    width:100%;
    height:0;
    border-style:solid;
    border-width:0 10px 18px 10px;
    border-color:transparent transparent yellowgreen transparent;
}
```&lt;/p&gt;

&lt;p&gt;这样也可以实现梯形标签。其实如果浏览器支持嵌套伪元素这个问题就更好解决了。不知道那时候那群玩one div的会搞出什么来。&lt;/p&gt;

&lt;p&gt;先写到这里吧，以后在实践中如果有用到的再补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前端需要知道的WEB知识（1）</title>
      <link>http://jiangshanmeta.github.io/post/browser1/</link>
      <pubDate>Mon, 23 May 2016 21:49:52 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/browser1/</guid>
      <description>&lt;p&gt;之前无意间触发了一个bug，让我开始接触浏览器相关的知识。搞web开发的如果不了解浏览器的基本知识，不了解一个网页是如何形成的，以及如何展示的，基本上也就到天花板了。&lt;/p&gt;

&lt;p&gt;今天并不想从发起一个http请求开始讲起，战线会拉的太长。就从web服务器返回页面开始讲起吧。&lt;/p&gt;

&lt;p&gt;浏览器接收到服务器返回的HTML，开始按顺序进行解析，先是head部分，再是body部分。&lt;/p&gt;

&lt;p&gt;在head部分，可能会遇到&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;,会发起相应的http请求对应的文件，在相应的文件下载之后，渲染才会继续进行，在这一段期间浏览器的状态是一片白。一些常见的web优化就是根据这个原因进行的。比如对CSS文件和JS文件进行压缩，这样可以减少请求文件的体积，从而减少传输时间。又比如CSS文件或者JS文件该合并的进行合并，这样可以减少http请求，而http请求会带来额外的开销。还有是一些js文件从head中移除，放到body中，这样可以先让用户看点东西，不至于一片白然后一怒之下关网页。&lt;/p&gt;

&lt;p&gt;然后就是解析body进行渲染了。这里我想借助一幅图说明&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/browser.png&#34; alt=&#34;浏览器渲染原理&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简单来说就是HTML解析器生成DOM，CSS解析器生成CSSOM，然后层叠，布局绘制，最终展示成为我们所看到的页面。&lt;/p&gt;

&lt;p&gt;再上张图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/browser2.png&#34; alt=&#34;浏览器渲染原理&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中大部分的工作对于web开发者来说都是不可控的，只有控制DOM和并不好用的样式操作对web开发者是可控的，其余的都是只能按照规则来。然而&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20939640&#34;&gt;知乎上有篇文章指出这一现状可能会被改善&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然绘制的过程目前是无法控制只能看浏览器心情，有些基本概念还是要了解的。&lt;/p&gt;

&lt;p&gt;当DOM的变化影响了元素的几何属性，浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会受到影响。浏览器会使渲染树的受到影响的部分失效，并重新构造渲染树。这个过程称为&lt;strong&gt;重排(reflow)&lt;/strong&gt;。完成重排后，浏览器会重新绘制受到影响的部分到屏幕中，这个过程称为&lt;strong&gt;重绘(repaint)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;显然，重排一定会导致重绘，重绘却不一定意味着重排。从前端性能优化的角度来看，我们需要尽可能减少重绘重排这样昂贵的操作。从CSS的角度上来讲，似乎能做的不多，我能想到的是利用&lt;code&gt;outline&lt;/code&gt;或者&lt;code&gt;box-shadow&lt;/code&gt;这样不影响元素几何属性的属性模拟一些几何属性，比如边框，不能减少重绘但是能减少重排。可能说的不太明白，还是上代码吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.box{
	width:300px;
	margin-left:20px;
}
.box:hover{
	border:1px solid #ccc;
	margin-left:19px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将CSS优化成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.box{
	width:300px;
	margin-left:20px;
}
.box:hover{
	outline:1px solid #ccc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js部分减少重绘重排能做的就比较多了。&lt;/p&gt;

&lt;p&gt;1.缓存布局信息，减少对布局信息的请求。可能会有人问了，难道对布局信息请求会强制重绘？我想引用*高性能JavaScript*中的一段话回答&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。然而，你可能会（经常不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.批量处理样式操作。利用cssText属性可以合并一些操作。如果可以通过添加类名改变样式的话尽可能控制类名而不是具体的style。&lt;/p&gt;

&lt;p&gt;3.利用documentFragment优化。这个我现在用的不多。&lt;/p&gt;

&lt;p&gt;4.还有搞前端最喜欢玩的，能用CSS实现的就不要用JS。不细说，自己体会。&lt;/p&gt;

&lt;p&gt;从浏览器的重绘重排扯到了前端性能优化，我觉得还是扯回来吧&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;http://jiangshanmeta.github.io/post/browser/&#34;&gt;上篇文章&lt;/a&gt;中，我提到了线程问题。当时找的资料有点杂，我觉得还是引用一些书籍上的话加深理解吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大多数浏览器让一个单线程共用于执行javascript和更新用户界面。每个时刻只能执行其中一种操作，这意味着当javascript代码正在执行时用户界面无法相应输入，反之亦然。当javascri代码执行时，用户界面处于“锁定”状态。&lt;/p&gt;

&lt;p&gt;用于执行javascript和更新用户界面的进程通常被称为“浏览器UI线程”。UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提出来并运行。这些任务要么是运行javascript代码，要么是执行UI更新，包括重绘和重排。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>一个bug引发的血案—浏览器基本渲染</title>
      <link>http://jiangshanmeta.github.io/post/browser/</link>
      <pubDate>Sun, 22 May 2016 17:05:41 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/browser/</guid>
      <description>&lt;p&gt;作为全知乎写bug水平第0的人，最近我又写了一个bug。&lt;/p&gt;

&lt;p&gt;当时的需求是这样的：用js和CSS3画一个时钟，能动的那种。很早很早之前，我用&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/canvas/canvasWatch.html&#34;&gt;canvas实现过这个需求&lt;/a&gt;,然而canvas毕竟需要各种写js，而且实现上也需要大量的计算，于是我就想能不能用尽可能少的js结合CSS实现。&lt;/p&gt;

&lt;p&gt;于是开始分解问题，我想实现的时钟和本地时间相对应，无论如何都要把Date对象拿出来然后求出当前的时分秒，然后进行初始偏转，再利用web动画进行转动即可，三个指针虽然在实际生活上有联系，但是把这三个割裂开会降低复杂度。只要求出当时的秒数，然后画出秒针的动画，99%的工作就完成了，时针和分针的效果只需要复制粘贴就能解决。&lt;/p&gt;

&lt;p&gt;HTML是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;clock-wrap&amp;quot; id=&amp;quot;clock-wrap&amp;quot;&amp;gt;
	&amp;lt;div class=&amp;quot;second&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.clock-wrap{
	width:300px;
	height:300px;
	border-radius:50%;
	background-color:#f1f1f1;
	position:relative;
}
.second{
	position:absolute;
	width:4px;
	height:40%;
	top:10%;
	left:calc(50% - 2px);
	transform-origin:bottom center;
	transition:all 60s linear;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就出现了基本的时钟的样子了，剩下的就是写js了。然而，当时着急去洗澡，于是写下了bug。我试着回忆当时的思路，然而我觉得当时自己脑子里已经进了水。当时想的是根据当前时间算出初始偏离角度，写一条样式，然后根据初始偏移角度算出最终角度，写一条过渡后的样式，然后添加类名，利用类名触发过渡。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function cssclock(wrapId){
	var time = new Date();
	var s = time.getSeconds();

	var sDOM = document.getElementById(&amp;quot;second&amp;quot;);
	var wrap = document.getElementById(wrapId);
	var style = document.createElement(&amp;quot;style&amp;quot;);
	var str = &amp;quot;&amp;quot;;
	str += &amp;quot;.second{transform:rotate(&amp;quot;+  6*s +&amp;quot;deg)}&amp;quot;;
	str += &amp;quot;.go .second{ transform:rotate(&amp;quot; + (6*s+360) + &amp;quot;deg)}&amp;quot;;
	style.innerHTML = str;
	document.head.appendChild(style);
	wrap.classList.add(&amp;quot;go&amp;quot;);
}
cssclock(&amp;quot;clockwrap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然是有bug的，按照这个思路实现根本不会有过渡效果，就算有也只是转一圈。转一圈很好理解，这是我脑子里进水了整个思路错了，然而为什么根本没有过渡呢？&lt;/p&gt;

&lt;p&gt;看控制台那里秒针样式秒针的转动的值直接是最终值，于是我便百思不得其解了。后来尝试着把最后一行给表的盒子加上类名去掉，然后在控制台手动给这个盒子加上类名，发现可以触发过渡。&lt;/p&gt;

&lt;p&gt;于是我就脑洞大开了，难道是要在添加样式表完成的回调里执行给盒子添加类名的操作，然而appendChild没有回调啊，那干脆加个定时器过一会再加类名好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setTimeout(function(){
 	document.getElementById(wrapId).classList.add(&amp;quot;go&amp;quot;);
},0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实践证明确实是可行的，然而诡异的事情又来了：当我把定时器的时间设为 &lt;strong&gt;0&lt;/strong&gt; 依然可以触发过渡，于是我就不明觉厉了。&lt;/p&gt;

&lt;p&gt;然后我想起来之前看到的&lt;a href=&#34;https://github.com/gomeplusFED/blog/blob/master/2016-04/do-you-really-understand-how-to-write-a-countdown-by-javascript.md&#34;&gt;关于定时器的文章&lt;/a&gt;,里面谈到了js的线程问题，于是我便顺着这条线索开始找。&lt;/p&gt;

&lt;p&gt;中间的曲折没什么意思，还是说结论吧。&lt;/p&gt;

&lt;p&gt;因为浏览器内部有多个线程，比如负责画页面的线程，比如处理js的线程。画页面的线程 GUI渲染线程大体上是以每秒60次的速度工作的，这就是定时器常见的 16.7ms （1000/60）的由来,然而，渲染线程和js引擎线程是互斥的，这是为什么呢？因为js很有可能对DOM操作，这期间免不了获取一些渲染上的属性，比如width之类的，如果两个一起工作，js获取的就可能不准，所以两者是互斥的。&lt;/p&gt;

&lt;p&gt;我上面的js代码里，将新的样式添加进去，我本来是期望秒针按照&lt;code&gt;.second&lt;/code&gt;类的样式进行渲染，然后给盒子加上&lt;code&gt;.go&lt;/code&gt;这一个类，触发过渡。但是按照上面的分析，直到js结束都没有进行页面的渲染，js结束后整个盒子已经加上了&lt;code&gt;.go&lt;/code&gt;类，渲染开始，因为已经存在&lt;code&gt;.go&lt;/code&gt;类了，渲染按照过渡结束的进行。&lt;/p&gt;

&lt;p&gt;那么我用的定时器是起到什么作用？定时器设定时间为0，并不是立即去做，而是在0ms之后加入到js的todo队列中，也就是说添加完样式表后，js暂时休息，之前本应该干活但因为js干活而休息的GUI渲染开始工作，进行初始偏移，js的队列里出现定时器中要运行的代码，进行添加类名操作，触发过渡。&lt;/p&gt;

&lt;p&gt;那有没什么办法在js里强制渲染一次再进行后续操作呢？有啊，比如说取一个宽度就能强制渲染一次，这是定时器方案的一个替代方案。这也是为什么用js做动画要缓存一些变量的原因，为了减少不必要的重绘重排。以前too young，too simple啊，还需要提高知识水平。&lt;/p&gt;

&lt;p&gt;语文不太好，引用别人的话总结一下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。&lt;/li&gt;
&lt;li&gt;GUI渲染线程负责渲染浏览器界面，当界面需要重绘（repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。&lt;/li&gt;
&lt;li&gt;事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;扯了这么多也没有写到最开始的需求该如何实现，反正实现了，用了些最近学到的技巧，然而这个bug让我学到的更多，毕竟前端不仅仅是写写页面写写js，浏览器的工作原理也要理解一些的。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>居中的常见实现</title>
      <link>http://jiangshanmeta.github.io/post/center/</link>
      <pubDate>Mon, 16 May 2016 21:26:45 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/center/</guid>
      <description>

&lt;p&gt;约定HTML结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div &amp;gt;
	&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-水平居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;1.水平居中&lt;/h2&gt;

&lt;p&gt;实现水平居中其实并不难，而且有多个可靠地方案可以使用。&lt;/p&gt;

&lt;h4 id=&#34;margin方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;margin方案&lt;/h4&gt;

&lt;p&gt;用过bootstrap的人会很熟悉这么一个类名&lt;code&gt;.center-block&lt;/code&gt;，这是实现居中的一个类名，具体实现是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-block{
	display:block;
	margin-left:auto;
	margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这应该是学习页面布局最基本的水平居中方案了，也没什么额外操作&lt;/p&gt;

&lt;h4 id=&#34;绝对定位方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;p&gt;基本实现是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-x-ab{
	position:absolute;
	left:50%;
	transform:translateX(-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是应用了translate如果值为百分比，则参考于自身。如果为了水平居中而这么做就有点折腾了，然而这一方案可以扩展到垂直居中和水平垂直都居中。这样做的缺点是父元素需要处理子元素绝对定位带来的问题。在实践中，制作h5页面慎用这种方法居中，因为h5页面经常有动画，动画离不开transform,两者同时存在会看到很诡异的问题。&lt;/p&gt;

&lt;h4 id=&#34;文本居中方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;文本居中方案&lt;/h4&gt;

&lt;p&gt;需要将要居中元素的父元素设定&lt;code&gt;text-align:center;&lt;/code&gt;需要居中的元素的display要设定为&lt;code&gt;inline-block&lt;/code&gt;,需要处理文本居中带来的影响，这一方案感觉用的不多。&lt;/p&gt;

&lt;h4 id=&#34;flex方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;1.你为什么不用margin方案的方案&lt;/p&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex&lt;/code&gt; 子元素img&lt;code&gt;margin-left:auto;margin-right:auto;&lt;/code&gt;我的评价见小标题&lt;/p&gt;

&lt;p&gt;2.感觉有点大材小用的方案&lt;/p&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex:justify-content:center;&lt;/code&gt;评价如小标题
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/animation/animation_spin.html&#34;&gt;上个例子&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-垂直居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;2.垂直居中&lt;/h2&gt;

&lt;p&gt;相较于水平居中，垂直居中相比较而言就有点难度了&lt;/p&gt;

&lt;h4 id=&#34;单行文字垂直居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;单行文字垂直居中&lt;/h4&gt;

&lt;p&gt;在我刚开始学习写页面的时候，就听说过让&lt;strong&gt;line-height&lt;/strong&gt;和&lt;strong&gt;height&lt;/strong&gt;值相等即可使单行文字垂直居中，最开始只是从使用的角度看这个问题，没有深入思考过，后来&lt;a href=&#34;http://t.imooc.com/learn/403&#34;&gt;张鑫旭大神告诉我们&lt;/a&gt;，这只是伪垂直居中。从工程实践角度这已经够用了，不要在意这些细节&lt;/p&gt;

&lt;h4 id=&#34;绝对定位方案-1:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;p&gt;在水平居中中提到可以使用绝对定位实现水平居中，同样也可以使用绝对定位实现垂直居中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-y-ab{
	position:absolute;
	left:50%;
	transform:translateY(-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然要处理绝对定位带来的后果，考虑到垂直居中方案并不多，这不失为一个好方案。&lt;/p&gt;

&lt;h4 id=&#34;table方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;table方案&lt;/h4&gt;

&lt;p&gt;请参阅&lt;a href=&#34;https://css-tricks.com/centering-in-the-unknown/&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;flex方案-1:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex&lt;/code&gt; 子元素img&lt;code&gt;margin-top:auto;margin-right:bottom;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然你也可以折腾flex的相关属性去，说的就是某些关于对其的属性。&lt;/p&gt;

&lt;h2 id=&#34;3-水平垂直都居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;3.水平垂直都居中&lt;/h2&gt;

&lt;h4 id=&#34;绝对定位方案-2:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-xy-ab{
	position:absolute;
	top:50%;
	left:50%;
	transform:translate(-50%,-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有代码有真相，就是结合水平、垂直居中的绝对定位方案&lt;/p&gt;

&lt;h4 id=&#34;flex方案-2:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;父元素&lt;code&gt;display:flex;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;子元素&lt;code&gt;margin:auto;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也不用去折腾各种对齐的属性&lt;/p&gt;

&lt;h4 id=&#34;水平文本居中-垂直table-的大杂烩:903435e3d66e261bf87738ad6f965a5c&#34;&gt;水平文本居中 + 垂直table 的大杂烩&lt;/h4&gt;

&lt;p&gt;如果真考虑兼容性的话，这似乎是兼容性最好的方案了
然而，需要多写一层标签&lt;/p&gt;

&lt;p&gt;水平垂直居中算是水平居中和垂直居中的综合使用，上个&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/center.html&#34;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-基于视口的居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;4.基于视口的居中&lt;/h2&gt;

&lt;p&gt;常见的各种模态框基本上是相较于视口水平垂直居中的，其实我最早知道模态框的实现的时候它的居中是通过js计算得到的。作为 &lt;em&gt;能用CSS实现的就绝对不用js实现&lt;/em&gt; 神教教徒，这个需求肯定要尝试使用CSS解决。&lt;/p&gt;

&lt;h4 id=&#34;transform方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;transform方案&lt;/h4&gt;

&lt;p&gt;基本上是上边的绝对定位方案的翻版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position:fixed;
top:50%;
left:50%;
transform:translate(-50%,-50%);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相关&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/center/center.css&#34;&gt;CSS下载&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>伪元素的应用总结</title>
      <link>http://jiangshanmeta.github.io/post/pseudo/</link>
      <pubDate>Mon, 16 May 2016 20:00:31 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/pseudo/</guid>
      <description>

&lt;dl&gt;
&lt;dt&gt;CSS中的伪元素CSS中经常能玩出花样的东西，它包括::first-letter、::first-line、::before、::after、::selection,作为强迫症晚期患者我觉得还应该出现::last-letter和::last-line，然而并没有，我很伤心。&lt;/dt&gt;
&lt;/dl&gt;

&lt;p&gt;::first-letter、::first-line、::selection通常是用来对文字进行装饰，比如::first-letter实现首字母下沉效果,::selection实现萌娘百科的黑幕效果，目前我还没发现这三个能玩出太大的花样。这里主要总结::before和::after两个伪元素的花样。一直在纠结如何整理这些东西，最后还是决定按照表现分类，毕竟CSS关系的是样式。&lt;/p&gt;

&lt;h2 id=&#34;clearfix:dc5e44b284002f2c33b84936afab53a1&#34;&gt;clearfix&lt;/h2&gt;

&lt;p&gt;写过几个网页的人就会知道clearfix，毕竟是布局相关的东西，实现起来有不少，经典的是&lt;code&gt;.clearfix::after{content:&#39;&#39;;display:table;clear:both;}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;字体图标:dc5e44b284002f2c33b84936afab53a1&#34;&gt;字体图标&lt;/h2&gt;

&lt;p&gt;网页上的小图标是很常见的设计，通常的实现方案有图片和字体图标两种，作为并不喜欢切图的我显然更倾向于使用字体图标这种方式。目前用过的字体图标有&lt;a href=&#34;http://v3.bootcss.com/components/#glyphicons-glyphs&#34;&gt;bootstrap&lt;/a&gt;里面自带的，还有&lt;a href=&#34;http://fontawesome.dashgame.com/&#34;&gt;font-awesome&lt;/a&gt;两个，基本能满足需求，如果不能满足请说服美术。&lt;/p&gt;

&lt;h2 id=&#34;一条线:dc5e44b284002f2c33b84936afab53a1&#34;&gt;一条线&lt;/h2&gt;

&lt;p&gt;为了一条线写一个标签通常来说是很不划算的，除非你很爱敲键盘。
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/cateList/cateList.html&#34;&gt;我之前写的一个分类列表&lt;/a&gt;这里结合使用了:checked伪类和::after伪元素，实现了无JS的tab切换效果。&lt;/p&gt;

&lt;p&gt;之前也见过在tab切换中，使用::after伪元素画一条线表示当前tab的。&lt;/p&gt;

&lt;p&gt;在bootstrap里的面包屑导航里，也采用了::before伪元素做一条分割线。&lt;/p&gt;

&lt;p&gt;还有见过走马灯效果里，用::after做分割的。然而最近没怎么见过走马灯效果了，这个设计目测已经过气了。&lt;/p&gt;

&lt;h2 id=&#34;背景图形:dc5e44b284002f2c33b84936afab53a1&#34;&gt;背景图形&lt;/h2&gt;

&lt;h4 id=&#34;模拟多背景-实现多重边框:dc5e44b284002f2c33b84936afab53a1&#34;&gt;模拟多背景、实现多重边框&lt;/h4&gt;

&lt;p&gt;在多背景支持性还不够好的时候，就有人试图用&lt;a href=&#34;http://nicolasgallagher.com/multiple-backgrounds-and-borders-with-css2/&#34;&gt;::before和::after来实现多背景&lt;/a&gt;。这项技术其实已经有点老了，然而其中提到的&lt;strong&gt;用伪元素实现多边框&lt;/strong&gt;依然具有实战意义。&lt;/p&gt;

&lt;h4 id=&#34;阴影效果:dc5e44b284002f2c33b84936afab53a1&#34;&gt;阴影效果&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://t.imooc.com/learn/240&#34;&gt;CSS3实现“图片阴影”效果&lt;/a&gt;,给慕课网打个广告吧。如果对阴影效果扩展一下，就可以模拟弹出层的背景。&lt;/p&gt;

&lt;h4 id=&#34;边框内圆角:dc5e44b284002f2c33b84936afab53a1&#34;&gt;边框内圆角&lt;/h4&gt;

&lt;p&gt;这一效果是在*CSS Secrets*一书中看到的，基本原理是border-radius+定位+z-index。&lt;/p&gt;

&lt;h4 id=&#34;各种图形:dc5e44b284002f2c33b84936afab53a1&#34;&gt;各种图形&lt;/h4&gt;

&lt;p&gt;之前的日志中，我利用::before实现了&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;自适应的正方形&lt;/a&gt;,同时这一原理也可以用来实现长宽比一定的矩形。&lt;/p&gt;

&lt;p&gt;伪元素实现三角形早就成为前端的必备技能了，不细说了。&lt;/p&gt;

&lt;p&gt;在三角形的基础上也能实现其他的图形，&lt;em&gt;CSS Secrets&lt;/em&gt; 一书中提到了如何使用伪元素实现平行四边形和菱形，主要利用了transform+绝对定位。&lt;/p&gt;

&lt;p&gt;更多的图形可以参见 &lt;a href=&#34;https://css-tricks.com/examples/ShapesOfCSS/&#34;&gt;css tricks&lt;/a&gt;,然而我觉得很多只是做着玩而不能在生产环境下使用。&lt;/p&gt;

&lt;h4 id=&#34;结合filter实现毛玻璃效果:dc5e44b284002f2c33b84936afab53a1&#34;&gt;结合filter实现毛玻璃效果&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://dabblet.com/gist/d9f243ddd7dbffa341a4&#34;&gt;局部毛玻璃模糊效果的实现&lt;/a&gt;，从&lt;strong&gt;CSS Secrets&lt;/strong&gt;中看到的&lt;/p&gt;

&lt;h2 id=&#34;扩大响应区域:dc5e44b284002f2c33b84936afab53a1&#34;&gt;扩大响应区域&lt;/h2&gt;

&lt;p&gt;其实这也不算是样式了，已经是交互部分了。伪元素结合定位就可以扩展原来元素的相应区域，结合:hover伪类应该能做出一些东西，目前没见过眼前一亮的例子&lt;/p&gt;

&lt;h2 id=&#34;模拟float-center:dc5e44b284002f2c33b84936afab53a1&#34;&gt;模拟float:center&lt;/h2&gt;

&lt;p&gt;浮动其实是没有center这一值的，但是一个居中的文字环绕效果确实挺漂亮。别人的&lt;a href=&#34;https://css-tricks.com/float-center/&#34;&gt;demo&lt;/a&gt;,使用具有一定宽度和高度的伪元素浮动占据位置，再用绝对定位把图片定位到伪元素占据的地方。这个效果我觉得很有创意。&lt;/p&gt;

&lt;p&gt;伪元素能做的东西很多，然而自己接触的还比较少，上面所说的就是我目前所见到的。其实结合:hover伪类，:checked伪类，以及transition和animation，是可以做一些小东西出来的，至少可以取代一些用js才能写出来的效果。以后看到效果试着能否只是用CSS实现。&lt;/p&gt;

&lt;p&gt;update 2016/05/19
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/dopant/cssclock/cssclock.html&#34;&gt;使用伪元素结合CSS3动画做的时钟&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/05/29
&lt;a href=&#34;http://jiangshanmeta.github.io/post/cssshape/&#34;&gt;使用伪元素结合border实现彩色环和梯形&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/07/07
&lt;a href=&#34;https://css-tricks.com/centering-in-the-unknown/&#34;&gt;伪元素在垂直居中的应用&lt;/a&gt;。这是一篇发布在css-tricks上的文章，显示利用&lt;code&gt;table&lt;/code&gt;+&lt;code&gt;vertical-align:middle&lt;/code&gt;实现了垂直居中。考虑到&lt;code&gt;vertical-align&lt;/code&gt;依赖于&lt;code&gt;table-cell&lt;/code&gt;或&lt;code&gt;inline-block&lt;/code&gt;或&lt;code&gt;inline&lt;/code&gt;，这篇文章又利用&lt;code&gt;inline-block&lt;/code&gt;实现了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>