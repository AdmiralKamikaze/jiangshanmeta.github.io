	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> mongodb的复杂查询和聚合 &middot; jsmeta </title>
  
  <link rel="stylesheet" href="http://jiangshanmeta.github.io/css/index.css">
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

</head>

	<body class=" article-body">
		<nav class="article-nav">
			<a href="http://jiangshanmeta.github.io/">Home</a>
			<a href="http://jiangshanmeta.github.io/demo/index.html">前端作品</a>
			<a href="http://jiangshanmeta.github.io/categories/index.html">日志分类</a>
		</nav>
		<div class="article ">
			<div >
			  <h1 class="text-center">mongodb的复杂查询和聚合</h1>
			  <p >Sun, Oct 23, 2016</p>
			      

<p>之前<a href="http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/">总结过mongodb常用的增删查改</a>，随着使用的深入自己的工作不在局限在简单地增删查改上，还处理一部分的统计性工作。统计所需要的查询条件就比较复杂了，而mongodb的聚合又是mongodb的一个很大的话题了。这里算是对工作中遇到的一些情况进行总结吧。因为平时都是通过php操作数据库，所以下面的代码都是php，不过并不影响我想表达的。</p>

<h2 id="1-限制数组长度查询:233b6dd901ca06898e3895bff0f956d4">1.限制数组长度查询</h2>

<p>mongodb可以存储数组，我遇到的一个需求是筛选出数组长度大于某个值的。首先想到的是使用<code>$size</code>，但是<code>$size</code>不支持<code>$gt</code>这样的操作，仅支持等于某个长度。</p>

<p>最终的解决方案是查询数组中第N个元素是否存在，比如限制field字段数组中至少有一个元素，则where条件如下：</p>

<pre><code>['fiele.0'=&gt;['$exists'=&gt;true]]
</code></pre>

<h2 id="2-addtoset在聚合中的使用:233b6dd901ca06898e3895bff0f956d4">2.$addToSet在聚合中的使用</h2>

<p>需求场景是这样的：在流水表里有一些数据是进货记录，每条这样的数据都包含店铺id和供应商id，现在需要拿出每家供应商所供货的店铺。暴力的做法是拿出数据来在php处理（写起来并不复杂），然而用聚合实现更简单。</p>

<pre><code>$this-&gt;db-&gt;clear();
$match = [
	'$match'=&gt;[
		'typ'=&gt;1
	]
];
$group = [
	'$group'=&gt;[
		'_id'=&gt;'$supplier',
		'orgs'=&gt;['$addToSet'=&gt;'$orgId']
	]
];
$rst = $this-&gt;db-&gt;aggregate('bPeijianFlow',[$match,$group]);
</code></pre>

<p>上面是实现代码，首先在<code>bPeijianFlow</code>这张表中只有typ为1的才是进货记录，据此筛选，然后我们要根据供应商id进行聚合，所以聚合中的<code>_id</code>是<code>$supplier</code>，因为一个供应商对一家店可能多次供货，但我们仅需保留一次门店id，所以采用<code>$addToSet</code>而不是<code>$push</code>，把每家供应商供货的店铺id保存到<code>orgs</code>这个数组中。</p>

<h2 id="3-根据多个字段进行聚合:233b6dd901ca06898e3895bff0f956d4">3.根据多个字段进行聚合</h2>

<p>上面的聚合仅仅是根据供应商一个字段进行，我遇到的场景是这样的：有一张用户考试的表，存储着用户id，考试类型，需要根据用户和考试类型进行聚合，拿到每个用户每个考试类型通过（通过是在筛选处理的）的次数。</p>

<pre><code>$match = array(
    '$match'=&gt;[
        'status'=&gt;2,
    ],
);
$group = array(
    '$group'=&gt;[
        '_id'=&gt;array('adminuserId'=&gt;'$adminuserId','typ'=&gt;'$typ'),
        'count'=&gt;array('$sum'=&gt;1),
        'name'=&gt;array('$first'=&gt;'$uName'),
        'orgId'=&gt;array('$first'=&gt;'$orgId'),
    ]

);

$rst = $this-&gt;db-&gt;aggregate('aExam',[$match,$group]);
</code></pre>

<p>首先是筛选通过的考试，用status为2表示，然后是进行聚合，聚合是根据<code>adminuserId</code>和<code>typ</code>两个字段来的，所以<code>_id</code>是一个array，而不是上面那个聚合的string，<code>'count'=&gt;array('$sum'=&gt;1),</code>是用来统计数量的，剩下的两行是用来做展示数据用的。</p>

<h2 id="4-聚合中的管线化操作:233b6dd901ca06898e3895bff0f956d4">4.聚合中的管线化操作</h2>

<p>目前遇到的大部分业务场景下的聚合都是两步：先筛选，再聚合。上面两个例子都是这个模式。mongodb的聚合其实是有一个管线化操作，即上一步的输出作为下一步的输入，在上面例子中是match的输出作为group的输入。
复杂场景所需要的管线化操作就比较多了，先举两个实际场景</p>

<p>第一个场景是这样的，有一张订单表，一个用户可以有多个订单，现在需要统计用户订单数量分布，即我需要统计一张订单的用户有多少、两张订单的用户有多少&hellip;</p>

<pre><code>$this-&gt;db-&gt;clear();
$match = [
    '$match'=&gt;[
        'crmId'=&gt;['$exists'=&gt;true],
        'status'=&gt;['$gte'=&gt;50],
    ]
];
$group = [
    '$group'=&gt;[
        '_id'=&gt;'$crmId',
        'count'=&gt;['$sum'=&gt;1],
    ]
];
$group2 = [
    '$group'=&gt;[
        '_id'=&gt;'$count',
        'sum'=&gt;['$sum'=&gt;1],
    ]
];
$sort = [
    '$sort'=&gt;[
        '_id'=&gt;-1,
    ]
];
$rst = $this-&gt;db-&gt;aggregate('bBook', [$match,$group,$group2,$sort]);
</code></pre>

<p>上面是实现代码，match条件不说了，第一个group是根据用户(crmId)进行聚合，得到每个用户拥有的订单数量，然后再一次聚合以订单数量为<code>_id</code>进行聚合，得到订单数量分布。</p>

<p>第二个场景也是处理订单表，需要统计有两张及以上订单的用户的数量，下面是代码：</p>

<pre><code>$this-&gt;db-&gt;clear();
$match = [
    '$match'=&gt;[
        'crmId'=&gt;['$exists'=&gt;true],
        'status'=&gt;['$gte'=&gt;50],
        '$or'=&gt;[
            ['totalPrice'=&gt;['$gt'=&gt;0]],
            ['totalJiesuan'=&gt;['$gt'=&gt;0]],
        ],
    ],
];
$group = [
    '$group'=&gt;[
        '_id'=&gt;'$crmId',
        'count'=&gt;['$sum'=&gt;1],
    ]
];
$match2 = [
    '$match'=&gt;[
        'count'=&gt;['$gte'=&gt;2],
    ]
];
$rst = $this-&gt;db-&gt;aggregate('bBook',[$match,$group,$match2]);
$data['daodianTwiceUserCount'] = count($rst['result']);
</code></pre>

<p>第一次聚合也是根据用户id(crmId)进行聚合，得到每个用户订单数量，到这里和第一个场景的操作一样，然后再向下操作不是聚合而是进行筛选，我们要筛选出订单数量大于等于2的。</p>

			</div>


		</div>
		<script>
console.log("联系我吧   540118044@qq.com");
</script>   
  </body>
</html>
