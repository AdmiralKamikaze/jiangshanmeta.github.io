	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> 重新学习最好的编程语言 &middot; jsmeta </title>
  
  <link rel="stylesheet" href="http://jiangshanmeta.github.io/css/index.css">
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

</head>

	<body class=" article-body">
		<nav class="article-nav">
			<a href="http://jiangshanmeta.github.io/">Home</a>
			<a href="http://jiangshanmeta.github.io/demo/index.html">前端作品</a>
			<a href="http://jiangshanmeta.github.io/categories/index.html">日志分类</a>
		</nav>
		<div class="article ">
			<div >
			  <h1 class="text-center">重新学习最好的编程语言</h1>
			  <p >Thu, Aug 25, 2016</p>
			      

<p>从前端入的行，现在前端和后端php一起写，虽然日常的业务逻辑对我来说很轻松，但是感觉自己被框架宠坏了。业务中用的框架是封装过的CI，想着从一个空的CI（3.1.0）开始做起，至少要脱离现在高度封装过的框架。跟着教程看起，发现了自己对于php很多地方理解不足，这里一条条记录下来。</p>

<h2 id="1-构造函数:960e085aadb29182f9448019a6b3c8f1">1.构造函数</h2>

<p>CI框架默认的<code>controller</code>是welcome，不过业界习惯还是index，我就照着welcome这个<code>controller</code>写了一个index的<code>controller</code>,然后就报错了。我说我这种动不动就建个<code>controller</code>写个几百行的咋建个<code>controller</code>就报错啊。然后百度了一下有人在博客里说是因为这是CI的保留名称所以会报错，可是项目中明明就有controller名为index的啊。后来我发现根本不是这么回事。</p>

<p>问题出在<strong>构造函数</strong>上。在php4的时代，构造函数是和类名同名的函数，但是在php5引入了<code>__construct</code>的概念作为构造函数，同时为了保证向下兼容所以如果没有找到<code>__construct</code>就把同名函数作为构造函数。在这里，我的controller名称是index，方法名称也是index，并且没有<code>__construct</code>所以会把index方法当成构造函数。解决方案也就很明了了：写上构造函数</p>

<pre><code>function __construct(){
	parent::__construct();
}
</code></pre>

<p>因为继承的基类<code>CI_Controller</code>里有构造函数，显然不作死的方案是调用基类的构造函数。看了一眼项目里的代码，我们是一个类继承了<code>CI_Controller</code>，调用了<code>CI_Controller</code>的构造函数，然后做了一些其他的操作。</p>

<h2 id="2-view-template:960e085aadb29182f9448019a6b3c8f1">2.view &amp;&amp; template</h2>

<p>CI是一个MVC框架，最开始我只会画画页面写写js，所以最一开始做的是view层。关于CI的view层<a href="http://codeigniter.org.cn/user_guide/general/views.html">官方文档里已经给出了很好的说明</a>，仅仅从用的角度来说已经足够了。然而如果不对其进行封装很容易做一些重复性的操作，比如说声明对header的加载，声明对footer的加载，而真正业务逻辑对应的页面加载只需要一行，对此我们引入了一个新的类<code>template</code>，把那些header、footer之类的全都放在模板里，在模板里输出真的业务逻辑界面。</p>

<p>下面代码是从项目代码里按照自己的书写习惯稍微改造的，如果不明白其中一些CI的东西可以看上面链接。</p>

<pre><code>class Template{
	public function __construct(){
		$this-&gt;templateData = [];
		$this-&gt;CI = &amp;get_instance();
	}

	public function set($name,$value){
		$this-&gt;templateData[$name] = $value;
	}

	public function load($template,$view,$view_data = array(),$return = FALSE){
		$this-&gt;set('contents',$this-&gt;CI-&gt;load-&gt;view($view,$view_data,TRUE));
		return $this-&gt;CI-&gt;load-&gt;view($template,$this-&gt;templateData,$return);
	}
}
</code></pre>

<p>我们把这个类放在<code>application/libraries</code>目录下<code>template.php</code>文件中，并在autoload中的libraries数组中添加<code>template</code>,这样我们就可以愉快的使用<code>template</code>类了，例如以下代码：</p>

<pre><code>$this-&gt;template-&gt;load(&quot;default_page&quot;,&quot;index/index&quot;);
</code></pre>

<h2 id="3-subclass:960e085aadb29182f9448019a6b3c8f1">3.subclass</h2>

<p>面向对象一大特征是继承，对于controller里的类也适用。CI官方文档里所讲的controller所继承的都是<code>CI_Controller</code>，如果需求简单确实足够了，想要封装一层的话可以让这个子类继承自<code>CI_Controller</code>，在这个类里面进行所需要的封装，controller里的类再继承自这个子类。</p>

<p>如果熟悉面向对象的话上面所说的实现起来并不复杂，唯一的问题是目录。其实CI已经考虑过这个问题了。把自己封装好的类放到<code>application/core</code>目录下，文件名称为xxController，然后在<code>application/config/config.php</code>中找到<code>$config['subclass_prefix']</code>，将其值赋为刚才文件名中的xx，然后你就会发现这个文件会自动被加载（至于具体的子类名称，对于我这种命名困难户显然是选文件名啦）。话说回来，真不嫌麻烦还可以每个controller里手动加载这个文件（何必呢）。</p>

<h2 id="4-uri类:960e085aadb29182f9448019a6b3c8f1">4.URI类</h2>

<p><a href="http://codeigniter.org.cn/user_guide/libraries/uri.html">URI类</a>可以帮助从URI字符串中获得一些基本的信息，结合项目中所用到的说一下。</p>

<p>根据CI的路由规则，第一个参数是控制器的名称，第二个参数是方法名，有的时候会用到这两个名称，最开始的时候我是在controller的构造函数手动声明控制器名称是啥，在具体方法里手动声明方法名是啥。看了文档个人觉得可以封装到上面提到的subclass的构造函数中，毕竟用到的还是比较多。</p>

<pre><code>$this-&gt;controller_name = $this-&gt;uri-&gt;segment(1)==null?'index':$this-&gt;uri-&gt;segment(1);
$this-&gt;method_name = $this-&gt;uri-&gt;segment(2)==null?'index':$this-&gt;uri-&gt;segment(2);
</code></pre>

<p>除此之外还用到比较多的是<code>$this-&gt;uri-&gt;uri_string()</code>，这个主要是用在重定向上（因为样式问题以及兼容性、推广等问题对于手机和PC做了两个子站）。</p>

<h2 id="5-mongodb-cimongo:960e085aadb29182f9448019a6b3c8f1">5.mongoDB &amp;&amp; cimongo</h2>

<p>WEB开发离不开数据库，没记错的话新手是首推mysql，然后我就点错科技树学了mongoDB。开始连接数据库吧。</p>

<p>先说个mongoDB的可视化工具<a href="https://robomongo.org/">robomongo</a>，从一开始写后端程序就在用，毕竟图形界面大法好。</p>

<p>然后说一下用的库<a href="https://github.com/vesparny/cimongo-codeigniter-mongodb-library">cimongo-codeigniter-mongodb-library</a>，目测作者弃坑了。这个库为我们封装了许多操作数据库的方法。我们需要把config目录下的cimongo.php移动到ci项目 application/config目录下，然后把libraries目录下的cimongo文件夹移动到我们的ci项目中application/libraries目录下。迁移过来之后需要进行一些配置操作，打开cimongo.php配置host、port和db，然后和上面的template类一样作为autoload的libraries，这样我们就可以通过<code>$this-&gt;cimongo</code>操作数据库了。在实际项目中目测是因为觉得这样写比较长在subclass中做了这个操作</p>

<pre><code>$this-&gt;db = $this-&gt;cimongo;
</code></pre>

<p>这样的话我们就可以进行数据库操作了，现在可以随手插入两条数据看看了，然而这样操作数据库是比较危险的操作，随后我们需要进行的是在model层对数据操作进行封装。</p>

			</div>


		</div>
		<script>
console.log("联系我吧   540118044@qq.com");
</script>   
  </body>
</html>
