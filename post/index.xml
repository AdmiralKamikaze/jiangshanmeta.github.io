<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on jsmeta</title>
    <link>https://jiangshanmeta.github.io/post/</link>
    <description>Recent content in Posts on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Apr 2017 19:19:25 +0800</lastBuildDate>
    <atom:link href="https://jiangshanmeta.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何优雅地上网？</title>
      <link>https://jiangshanmeta.github.io/post/cs/computernetwork/</link>
      <pubDate>Mon, 17 Apr 2017 19:19:25 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/cs/computernetwork/</guid>
      <description>

&lt;p&gt;这算是我对计算机网络的学习总结吧。我准备以一个网页请求为例，串起来相关的计算机网络协议。&lt;/p&gt;

&lt;h2 id=&#34;计算机网络层级结构:35224f1d25546748f0558e134bd8e19d&#34;&gt;计算机网络层级结构&lt;/h2&gt;

&lt;p&gt;一般计算机网络的相关书籍上来就会讲网络的层次结构，一般而言自顶向下可以分为：应用层、传输层、网络层、数据链路层、物理层。对我而言主要关心的是前三个层次，对于数据链路层我会捎带一提。&lt;/p&gt;

&lt;p&gt;应用层通过数据交互完成特定的任务，如超文本传输(HTTP)、文件传输(FTP)、邮件传输(SMTP)等。&lt;/p&gt;

&lt;p&gt;传输层提供了应用进程逻辑通信，这一层主要包括TCP和UDP两个协议。UDP在网络层的基础上只做了必要的复用/分用和校验，不提供可靠传输、不提供面向连接的服务。TCP提供了更多的服务，它是面向连接的，提供可靠传输，顺便还提供了流量控制和拥塞控制。为了实现可靠传输，TCP有许多相关的机制，包括校验和、字节流编号、确认反馈、重传、定时器。&lt;/p&gt;

&lt;p&gt;网络层提供了主机间的逻辑通信。这一层包含了网际协议IP、一堆路由选择协议、一个辅助控制协议ICMP。&lt;/p&gt;

&lt;p&gt;数据链路层将网络层提供的数据封装成帧，实现节点之间的通信。&lt;/p&gt;

&lt;h2 id=&#34;分用:35224f1d25546748f0558e134bd8e19d&#34;&gt;分用&lt;/h2&gt;

&lt;p&gt;上面提到的每一层都包含多个协议，对于应用层一个协议可能被多个应用进程使用，那下层是如何知道把数据交给那个上层服务呢，即分用问题。&lt;/p&gt;

&lt;p&gt;对于数据链路层，链路层帧有一个类型字段，通过这个字段决定交付给哪个网络层协议。&lt;/p&gt;

&lt;p&gt;对于网络层，也有一个类似的协议字段，用于指出交付给哪个传输层协议。&lt;/p&gt;

&lt;p&gt;对于传输层协议，情况就不一样了，因为多个应用进程可以使用同一个协议，这时我们需要的是对应用进程进行编号，于是就有了端口号。通过端口号，传输层找到应用进程。&lt;/p&gt;

&lt;h2 id=&#34;寻址:35224f1d25546748f0558e134bd8e19d&#34;&gt;寻址&lt;/h2&gt;

&lt;p&gt;上面的分用的前提是报文已经到了这个端系统，那报文是如何找到这个端系统的呢？这里需要IP地址和MAC地址。MAC地址是对网卡接口的标识(数据链路层)，这是一个硬件地址。IP地址是网络层接口的编址(网络层)，一般是由DHCP协议自动分配获得，IP地址在某种程度上可以理解为对一个端系统的编址。其实MAC地址也可以理解为对端系统的编址，毕竟找到网卡接口了，就相当于找到这台主机了。那为啥需要两个地址？一个原因是MAC地址相对来说是完全无序的，路由功能实现起来过于复杂，IP地址一定程度上解决了这个问题。&lt;/p&gt;

&lt;p&gt;到这里关于计算机网络最基础的概念已经介绍完了，然而离我们获得一个页面还有一些准备工作。首先要做的是连上网，获得IP地址，完成这项工作的是DHCP协议。&lt;/p&gt;

&lt;h2 id=&#34;dhcp:35224f1d25546748f0558e134bd8e19d&#34;&gt;DHCP&lt;/h2&gt;

&lt;p&gt;DHCP是一个应用层协议，它的主要作用是用来获取IP地址、获取子网掩码、获取默认路由器地址、获取默认DNS服务器地址。DHCP所应用的传输层协议是UDP，毕竟UDP可以提供广播服务，TCP只能进行端到端的连接。&lt;/p&gt;

&lt;p&gt;当我们想要连接到网上时，本机没有IP地址，也不知道DHCP服务器(或者说DHCP服务器代理，但是对于端系统而言它起到了DHCP服务器的作用)地址，更不知道DHCP服务器的MAC地址，我们只知道源端口号和目的端口号，这两个是DHCP协议所规定的，还有源MAC地址，这是网卡出厂就决定好的。源IP地址全0表示本机、目的IP地址全1表示本网广播地址、目的MAC地址全1表示广播，这是DHCP查询报文的部分信息。&lt;/p&gt;

&lt;p&gt;DHCP服务器通过广播发送了DHCP响应报文，这样本机就可以获得一个IP地址了，同时获得的还有子网掩码、默认路由器地址和DNS服务器地址。但是一个网络中可能含有多个DHCP服务器，而且UDP不提供可靠传输，所以本机还要广播一个DHCP请求报文，表明自己决定使用了哪个IP地址。最后DHCP服务器还要有个DHCP确认报文。&lt;/p&gt;

&lt;h2 id=&#34;dns:35224f1d25546748f0558e134bd8e19d&#34;&gt;DNS&lt;/h2&gt;

&lt;p&gt;现在上网的准备工作已经完成，我们可以打开浏览器输入某个域名了。输入完之后，我们需要获得域名到IP地址的映射关系(不考虑缓存)才能发起HTTP请求，这就需要DNS了。DNS也是一个工作在应用层的协议，它所应用的传输层协议是UDP。&lt;/p&gt;

&lt;p&gt;DNS请求报文源端口号好说，毕竟是自身的应用进程表示，目的端口号是协议规定好的。向下走我们需要填写源IP地址和DNS服务器IP地址，这两个字段我们已经通过DHCP获得了。然后是目的MAC地址，上面的DHCP服务因为是广播，所以MAC地址全1，这里我们的MAC地址怎么填？这要看DNS服务器和本机的关系了，如果是在一个子网内，那我们直接填DNS服务器的MAC地址，如果不在一个子网内，我们需要填默认路由器的MAC地址。怎么判断是否在一个子网呢？还记得子网掩码吗？解决了获取谁的MAC地址，我们要回答的是怎么获取MAC地址。获取MAC地址所需要的是ARP。&lt;/p&gt;

&lt;p&gt;ARP这个协议有人认为应该分到网络层，也有人认为应该分到数据链路层，还有人认为是在网络层和数据链路层之间属于跨层的协议。这些学院派的争执我们没必要关心，我们只需注意到这个协议实现的是IP地址到MAC地址的映射。&lt;/p&gt;

&lt;p&gt;现在请求报文的目的MAC地址字段我们已经知道怎么填了，剩下的就是发出报文，交给DNS服务器，然后默默等待响应报文。这里DNS服务器所要做的就不说了，从端系统角度看这就是个黑盒。&lt;/p&gt;

&lt;h2 id=&#34;http:35224f1d25546748f0558e134bd8e19d&#34;&gt;HTTP&lt;/h2&gt;

&lt;p&gt;HTTP请求所依赖的传输层协议是TCP，我们需要建立连接，但这个连接是只保留在端系统上的逻辑连接，并不存在于中间的链路上。&lt;/p&gt;

&lt;p&gt;源端口号是系统提供的，目的端口号是协议规定好的。源IP地址是通过DHCP获取的，目的IP地址是通过DNS获取的。源MAC地址是网卡出厂自带的，目的MAC地址是通过ARP获得的默认路由器MAC地址(一般情况下本机和服务器不在一个子网内)。然后报文被交付到了路由器。&lt;/p&gt;

&lt;p&gt;在路由器数据包会部分拆开，然后路由器实现路由和转发(超复杂的路由转发功能就这么被我一笔带过了)。每穿过一个路由器，目的MAC地址就会被修改，但是目标IP地址不会被修改(不考虑NAT)，这就是需要MAC地址和IP地址的第二个原因：IP地址是为主机到主机的逻辑通信服务的，MAC地址是为节点间的通信服务的。&lt;/p&gt;

&lt;p&gt;最终我们的这个请求到达了服务器，然后服务器作出相应，我们获得HTTP响应报文。&lt;/p&gt;

&lt;h2 id=&#34;结语:35224f1d25546748f0558e134bd8e19d&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;到这里浏览网页所需要的最基本的计算机网络协议已经串起来了。一些辅助的协议，如ICMP、NAT我没有提及，但并不代表这些协议不重要。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为CI添加Service层——记一次失败的脑洞</title>
      <link>https://jiangshanmeta.github.io/post/php/service/</link>
      <pubDate>Sat, 04 Mar 2017 19:08:31 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/php/service/</guid>
      <description>&lt;p&gt;CI是一个MVC框架，业务逻辑在controller和model层上。随着业务复杂度的提升，一些本来在controller层的代码被逐渐移到了model层，以实现复用，到这里一切都很美好，然而model层越来越臃肿了，更为严重的是在model层调用其他model越来越多。
于是就想着在controller层和model层之间再插一个Service层，在Service层实现多个model的逻辑交互。这样一些在controller层的逻辑下放到service层，一些model层的逻辑，尤其是调用其他model的上调至service层。&lt;/p&gt;

&lt;p&gt;CI本身不提供service层，但是拓展起来并不困难，主要要做的是在加载器上添加一个加载service的方法，这个本身没什么难度，就不放代码了，顺手要写的一个是service的基类，虽然并没有什么特殊的方法(说不定以后能扩展呢)，但是可以把model基类的那个&lt;code&gt;__get&lt;/code&gt;方法抄过来，service层就这么出来了。按照上边的说法，把controller的逻辑下放，把model的逻辑上调，这些本身都没什么特殊的。&lt;/p&gt;

&lt;p&gt;对于业务逻辑，可以现在controller里把model层实例化出来，有需要初始化的需要连数据库加载数据顺便校验，然后把model传入到service层，在service层做具体的业务逻辑(据说这叫桥接模式)，controller主要负责数据的校验和与前端的数据交互，这么写确实可以。&lt;/p&gt;

&lt;p&gt;但是又觉得没什么用处，对于没那么复杂的业务逻辑加一个service层属于食之无味弃之可惜，而且对于小团队来说这个增加了工作量。&lt;/p&gt;

&lt;p&gt;不过，写代码最重要的是开心。&lt;/p&gt;

&lt;p&gt;另外，关于service层，我觉得 &lt;a href=&#34;https://segmentfault.com/q/1010000003849810/a-1020000003851204&#34;&gt;这个答案说的很好&lt;/a&gt;，引用两句&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你的某个业务逻辑，需要用到多个model，就放到service层里面去，如果只是这个model自己的事，跟其它的model没有任何关系，就放到model里面就好。如果你的系统本来就很小，业务逻辑也超级简单，也不存在长期演进迭代的需求，随你怎么高兴怎么写都行。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>21天并不能精通underscore.js</title>
      <link>https://jiangshanmeta.github.io/post/js/underscore/</link>
      <pubDate>Tue, 21 Feb 2017 19:27:11 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/underscore/</guid>
      <description>

&lt;p&gt;underscore.js是一个javascript库，它提供了一系列实用功能。在介绍具体的功能之前，需要重新学习几个基本概念。&lt;/p&gt;

&lt;h2 id=&#34;基本概念:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;首先要学习的是&lt;strong&gt;高阶函数&lt;/strong&gt;，高阶函数本身是一个函数，它的参数中包含函数，或者返回一个函数。听起来比较抽象，我们举一个实际的例子吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var property = function(key) {
	return function(obj) {
	  return obj == null ? void 0 : obj[key];
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据文档描述，这个函数返回一个新函数，新函数返回传入任何对象的key属性。上面的property函数就是一个高阶函数，除此之外，对这个函数还有一些可说的。比如说&lt;strong&gt;闭包&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;property函数每次被调用的时候都会创建一个新的执行上下文，其中key被赋值为我们传入的值，比如说underscore会内置一个方法&lt;code&gt;getLength&lt;/code&gt;传入的就是length，当函数走到return的时候，返回新函数，但是这个key还不能被释放掉，因为我们会在新函数中用到这个key，闭包算是老生常谈的了，常常在一起提及的还有作用域链、内存泄漏，不多说了。&lt;/p&gt;

&lt;p&gt;第三个要了解的新概念是&lt;strong&gt;偏函数&lt;/strong&gt;，偏函数是相对于原函数而言的，偏的意思是部分，原函数的部分参数或者变量被预置形成的新函数就是偏函数。underscore.js中提供了&lt;code&gt;_.partial&lt;/code&gt;方法，它相当于一个偏函数工厂，原料是原函数，生成偏函数。看下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	var self = baseCreate(sourceFunc.prototype);
	var result = sourceFunc.apply(self, args);
	if (_.isObject(result)) return result;
	return self;
};
_.partial = function(func) {
var boundArgs = slice.call(arguments, 1);
var bound = function() {
  var position = 0, length = boundArgs.length;
  var args = Array(length);
  for (var i = 0; i &amp;lt; length; i++) {
    args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
  }
  while (position &amp;lt; arguments.length) args.push(arguments[position++]);
  return executeBound(func, bound, this, this, args);
};
return bound;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，我们在partial中可以预填一些参数，如果想跳过某些参数可以用&lt;code&gt;_&lt;/code&gt;占位，在执行的的时候会用相应的参数替换的。&lt;/p&gt;

&lt;p&gt;需要先说明的基本概念就这些，然后我要从函数相关的函数讲起了。&lt;/p&gt;

&lt;h2 id=&#34;函数相关的函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;函数相关的函数&lt;/h2&gt;

&lt;p&gt;你可能会奇怪为啥我要从函数相关的函数开始说，按照文档或者源码应该先说整体结构或者集合啊，因为看到作者写的关于函数的函数我怀疑我以前写的是假javascript。&lt;/p&gt;

&lt;h4 id=&#34;bind:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.bind&lt;/h4&gt;

&lt;p&gt;函数执行的时候有一个执行上下文，通过作用域链我们可以一级一级向上访问变量，直到全局作用域，bind的作用就是改变执行上下文。在jQuery中绑定执行上下文的方法是&lt;code&gt;jQuery.proxy&lt;/code&gt;，它那里用的是apply方法，在underscore中用的是bind方法。这两个其实差异挺大的，apply/call会立即执行函数，而bind方法仅仅是绑定执行上下文，不会立即执行，所以jQuery源码在外面又包了一层函数。其实我们可以这么看：apply和bind方法都能改变执行上下文，apply同时还做了调用函数，包了一层函数会推迟绑定的时间，直到外层包裹函数被调用的时候才执行绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy: function( fn, context ) {
	var tmp, args, proxy;
	if ( typeof context === &amp;quot;string&amp;quot; ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}
	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !jQuery.isFunction( fn ) ) {
		return undefined;
	}
	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};
	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是jQuery的代码，函数内部的那个&lt;code&gt;proxy&lt;/code&gt;就是我说的包的一层函数。而underscore的做法是直接使用原生的bind方法，如果没有原生的bind方法就用一个兼容函数，兼容函数的基本思路和jQuery的是一致的。我们去看&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;MDN上bind方法的文档&lt;/a&gt;，其中提到bind方法的一个作用是偏函数，想想也对，bind调用的时候不仅仅可以绑定作用域，而且可以传参，这样返回的新函数确实是偏函数，这里或许会加深你对偏函数的理解。&lt;/p&gt;

&lt;h4 id=&#34;memoize:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.memoize&lt;/h4&gt;

&lt;p&gt;这个函数是个工厂函数，返回的新函数具有缓存结果的能力。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.memoize = function(func, hasher) {
	var memoize = function(key) {
	  var cache = memoize.cache;
	  var address = &#39;&#39; + (hasher ? hasher.apply(this, arguments) : key);
	  if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	  return cache[address];
	};
	memoize.cache = {};
	return memoize;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码并不难理解，以前我也写过具有缓存功能的函数，思路都是一致的，作者进一步抽象，做了一个缓存函数工厂，使得输出的函数每一个都具有缓存能力。这里同时提供了一个可选的hasher参数，用来生成缓存的键。&lt;/p&gt;

&lt;p&gt;用处很多了，文档中给的例子是递归，为了防止栈溢出。&lt;/p&gt;

&lt;h4 id=&#34;throttle:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.throttle&lt;/h4&gt;

&lt;p&gt;这个函数能够控制函数的执行频率，保证至少间隔wait时间才能执行一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.throttle = function(func, wait, options) {
	var context, args, result;
	var timeout = null;
	var previous = 0;
	if (!options) options = {};
	var later = function() {
	  previous = options.leading === false ? 0 : _.now();
	  timeout = null;
	  result = func.apply(context, args);
	  if (!timeout) context = args = null;
	};
	return function() {
	  var now = _.now();
	  if (!previous &amp;amp;&amp;amp; options.leading === false) previous = now;
	  var remaining = wait - (now - previous);
	  context = this;
	  args = arguments;
	  if (remaining &amp;lt;= 0 || remaining &amp;gt; wait) {
	    if (timeout) {
	      clearTimeout(timeout);
	      timeout = null;
	    }
	    previous = now;
	    result = func.apply(context, args);
	    if (!timeout) context = args = null;
	  } else if (!timeout &amp;amp;&amp;amp; options.trailing !== false) {
	    timeout = setTimeout(later, remaining);
	  }
	  return result;
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，基本原理是利用时间戳记录上次执行时间，这点其实好理解，比较复杂的是配置参数&lt;code&gt;leading&lt;/code&gt;和&lt;code&gt;trailing&lt;/code&gt;。
在默认条件下两者均为undefined，在这一条件下触发函数，func被调用，在wait时间内触发都不会调用func，直到wait时间结束后才会被调用(对应的参数是最后一次触发时的参数)。leading为undefined，trailing为false，则在调用的时候func被调用，wait时间内多次触发没有效果。leading为false，trailing为undefined，则在wait时间结束func才会被调用，期间的触发会改变context和args。然后我们可以看到&lt;code&gt;if (!timeout) context = args = null;&lt;/code&gt;，这句话其实是为了优化性能，减少闭包占用的内存。&lt;/p&gt;

&lt;h4 id=&#34;debounce:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.debounce&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;_.debounce = function(func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function() {
	  var last = _.now() - timestamp;

	  if (last &amp;lt; wait &amp;amp;&amp;amp; last &amp;gt;= 0) {
	    timeout = setTimeout(later, wait - last);
	  } else {
	    timeout = null;
	    if (!immediate) {
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  }
	};

	return function() {
	  context = this;
	  args = arguments;
	  timestamp = _.now();
	  var callNow = immediate &amp;amp;&amp;amp; !timeout;
	  if (!timeout) timeout = setTimeout(later, wait);
	  if (callNow) {
	    result = func.apply(context, args);
	    context = args = null;
	  }

	  return result;
	};
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照文档的说法，返回 function 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 wait 毫秒之后。基本思路是有一个标识上次触发的时间戳，然后比较时间看能否执行。这个请结合时间轴理解。我记得Vue1里面变淡那里有类似的概念，好像Vue2去掉了。&lt;/p&gt;

&lt;h4 id=&#34;negate:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.negate&lt;/h4&gt;

&lt;p&gt;返回一个断言函数的相反版本，这个函数在内部经常被调用，思路上没什么难的，但是作者做了一步抽象成为了函数工厂。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.negate = function(predicate) {
	return function() {
	  return !predicate.apply(this, arguments);
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;delay:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.delay&lt;/h4&gt;

&lt;p&gt;这个函数相比较之下可说的不多了，直接上源码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.delay = function(func, wait) {
	var args = slice.call(arguments, 2);
	return setTimeout(function(){
	  return func.apply(null, args);
	}, wait);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;before-after-once:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.before _.after _.once&lt;/h4&gt;

&lt;p&gt;这三个函数是和函数调用次数有关的，after是被触发times次之后才调用func，before是最多只能调用times次(不含times，所以我觉得很奇怪)，once只是before的特殊情况，可以看到源码里once是利用partial将before加工生成的偏函数。&lt;/p&gt;

&lt;p&gt;关于函数的函数每一个都是高阶函数，都返回新的处理过的函数，每一个具体的功能其实或多或少都实现过，但是抽象能力没有作者这么高。&lt;/p&gt;

&lt;h2 id=&#34;集合相关函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;集合相关函数&lt;/h2&gt;

&lt;p&gt;集合相关函数基本上都会用到迭代器，而用户传入的迭代器不仅仅可以是一个函数，对象、字符串、数字、甚至不传都可以，underscore在内部会做统一处理，使其变成一个函数的形式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var optimizeCb = function(func, context, argCount) {
	if (context === void 0) return func;
	switch (argCount == null ? 3 : argCount) {
	  case 1: return function(value) {
	    return func.call(context, value);
	  };
	  case 2: return function(value, other) {
	    return func.call(context, value, other);
	  };
	  case 3: return function(value, index, collection) {
	    return func.call(context, value, index, collection);
	  };
	  case 4: return function(accumulator, value, index, collection) {
	    return func.call(context, accumulator, value, index, collection);
	  };
	}
	return function() {
	  return func.apply(context, arguments);
	};
};

var cb = function(value, context, argCount) {
	if (value == null) return _.identity;
	if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	if (_.isObject(value)) return _.matcher(value);
	return _.property(value);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在源码的一开始，一开始读的时候会感觉莫名其妙，我来一一解读。cb函数是用来将各种用户传入的迭代器转换成内部能够使用的迭代器的。首先，如果用户不传迭代器，默认迭代器就是&lt;code&gt;_.identity&lt;/code&gt;，这个函数返回与传入参数相等的值，真的很没用，而且听着描述就能顺手把这个函数实现掉。这个函数被_.compact调用过，虽然我觉得后者也没啥用。然后第二类参数是函数，这应该是最常见的情况了，在内部对函数做了优化(optimizeCb)，顺手说下这个奇怪的optimizeCb，初读的时候会发现switch里返回的函数和最后默认返回的函数干的事同一件事情，为啥还要写这么多相似的代码？查了一下我的结论是魔术变量arguments有性能上的问题，这里还一点是&lt;code&gt;void 0&lt;/code&gt;，一般很少见人用这个啊，他这里考虑的是undefined可能会被篡改。下一种类型是Object(含array)，他这里返回的是matcher函数生成的偏函数，偏函数用于检测传入的新对象是否包含这里的对象value。最后一种情况是字符串、数字，property函数的具体实现已经在最开始说过了。&lt;/p&gt;

&lt;p&gt;到这里我们已经有工具预处理用户传入的迭代器，拿到内部可用的新迭代器了。剩下的就套路比较多了。&lt;/p&gt;

&lt;h4 id=&#34;each:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.each&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;_.each = _.forEach = function(obj, iteratee, context) {
	iteratee = optimizeCb(iteratee, context);
	var i, length;
	if (isArrayLike(obj)) {
	  for (i = 0, length = obj.length; i &amp;lt; length; i++) {
	    iteratee(obj[i], i, obj);
	  }
	} else {
	  var keys = _.keys(obj);
	  for (i = 0, length = keys.length; i &amp;lt; length; i++) {
	    iteratee(obj[keys[i]], keys[i], obj);
	  }
	}
	return obj;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原生js给array原型上加了一个forEach方法用来迭代数组，只能处理数组，jQuery也有一个each不仅仅能够处理数组，类数组、和对象也都能处理，underscore的each和jQuery的其实差不多，但是在jQuery中如果迭代返回false就停止迭代了。&lt;/p&gt;

&lt;p&gt;这里还有个内部函数&lt;code&gt;isArrayLike&lt;/code&gt;，其实jQuery也有个同样功能的函数，看下代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
var getLength = property(&#39;length&#39;);
var isArrayLike = function(collection) {
	var length = getLength(collection);
	return typeof length == &#39;number&#39; &amp;amp;&amp;amp; length &amp;gt;= 0 &amp;amp;&amp;amp; length &amp;lt;= MAX_ARRAY_INDEX;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面的&lt;code&gt;getLength&lt;/code&gt;函数我其实在最开始说&lt;code&gt;property&lt;/code&gt;函数的时候已经提过了。&lt;/p&gt;

&lt;h4 id=&#34;map:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.map&lt;/h4&gt;

&lt;p&gt;原生js的array上也有个map方法，但是只能用在array上，这里也是推广到了类数组和对象。其实有了上面&lt;code&gt;_.each&lt;/code&gt;的代码，我们完全可以照着实现一个map，代码上也没有太多难以理解的。&lt;/p&gt;

&lt;p&gt;一个相类似的函数是&lt;code&gt;_.mapObject&lt;/code&gt;，它只能对object进行迭代，并且mapObject的结果是一个object，而map的结果是一个array&lt;/p&gt;

&lt;h4 id=&#34;reduce-reduceright:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.reduce  _.reduceRight&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function createReduce(dir) {
	function iterator(obj, iteratee, memo, keys, index, length) {
	  for (; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; length; index += dir) {
	    var currentKey = keys ? keys[index] : index;
	    memo = iteratee(memo, obj[currentKey], currentKey, obj);
	  }
	  return memo;
	}

	return function(obj, iteratee, memo, context) {
	  iteratee = optimizeCb(iteratee, context, 4);
	  var keys = !isArrayLike(obj) &amp;amp;&amp;amp; _.keys(obj),
	      length = (keys || obj).length,
	      index = dir &amp;gt; 0 ? 0 : length - 1;
	  // Determine the initial value if none is provided.
	  if (arguments.length &amp;lt; 3) {
	    memo = obj[keys ? keys[index] : index];
	    index += dir;
	  }
	  return iterator(obj, iteratee, memo, keys, index, length);
	};
}

  _.reduce = _.foldl = _.inject = createReduce(1);
  _.reduceRight = _.foldr = createReduce(-1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果先看了underscore中关于函数的函数，再看这一段就会觉得没那么难以理解了。&lt;code&gt;createReduce&lt;/code&gt;是一个高阶函数，传入的是迭代的方向。类似的套路还有 &lt;code&gt;_.findIndex&lt;/code&gt;、&lt;code&gt;findLastIndex&lt;/code&gt;、&lt;code&gt;createPredicateIndexFinder&lt;/code&gt;这一组，还有&lt;code&gt;_.indexOf&lt;/code&gt; 、&lt;code&gt;_.lastIndexOf&lt;/code&gt;、&lt;code&gt;createIndexFinder&lt;/code&gt;这一组。&lt;/p&gt;

&lt;h4 id=&#34;sortby:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.sortBy&lt;/h4&gt;

&lt;p&gt;这个函数其实是叫我们如何优雅的使用underscore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.sortBy = function(obj, iteratee, context) {
	iteratee = cb(iteratee, context);
	return _.pluck(_.map(obj, function(value, index, list) {
	  return {
	    value: value,
	    index: index,
	    criteria: iteratee(value, index, list)
	  };
	}).sort(function(left, right) {
	  var a = left.criteria;
	  var b = right.criteria;
	  if (a !== b) {
	    if (a &amp;gt; b || a === void 0) return 1;
	    if (a &amp;lt; b || b === void 0) return -1;
	  }
	  return left.index - right.index;
	}), &#39;value&#39;);
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在underscore中有不少函数就是在其他函数的基础上搭起来的。这个sortBy函数中用到的pluck就是一个基于map搭出来的函数。&lt;/p&gt;

&lt;h4 id=&#34;groupby-indexby-countby:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.groupBy _.indexBy _.countBy&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var group = function(behavior) {
	return function(obj, iteratee, context) {
	  var result = {};
	  iteratee = cb(iteratee, context);
	  _.each(obj, function(value, index) {
	    var key = iteratee(value, index, obj);
	    behavior(result, value, key);
	  });
	  return result;
	};
};

_.groupBy = group(function(result, value, key) {
	if (_.has(result, key)) result[key].push(value); else result[key] = [value];
});

_.indexBy = group(function(result, value, key) {
	result[key] = value;
});

_.countBy = group(function(result, value, key) {
	if (_.has(result, key)) result[key]++; else result[key] = 1;
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;groupBy、indexBy、countBy这三个在实现上没有太多难以理解的东西，但是注意这个抽象能力。&lt;/p&gt;

&lt;h2 id=&#34;数组相关函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;数组相关函数&lt;/h2&gt;

&lt;h4 id=&#34;uniq:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.uniq&lt;/h4&gt;

&lt;p&gt;数组去重算是一个经典问题了，对于一些特殊的数据我会将数组转化成hash结构(用object实现)然后再转回数组来实现(然而碰到的绝大多数是这种情况，算法复杂度O(n) )，underscore提供的去重方法更加通用，考虑的也更多，它提供一个可选参数isSorted，用于已经排序的元素，这时候算法的时间复杂度是O(n)，传入迭代器或者不传入迭代器的算法时间复杂度是O(n^2),判断是否是重复元素用的是&lt;code&gt;_.contains&lt;/code&gt;，它再调用&lt;code&gt;_.indexOf&lt;/code&gt;，看名字array的原型上就有这么一个方法，underscore的进步之处是它还考虑了NaN的情况(ES6的includes方法考虑了NaN的情况，但是这个糟心的兼容性问题，还有MDN上的polyfill有bug没考虑NaN的情况)。&lt;/p&gt;

&lt;p&gt;underscore去重算法的源码就不在这里贴了，但是很推荐去读一下源码&lt;/p&gt;

&lt;h4 id=&#34;intersection:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.intersection&lt;/h4&gt;

&lt;p&gt;这个函数是用来求交集的，原理也不复杂，交集的话一定是第一个集合的子集，只要遍历第一个集合的元素，看其他集合是否有这个元素即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.intersection = function(array) {
	var result = [];
	var argsLength = arguments.length;
	for (var i = 0, length = getLength(array); i &amp;lt; length; i++) {
	  var item = array[i];
	  if (_.contains(result, item)) continue;
	  for (var j = 1; j &amp;lt; argsLength; j++) {
	    if (!_.contains(arguments[j], item)) break;
	  }
	  if (j === argsLength) result.push(item);
	}
	return result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一提到交集，会联想到的另一个名词就是并集，并集的思路更简单了，把集合合并在一起，然后去重就好了。去重上面已经有代码了，现在需要的是合并，underscore内部的&lt;code&gt;flatten&lt;/code&gt;能够进行合并，而且看一下参数配置，你会发现union方法实际上考虑了传递的参数类型，并且只允许集合(数组)被合并。&lt;/p&gt;

&lt;h2 id=&#34;对象相关函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;对象相关函数&lt;/h2&gt;

&lt;h4 id=&#34;类型判断全家桶:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;类型判断全家桶&lt;/h4&gt;

&lt;p&gt;又是个js的常见问题，其实jQuery里也有相关的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === &#39;[object Array]&#39;;
  };

  _.isObject = function(obj) {
    var type = typeof obj;
    return type === &#39;function&#39; || type === &#39;object&#39; &amp;amp;&amp;amp; !!obj;
  };  

  _.each([&#39;Arguments&#39;, &#39;Function&#39;, &#39;String&#39;, &#39;Number&#39;, &#39;Date&#39;, &#39;RegExp&#39;, &#39;Error&#39;], function(name) {
    _[&#39;is&#39; + name] = function(obj) {
      return toString.call(obj) === &#39;[object &#39; + name + &#39;]&#39;;
    };
  });

  _.isFinite = function(obj) {
    return isFinite(obj) &amp;amp;&amp;amp; !isNaN(parseFloat(obj));
  };

  _.isNaN = function(obj) {
    return _.isNumber(obj) &amp;amp;&amp;amp; obj !== +obj;
  };

  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === &#39;[object Boolean]&#39;;
  };

  _.isNull = function(obj) {
    return obj === null;
  };

  _.isUndefined = function(obj) {
    return obj === void 0;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否是array的时候先尝试使用Array的静态方法&lt;code&gt;Array.isArray&lt;/code&gt;，兼容版本大家其实都熟。&lt;/p&gt;

&lt;p&gt;对于Object的判断就有些奇怪了，他把function object array都算作object了（null这个异端没算），虽然我不太认同这个规则（反过来想想在js的世界谁不是对象呢）。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;_.isFinite&lt;/code&gt;和&lt;code&gt;_.isNaN&lt;/code&gt;这两个的意思就是故意黑js了，记得Number对象上有了相关的判断静态方法，不过实际项目中真的有必要判断这两个？我反正没判断过。&lt;/p&gt;

&lt;p&gt;其实我个人认为把isArrayLike暴露出来的其实更好。&lt;/p&gt;

&lt;h4 id=&#34;keys-allkeys-values:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.keys  _.allKeys  _.values&lt;/h4&gt;

&lt;p&gt;看名字自行联想也能猜出来是干啥的，&lt;code&gt;Object.values&lt;/code&gt;目前还处于实验阶段，然而我更好奇当时出&lt;code&gt;Object.keys&lt;/code&gt;的时候为啥没把这货一起写上。实现起来没啥难的。&lt;/p&gt;

&lt;h4 id=&#34;invert:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.invert&lt;/h4&gt;

&lt;p&gt;php有一个内置方法&lt;code&gt;array_flip&lt;/code&gt;是用来交换键值的，underscore的这个方法就是模拟这个功能。自己可以试着实现一下。&lt;/p&gt;

&lt;h4 id=&#34;functions:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.functions&lt;/h4&gt;

&lt;p&gt;这是个特异化的keys功能，只返回方法名。&lt;/p&gt;

&lt;h4 id=&#34;extend-extendown-clone:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.extend _.extendOwn _.clone&lt;/h4&gt;

&lt;p&gt;让我想到了原生的&lt;code&gt;Object.assign&lt;/code&gt;和jQuery的&lt;code&gt;jQuery.extend&lt;/code&gt;，其实我觉得jQuery写的更好，功能强大多了，建议大家去读jQuery的extend&lt;/p&gt;

&lt;h2 id=&#34;其他函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;其他函数&lt;/h2&gt;

&lt;h4 id=&#34;shuffle:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.shuffle&lt;/h4&gt;

&lt;p&gt;在php中有一个系统方法shuffle用来将原数组打乱顺序，underscore也实现了这一功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index &amp;lt; length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里重要的是重排算法的实现。&lt;/p&gt;

&lt;h4 id=&#34;sortedindex:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.sortedIndex&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low &amp;lt; high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) &amp;lt; value) low = mid + 1; else high = mid;
    }
    return low;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法适用于已经从小到大排好序的数组，用的是二分法查找。&lt;/p&gt;

&lt;h4 id=&#34;mixin:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;mixin&lt;/h4&gt;

&lt;p&gt;这个方法是用来让用户扩展underscore的。看下源码其实不难理解，但我到现在依然怀疑把函数挂到underscore的原型上的必要性。&lt;/p&gt;

&lt;p&gt;而且这个方法本身很危险，因为他允许用户修改underscore暴露出来的的方法。想起来之前看的CI的一个library，有这么一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function initialize($params = array())
{
	if (count($params) &amp;gt; 0)
	{
		foreach ($params as $key =&amp;gt; $val)
		{
			if (isset($this-&amp;gt;$key))
			{
				$this-&amp;gt;$key = $val;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CI的做法是$this上挂载的才允许用户设置，多余的设置一律跳过，underscore可以使用类似的思路，underscore上没有挂载的才允许挂载，至少这样比较安全。&lt;/p&gt;

&lt;h2 id=&#34;总结:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于underscore我没有一个一个列出来解读，而是找了一些有代表性的重要的代码简单评价一下。有的功能其实看着上面的描述可以自行去尝试实现一下了，比如说&lt;code&gt;_.constant&lt;/code&gt;和&lt;code&gt;_.propertyOf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;读underscore源码对我来说最大的影响作者的抽象能力，还有暴露了我对函数这个概念理解地太弱。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈我对静态使用场景的理解</title>
      <link>https://jiangshanmeta.github.io/post/php/static/</link>
      <pubDate>Tue, 27 Dec 2016 20:54:19 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/php/static/</guid>
      <description>

&lt;p&gt;静态属性和静态方法这两个概念大家都不陌生，然而在日常的开发中用的却比较少，结合最近的开发工作我想谈一谈我对这两个使用场景的理解。&lt;/p&gt;

&lt;h2 id=&#34;静态方法的使用场景:d0787c13b8a4561bb718106ef30e7fec&#34;&gt;静态方法的使用场景&lt;/h2&gt;

&lt;p&gt;首先是项目中的一个工具类。这个类收集了一些常用的工具函数，比如一些字符串处理函数、数组处理函数，本身各个方法之间没有什么逻辑关系，这个类更像是一个命名空间。其实这些方法我更倾向于按照面向过程的写法，写成一堆注册到全局的小函数。从逻辑上讲这里的每一个方法都不会影响实例的状态，所以均应该是静态方法，不过写成实例方法也没什么问题。&lt;/p&gt;

&lt;p&gt;然后是model层的一个方法，这个方法是我封装来处理mongoId的，它本身也只是一个工具函数，不影响实例状态，而且最开始我还把这个方法直接final掉了，我不认为子类需要重载这个方法，这个方法最终声明成了静态方法。&lt;/p&gt;

&lt;p&gt;对于静态方法和实例方法，我找到的资料一般认为性能上有些许差异，静态方法性能上更好一点点，其实可以认为没有差异。一般而言静态方法能做的实例方法都能做，然而实例方法能做的事情静态方法不一定能做(因为静态方法无法访问&lt;code&gt;$this&lt;/code&gt;，无法改变实例状态)。我一直在提及的一个词是&lt;strong&gt;改变实例状态&lt;/strong&gt;，这是我认为方法是否要加&lt;code&gt;static&lt;/code&gt;修饰词的一个分界线，如果这个方法可能会改变实例状态，那么一定是实例方法，否则可当做静态方法。静态方法的一个特征是不允许子类重载，一定程度上相当于加上了&lt;code&gt;final&lt;/code&gt;关键词(还是有不少差异的)，我举的第二个例子就是把一个final的工具方法改成了静态方法。&lt;/p&gt;

&lt;p&gt;静态方法和实例方法的应用场景上面已经总结了，下面介绍静态属性的应用场景。&lt;/p&gt;

&lt;h2 id=&#34;静态属性的应用场景:d0787c13b8a4561bb718106ef30e7fec&#34;&gt;静态属性的应用场景&lt;/h2&gt;

&lt;p&gt;首先是CI框架的conroller基类的一段代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CI_Controller {
	private static $instance;
	public function __construct(){
		self::$instance =&amp;amp; $this;
	}
	public static function &amp;amp;get_instance(){
		return self::$instance;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用静态私有变量&lt;code&gt;$instance&lt;/code&gt;存储对象实例，然后通过静态方法&lt;code&gt;get_instance&lt;/code&gt;获取实例，用过CI的应该对这段代码比较熟悉。&lt;/p&gt;

&lt;p&gt;在这里静态变量存储了一个对象，基于类似的思路，我们可以&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/single/&#34;&gt;实现单例模式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;进一步扩展，静态变量不仅可以存储一个对象实例，也可以存储一组对象，下面就要自夸一段我自己写的代码了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class H_Model extends CI_Model{
	static private $_cache_models;
	public function __construct(){
		parent::__construct();
	}
	final protected function get_model($model){
		$_cache_name = strtolower($model);
		if(!isset(self::$_cache_models[$_cache_name]) || !(self::$_cache_models[$_cache_name] instanceof $model) ){
			self::$_cache_models[$_cache_name] = new $model;
		}
		return self::$_cache_models[$_cache_name];
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;静态变量&lt;code&gt;$_cache_models&lt;/code&gt;是配合方法&lt;code&gt;get_model&lt;/code&gt;使用的，这段代码之所以出现是因为将代码从controller封装到model层的过程中，不免会在model层内部实例化其他model，这里将实例化的model保存在静态变量中避免不必要的实例化。&lt;/p&gt;

&lt;p&gt;最后一段代码是用静态变量保存一组数组的，原理和上边保存一组对象差不多就不展示代码。最初是每个实例上都挂这么一个数组，当实例一多所占的内存就大了，后来我们改成用了一个global的变量存储这一组数组，然后每个对象对数组进行引用。但是从逻辑上不应该用global的元素保存，这些数组从属于类而不是全局，所以我改成了用静态存储。&lt;/p&gt;

&lt;p&gt;可以看到，静态属性在存储对象/数组上有着特别的优势，用得好可以实现性能的优化、实现一些特殊的功能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>21天并不能精通CI</title>
      <link>https://jiangshanmeta.github.io/post/php/ci/</link>
      <pubDate>Sat, 05 Nov 2016 19:39:38 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/php/ci/</guid>
      <description>

&lt;p&gt;CI是一个MVC的php框架，平时使用的多了所以开始阅读其源码，在这里做个记录。&lt;/p&gt;

&lt;h2 id=&#34;整体流程:4148907b28e52bc7301c1249655cea8c&#34;&gt;整体流程&lt;/h2&gt;

&lt;p&gt;要了解一个框架，首先要做的就了解程序的流程。&lt;/p&gt;

&lt;p&gt;一般而言，我们请求的是index.php文件，在这个文件中主要定义了三个文件目录：CI系统文件目录、应用程序文件目录、界面层文件目录，然后加载了CodeIgniter.php这一文件，该文件规定了程序的主要逻辑。&lt;/p&gt;

&lt;p&gt;在CodeIgniter.php中，首先加载了一些定义好的工具全局函数和变量，然后是基准测试类、钩子类、Config类，到这里都是一些辅助性的东西，接下来的加载URI类和路由类，前者对请求的url进行各种处理得到各段参数，后者对URI类的处理结果根据路由规则进行处理，到这里我们拿到了controller名、method名以及参数。根据路由类的处理结果，我们拿到controller实例，并调用相应的方法（大部分工作就是实现controller里的各种方法），如果需要输出页面的话一般是通过Output类进行。&lt;/p&gt;

&lt;p&gt;基本流程就是这样，下面具体展开来看。&lt;/p&gt;

&lt;h2 id=&#34;index-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;index.php&lt;/h2&gt;

&lt;p&gt;这个文件是入口文件，虽然看起来有一堆代码，但是真正做的事情并不多。首先是定义当前环境，并且根据环境决定报错等级，然后定义了三个文件目录，分别是系统文件目录(&lt;code&gt;basepath&lt;/code&gt;)、应用代码文件目录(&lt;code&gt;APPPATH&lt;/code&gt;)和view层目录(&lt;code&gt;VIEWPATH&lt;/code&gt;)，大量操作都是用来校验目录合法性的，最后就是加载CodeIgniter.php这一文件。&lt;/p&gt;

&lt;h2 id=&#34;common-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Common.php&lt;/h2&gt;

&lt;p&gt;这个文件包含一些CI封装好的全局函数，先说一部分吧。&lt;/p&gt;

&lt;p&gt;1.&lt;code&gt;is_php&lt;/code&gt;是用来判断当前php版本的，其实就是对&lt;code&gt;version_compare&lt;/code&gt;这一系统函数的封装，不过在函数内部有一个静态局部变量&lt;code&gt;_is_php&lt;/code&gt;用来缓存判断的结果(js就只能默默地靠闭包实现这一功能)。&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;get_config&lt;/code&gt;主要是用来获取应用项目中的config文件并保存在静态局部变量&lt;code&gt;config&lt;/code&gt;中，还可以根据传入的值对&lt;code&gt;$config&lt;/code&gt;进行补充。&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;config_item&lt;/code&gt;是用来获取某个具体的配置的，在实现上首先有一个局部静态变量&lt;code&gt;_config&lt;/code&gt;，然后&lt;code&gt;$_config[0] =&amp;amp; get_config();&lt;/code&gt;，这样局部静态变量&lt;code&gt;_config&lt;/code&gt;保存了对config的引用，这里之所以用一个数组注释里说的很清楚：静态变量无法保存引用，所以用了数组。&lt;/p&gt;

&lt;p&gt;4.&lt;code&gt;load_class&lt;/code&gt;这个很重要，用来加载并且实例化一些系统类，由于CI扩展性强的特点，这里会判断有没有我们自行扩展的子类然后再实例化，实例化的类会缓存在一个静态局部变量中，用来实现单例。&lt;/p&gt;

&lt;p&gt;5.&lt;code&gt;is_loaded&lt;/code&gt;是和上面的&lt;code&gt;load_class&lt;/code&gt;函数配合使用的，用来追踪那些实例化的系统类的，这个函数一个是在&lt;code&gt;load_class&lt;/code&gt;中用到，还有是在controller的基类的构造函数使用，用来把实例化的系统类挂到controller上。&lt;/p&gt;

&lt;h2 id=&#34;benchmark-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Benchmark.php&lt;/h2&gt;

&lt;p&gt;Benchmark类是用来测试执行时间和使用内存的。&lt;/p&gt;

&lt;p&gt;对于内存的使用的测试Benckmark类仅仅是返回了一个特殊的字符串，然后在Output类中这个字符串被替换为真正的内存消耗。&lt;/p&gt;

&lt;p&gt;对于执行时间的测试原理其实很简单就是打时间戳。在CodeIgniter.php有几个默认的打时间戳的位置，比如Benchmark实例化成功后、controller的方法被调用后，对应打时间戳的方法是&lt;code&gt;mark&lt;/code&gt;，还有一个和测试时间有关的方法是&lt;code&gt;elapsed_time&lt;/code&gt;，它的作用是返回两点间的时间。既然是两个点，如果终点不传就返回起点到当前的时间，如果起点不传返回特殊字符串，经Output类处理最终是从开始运行CI到输出到浏览器的总时间。&lt;/p&gt;

&lt;h2 id=&#34;hooks-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Hooks.php&lt;/h2&gt;

&lt;p&gt;钩子为我们提供了在不改变核心代码的同时扩展核心代码的可能。对于Hooks类CI默认是禁用的，我们可以修改配置文件启用Hooks类。当启用时，会加载应用代码中的钩子函数。调用钩子函数时是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$EXT-&amp;gt;call_hook(&#39;pre_system&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还是看一下源代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function call_hook($which = &#39;&#39;)
{
  if ( ! $this-&amp;gt;enabled OR ! isset($this-&amp;gt;hooks[$which])){
	return FALSE;
  }

  if (is_array($this-&amp;gt;hooks[$which]) &amp;amp;&amp;amp; ! isset($this-&amp;gt;hooks[$which][&#39;function&#39;])){
	foreach ($this-&amp;gt;hooks[$which] as $val){
		$this-&amp;gt;_run_hook($val);
	}
  }else{
		$this-&amp;gt;_run_hook($this-&amp;gt;hooks[$which]);
  }

  return TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是判断有没有启用钩子、有没有在调用钩子函数的地方挂钩子，该退出的就退出。然后判断这个挂钩子的地方是挂了一个脚本还是多个脚本（一维数组还是二维数组），最终执行每一个脚本的是受保护的&lt;code&gt;_run_hook&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;这个&lt;code&gt;_run_hook&lt;/code&gt;方法支持的还是挺多的，支持匿名函数、支持调用已有实例的方法、支持面向过程的函数、也支持自行实例化一个类然后调用相应的方法（还实现了对这个实例的缓存）。&lt;/p&gt;

&lt;h2 id=&#34;config-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Config.php&lt;/h2&gt;

&lt;p&gt;config类是用来处理各种config文件的，在构造函数中有如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;config =&amp;amp; get_config();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能会问，为啥还要单独实现一个全局函数来获取config呢，为啥不在这个类里实现呢？原因是当我们需要实例化config类的时候(load_class函数)，我们需要判断有没有用户自行扩展的config子类，这时候已经需要加载config了，就这样。&lt;/p&gt;

&lt;p&gt;一些公共方法比如&lt;code&gt;set_item&lt;/code&gt;、&lt;code&gt;item&lt;/code&gt;、&lt;code&gt;slash_item&lt;/code&gt;都是对具体的config项目进行处理。而&lt;code&gt;load&lt;/code&gt;方法是用来加载一个配置文件的，在Loader类的自动加载调用过这个函数。&lt;/p&gt;

&lt;h2 id=&#34;controller-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Controller.php&lt;/h2&gt;

&lt;p&gt;虽然想按照执行顺序写但是还是先写Controller吧，毕竟controller是日常写的比较多的部分。controller的基类并不复杂：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CI_Controller {
	private static $instance;
	public function __construct()
	{
		self::$instance =&amp;amp; $this;
		foreach (is_loaded() as $var =&amp;gt; $class)
		{
			$this-&amp;gt;$var =&amp;amp; load_class($class);
		}

		$this-&amp;gt;load =&amp;amp; load_class(&#39;Loader&#39;, &#39;core&#39;);
		$this-&amp;gt;load-&amp;gt;initialize();
		log_message(&#39;info&#39;, &#39;Controller Class Initialized&#39;);
	}

	public static function &amp;amp;get_instance()
	{
		return self::$instance;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个静态私有变量&lt;code&gt;$instance&lt;/code&gt;用来存放实例化的controller，静态方法&lt;code&gt;get_instance&lt;/code&gt;是用来获取这个实例化的controller，在构造函数中，首先&lt;code&gt;self::$instance =&amp;amp; $this;&lt;/code&gt;把形成的实例存储在静态私有变量&lt;code&gt;$instance&lt;/code&gt;中，然后把通过&lt;code&gt;load_class&lt;/code&gt;这一函数实例化的类挂到controller上面，这样我们就可以在controller内通过&lt;code&gt;$this&lt;/code&gt;访问这些类了。&lt;/p&gt;

&lt;p&gt;在CodeIgniter.php文件中一个有关的函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_instance()
{
	return CI_Controller::get_instance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;model-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Model.php&lt;/h2&gt;

&lt;p&gt;Model也是业务逻辑经常要实现的，我们看一下model的基类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CI_Model {

	public function __construct()
	{
		log_message(&#39;info&#39;, &#39;Model Class Initialized&#39;);
	}

	public function __get($key)
	{
		return get_instance()-&amp;gt;$key;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CI_Model就这么简短，比较有意思的是对于魔术方法&lt;code&gt;__get&lt;/code&gt;的使用，这里利用了get_instance这一函数，当model层没有所查询的变量时就从超级对象CI那里获取。&lt;/p&gt;

&lt;h2 id=&#34;uri-php-router-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;URI.php Router.php&lt;/h2&gt;

&lt;p&gt;这两个文件综合决定了请求的controller和method以及参数。&lt;/p&gt;

&lt;p&gt;URI类主要是处理请求的URL，对超全局变量&lt;code&gt;$_SERVER&lt;/code&gt;里的数据进行各种处理，并且处理一些服务器的兼容问题，具体的代码注释可以参照&lt;a href=&#34;http://blog.csdn.net/Zhihua_W/article/details/52872407&#34;&gt;CI框架源码解析八之地址解析类文件URI.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Router类处理的是路由规则，如果使用默认的路由规则的话这个类基本上不做什么(除了赋默认值)，最终的controller和method名会挂在这个类上，以供CodeIgniter.php这个文件调用，并且对URI实例进行丰富，获得URI的&lt;code&gt;rsegment&lt;/code&gt;属性就是在这里填入数据的。关于代码解读可以参考&lt;a href=&#34;http://blog.csdn.net/Zhihua_W/article/details/52918664&#34;&gt;CI框架源码解析九之路由类文件Router.php&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;loader-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Loader.php&lt;/h2&gt;

&lt;p&gt;加载器类是一个功能丰富的类，它负责加载MVC中的Model和View，并且还加载library和helper。&lt;/p&gt;

&lt;h4 id=&#34;加载model:4148907b28e52bc7301c1249655cea8c&#34;&gt;加载model&lt;/h4&gt;

&lt;p&gt;加载model对应的是&lt;code&gt;model&lt;/code&gt;方法，这个方法有三个参数，有意思的是第一个参数，我们看下文档对第一个参数的说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$model (mixed) &amp;ndash; Model name or an array containing multiple models&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一个参数可以是一个model名，也可以是一个索引数组其中每一项是model名，还可以是关联数组，其中键为model名、值位挂在controller上的显示名。我们看下是如何实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (empty($model))
{
	return $this;
}
elseif (is_array($model))
{
	foreach ($model as $key =&amp;gt; $value)
	{
		is_int($key) ? $this-&amp;gt;model($value, &#39;&#39;, $db_conn) : $this-&amp;gt;model($key, $value, $db_conn);
	}

	return $this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，加载多个model最终转换为一个一个model的加载。&lt;/p&gt;

&lt;p&gt;然后所做的是根据传入的参数获得路径和model名，保证CI_model这个基类被加载，如果有扩展的子类还要保证扩展的子类被加载，最终拿到model的实例并挂到controller上。&lt;/p&gt;

&lt;h4 id=&#34;加载helper:4148907b28e52bc7301c1249655cea8c&#34;&gt;加载helper&lt;/h4&gt;

&lt;p&gt;加载helper其实要比加载model更简单，因为helper都是面向过程的写法，只要保证文件被include进来就行，无所谓什么基类子类之类的，不过CI在这里把subclass的概念强加在了文件名称规范上了，虽说如此CI也做了兼容处理允许在应用代码的help文件不包含subclass前缀。具体的看代码吧。&lt;/p&gt;

&lt;h4 id=&#34;加载library:4148907b28e52bc7301c1249655cea8c&#34;&gt;加载library&lt;/h4&gt;

&lt;p&gt;加载library的核心逻辑和加载一个model的差不多，都是加载文件实例化一个类最后挂在CI上面，只是多了一些if else。这是因为model的话必须是&lt;code&gt;CI_Model&lt;/code&gt;的子类，而library可不一定，library可以是对CI的library的拓展(即子类)，我们还何以在应用代码里来个和系统library同名文件直接取代掉系统的library，我们还可以在应用代码里自行写一个新的类，而且实例化model的时候没有参数，但是library的有。&lt;/p&gt;

&lt;h4 id=&#34;加载view:4148907b28e52bc7301c1249655cea8c&#34;&gt;加载view&lt;/h4&gt;

&lt;p&gt;加载view有三个参数，第一个是view层文件的地址，既然已经到这里了加载一个文件已经是见的多了，不多说了，然后第二个参数是一个关联数组，用于存放我们要从controller层传递给view层的数据，在view层我们使用传递过来的数据的时候这个关联数组就像被打散了一样，我一直没想清楚ci是如何实现的，知道我看了源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extract($this-&amp;gt;_ci_cached_vars);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在对传进来的数据进行一定的清洗合并之后，使用&lt;code&gt;extract&lt;/code&gt;这个函数实现打散一个关联数组。这里还一个问题，在我们的项目中一般是把数据挂在controller上，然后在view层通过&lt;code&gt;$this&lt;/code&gt;来访问，那就有问题了，加载view层的时候，&lt;code&gt;$this&lt;/code&gt;指向的是加载器而不是controller，那我们是如何获得controller上的变量的？其实类似的问题我们在model层也遇到过，model层是通过魔术方法&lt;code&gt;__get&lt;/code&gt;获得挂在controller上的变量的，然而加载器这里处理的太暴力的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; foreach (get_object_vars($_ci_CI) as $_ci_key =&amp;gt; $_ci_var)
{
	if ( ! isset($this-&amp;gt;$_ci_key))
	{
		$this-&amp;gt;$_ci_key =&amp;amp; $_ci_CI-&amp;gt;$_ci_key;
 	}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有代码有真相，这里是把controller上的变量直接全挂到了加载器上，不得不佩服作者的脑洞，其实我一直很好奇作者为啥不和model用同样的代码。&lt;/p&gt;

&lt;p&gt;最后一个参数是控制直接返回一个字符串还是把它交给output类处理，在默认条件下是交给output类。在这里作者为了性能上的考虑使用了输出缓存。&lt;/p&gt;

&lt;p&gt;++++++++++++++++分割线++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;&lt;em&gt;到这里CI最主要的基本上完了，这里没提的几个类包括Lang、UTF8、Input、Security，前两个我认为对于常规的开发没有去看的必要，后两个虽然常用，但是有大量的正则表达式我实在是不想看，先告一段落吧。下面的主要任务是看CI封装的一些library和helper。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;++++++++++++++++分割线++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;CI的helper大体看了几个自己感兴趣的，最大的收获是给CI发现了一个bug然后让作者修掉了。其实php提供的系统函数已经够多了，足以支持一般开发。&lt;/p&gt;

&lt;p&gt;library看了ua类，从代码的角度没有什么难以理解的，其中有一段值得学习一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach (array(&#39;_set_robot&#39;, &#39;_set_browser&#39;, &#39;_set_mobile&#39;) as $function)
{
    if ($this-&amp;gt;$function() === TRUE)
    {
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mongodb的复杂查询和聚合</title>
      <link>https://jiangshanmeta.github.io/post/mongodb/aggregate/</link>
      <pubDate>Sun, 23 Oct 2016 20:20:18 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/mongodb/aggregate/</guid>
      <description>

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/&#34;&gt;总结过mongodb常用的增删查改&lt;/a&gt;，随着使用的深入自己的工作不在局限在简单地增删查改上，还处理一部分的统计性工作。统计所需要的查询条件就比较复杂了，而mongodb的聚合又是mongodb的一个很大的话题了。这里算是对工作中遇到的一些情况进行总结吧。因为平时都是通过php操作数据库，所以下面的代码都是php，不过并不影响我想表达的。&lt;/p&gt;

&lt;h2 id=&#34;限制数组长度查询:233b6dd901ca06898e3895bff0f956d4&#34;&gt;限制数组长度查询&lt;/h2&gt;

&lt;p&gt;mongodb可以存储数组，我遇到的一个需求是筛选出数组长度大于某个值的。首先想到的是使用&lt;code&gt;$size&lt;/code&gt;，但是&lt;code&gt;$size&lt;/code&gt;不支持&lt;code&gt;$gt&lt;/code&gt;这样的操作，仅支持等于某个长度。&lt;/p&gt;

&lt;p&gt;最终的解决方案是查询数组中第N个元素是否存在，比如限制field字段数组中至少有一个元素，则where条件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;fiele.0&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;addtoset在聚合中的使用:233b6dd901ca06898e3895bff0f956d4&#34;&gt;$addToSet在聚合中的使用&lt;/h2&gt;

&lt;p&gt;需求场景是这样的：在流水表里有一些数据是进货记录，每条这样的数据都包含店铺id和供应商id，现在需要拿出每家供应商所供货的店铺。暴力的做法是拿出数据来在php处理（写起来并不复杂），然而用聚合实现更简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
	&#39;$match&#39;=&amp;gt;[
		&#39;typ&#39;=&amp;gt;1
	]
];
$group = [
	&#39;$group&#39;=&amp;gt;[
		&#39;_id&#39;=&amp;gt;&#39;$supplier&#39;,
		&#39;orgs&#39;=&amp;gt;[&#39;$addToSet&#39;=&amp;gt;&#39;$orgId&#39;]
	]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bPeijianFlow&#39;,[$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是实现代码，首先在&lt;code&gt;bPeijianFlow&lt;/code&gt;这张表中只有typ为1的才是进货记录，据此筛选，然后我们要根据供应商id进行聚合，所以聚合中的&lt;code&gt;_id&lt;/code&gt;是&lt;code&gt;$supplier&lt;/code&gt;，因为一个供应商对一家店可能多次供货，但我们仅需保留一次门店id，所以采用&lt;code&gt;$addToSet&lt;/code&gt;而不是&lt;code&gt;$push&lt;/code&gt;，把每家供应商供货的店铺id保存到&lt;code&gt;orgs&lt;/code&gt;这个数组中。&lt;/p&gt;

&lt;h2 id=&#34;根据多个字段进行聚合:233b6dd901ca06898e3895bff0f956d4&#34;&gt;根据多个字段进行聚合&lt;/h2&gt;

&lt;p&gt;上面的聚合仅仅是根据供应商一个字段进行，我遇到的场景是这样的：有一张用户考试的表，存储着用户id，考试类型，需要根据用户和考试类型进行聚合，拿到每个用户每个考试类型通过（通过是在筛选处理的）的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$match = array(
    &#39;$match&#39;=&amp;gt;[
        &#39;status&#39;=&amp;gt;2,
    ],
);
$group = array(
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;array(&#39;adminuserId&#39;=&amp;gt;&#39;$adminuserId&#39;,&#39;typ&#39;=&amp;gt;&#39;$typ&#39;),
        &#39;count&#39;=&amp;gt;array(&#39;$sum&#39;=&amp;gt;1),
        &#39;name&#39;=&amp;gt;array(&#39;$first&#39;=&amp;gt;&#39;$uName&#39;),
        &#39;orgId&#39;=&amp;gt;array(&#39;$first&#39;=&amp;gt;&#39;$orgId&#39;),
    ]

);

$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;aExam&#39;,[$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是筛选通过的考试，用status为2表示，然后是进行聚合，聚合是根据&lt;code&gt;adminuserId&lt;/code&gt;和&lt;code&gt;typ&lt;/code&gt;两个字段来的，所以&lt;code&gt;_id&lt;/code&gt;是一个array，而不是上面那个聚合的string，&lt;code&gt;&#39;count&#39;=&amp;gt;array(&#39;$sum&#39;=&amp;gt;1),&lt;/code&gt;是用来统计数量的，剩下的两行是用来做展示数据用的。&lt;/p&gt;

&lt;h2 id=&#34;聚合中的管线化操作:233b6dd901ca06898e3895bff0f956d4&#34;&gt;聚合中的管线化操作&lt;/h2&gt;

&lt;p&gt;目前遇到的大部分业务场景下的聚合都是两步：先筛选，再聚合。上面两个例子都是这个模式。mongodb的聚合其实是有一个管线化操作，即上一步的输出作为下一步的输入，在上面例子中是match的输出作为group的输入。
复杂场景所需要的管线化操作就比较多了，先举两个实际场景&lt;/p&gt;

&lt;p&gt;第一个场景是这样的，有一张订单表，一个用户可以有多个订单，现在需要统计用户订单数量分布，即我需要统计一张订单的用户有多少、两张订单的用户有多少&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;crmId&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true],
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;50],
    ]
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$crmId&#39;,
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$group2 = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$count&#39;,
        &#39;sum&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$sort = [
    &#39;$sort&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;-1,
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bBook&#39;, [$match,$group,$group2,$sort]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是实现代码，match条件不说了，第一个group是根据用户(crmId)进行聚合，得到每个用户拥有的订单数量，然后再一次聚合以订单数量为&lt;code&gt;_id&lt;/code&gt;进行聚合，得到订单数量分布。&lt;/p&gt;

&lt;p&gt;第二个场景也是处理订单表，需要统计有两张及以上订单的用户的数量，下面是代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;crmId&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true],
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;50],
        &#39;$or&#39;=&amp;gt;[
            [&#39;totalPrice&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]],
            [&#39;totalJiesuan&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]],
        ],
    ],
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$crmId&#39;,
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$match2 = [
    &#39;$match&#39;=&amp;gt;[
        &#39;count&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;2],
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bBook&#39;,[$match,$group,$match2]);
$data[&#39;daodianTwiceUserCount&#39;] = count($rst[&#39;result&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次聚合也是根据用户id(crmId)进行聚合，得到每个用户订单数量，到这里和第一个场景的操作一样，然后再向下操作不是聚合而是进行筛选，我们要筛选出订单数量大于等于2的。&lt;/p&gt;

&lt;h2 id=&#34;project的使用:233b6dd901ca06898e3895bff0f956d4&#34;&gt;$.project的使用&lt;/h2&gt;

&lt;p&gt;在同事的聚合代码里发现了这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$match = array(
    &#39;$match&#39;=&amp;gt; [
        &#39;storeId&#39;=&amp;gt;$this-&amp;gt;store,
        &#39;counter&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]
    ]
);
$project = array(
    &#39;$project&#39;=&amp;gt;[
        &#39;typ&#39;=&amp;gt;1,
        &#39;counter&#39;=&amp;gt;1 ,
        &#39;total&#39;=&amp;gt;[&#39;$multiply&#39;=&amp;gt;[&#39;$counter&#39;,&#39;$chengben&#39;]]
    ]
);
$group = array(
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$typ&#39;, 
        &amp;quot;counter&amp;quot;=&amp;gt;[&#39;$sum&#39;=&amp;gt; &#39;$counter&#39;],
        &amp;quot;totalPrice&amp;quot;=&amp;gt;[&#39;$sum&#39;=&amp;gt; &#39;$total&#39;]
    ]
);
$sort = [&#39;$sort&#39;=&amp;gt;[&#39;_id&#39;=&amp;gt;1]];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;sPeijianinstore&#39;,[$match,$project,$group,$sort]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用聚合也有一段时间了match和group很熟悉，但是那个project是个啥？查了一下&lt;a href=&#34;https://docs.mongodb.com/manual/reference/operator/aggregation/project/&#34;&gt;官方文档&lt;/a&gt;发现这里的&lt;code&gt;$project&lt;/code&gt;很接近mysql的&lt;code&gt;select&lt;/code&gt;，选择需要返回的字段，并能对字段进行运算作为新字段返回。
那解释一下上面project代码的含义：返回typ字段和counter字段（_id字段是默认返回的），然后创建并返回一个新的字段total，这个新字段是由counter字段和chengben字段相乘得到的。&lt;/p&gt;

&lt;p&gt;那个&lt;code&gt;$multiply&lt;/code&gt;就是相乘的意思，&lt;a href=&#34;https://docs.mongodb.com/manual/reference/operator/aggregation-arithmetic/&#34;&gt;mongodb支持多种常见的运算&lt;/a&gt;，四则运算、指数对数运算、幂运算、取整都支持。&lt;/p&gt;

&lt;h2 id=&#34;比较两个字段:233b6dd901ca06898e3895bff0f956d4&#34;&gt;比较两个字段&lt;/h2&gt;

&lt;p&gt;需求场景是这样的：有x、y两个字段，需要x&amp;gt;y的数据。如果在mysql里这个需求实现起来其实很简单，但是mongodb&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;以前对于这样的需求都是在php里进行筛选而不是在数据库里进行筛选，有了上面的&lt;code&gt;$project&lt;/code&gt;这个实现起来终于有点希望了&lt;/p&gt;

&lt;p&gt;下面一段代码是在&lt;a href=&#34;https://segmentfault.com/q/1010000003034113&#34;&gt;segmentfault&lt;/a&gt;上找的，是mongo shell的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.collection.aggregate(
    [  
      {
        $project : {
           _id: &#39;$name&#39;,
           val: { $subtract : [ &amp;quot;$x&amp;quot;, &amp;quot;$y&amp;quot; ] }，
           x: &#39;$x&#39;,
           y: &#39;$y&#39;
        }
      },
      {$match: {val: {$gt: 0}}},
      {$sort: { val: -1 }}
   ]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际使用的时候为了性能优化可以先match一遍做个初筛，然后进行project判断字段间的关系进行筛选，然后执行聚合之类的操作。&lt;/p&gt;

&lt;h2 id=&#34;没有-id的聚合:233b6dd901ca06898e3895bff0f956d4&#34;&gt;没有_id的聚合&lt;/h2&gt;

&lt;p&gt;group的时候通常会有&lt;code&gt;_id&lt;/code&gt;表示按照什么聚合，可以按照一个字段，也可以按照多个字段，上面都有例子，但是有的时候我们并不需要这个聚合的字段，比如如下场景：在订单表中快照出本月的营业额。显然我们只需要筛选出来本月的订单，然后把金额字段加起来就结束了，不需要根据哪个字段聚合。但是group的时候&lt;code&gt;_id&lt;/code&gt;不填还不行，还好mongodb支持填&lt;code&gt;null&lt;/code&gt;。一下是代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;20],
        &#39;userpayTS&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;$startTS,&#39;$lt&#39;=&amp;gt;$endTS],
    ],
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;null,
        &#39;sum&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;&#39;$totalprice&#39;],
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bJingpinbook&#39;, [$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mapreduce:233b6dd901ca06898e3895bff0f956d4&#34;&gt;mapreduce&lt;/h2&gt;

&lt;p&gt;一般的统计性工作使用&lt;code&gt;aggregate&lt;/code&gt;基本就够了，直到我遇到了这么一个需求：类似于知乎的给问题添加话题，一个问题对应多个话题，这些话题存成一个array作为问题的一个字段，然后需要拿到一段时间内话题热度排行榜。如果是一个问题只对应一个话题，这个直接对问题筛选然后对话题字段聚合最后再排个序就可以了，但是问题是话题是个array，在没想到如何用&lt;code&gt;aggregate&lt;/code&gt;实现的情况下我们使用了mapreduce。&lt;/p&gt;

&lt;p&gt;虽然目前还理解的不深刻但是已经可以用来实现上面的需求了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$map = &#39;function(){
    var key = this.relateFeedbackTags;
    for(k in key){
        emit(key[k],1);
    }
}&#39;;
$reduce = &#39;function(key,value){
    return Array.sum(value);

}&#39;;
$rst = $this-&amp;gt;db-&amp;gt;command(array(
    &#39;mapreduce&#39;=&amp;gt;&#39;uFeedback&#39;,
    &#39;map&#39;=&amp;gt;$map,
    &#39;reduce&#39;=&amp;gt;$reduce,
    &#39;out&#39;=&amp;gt;[&#39;inline&#39;=&amp;gt;1],
    &#39;sort&#39;=&amp;gt;[&#39;_id&#39;=&amp;gt;1],
    &#39;query&#39;=&amp;gt;[&#39;orgId&#39;=&amp;gt;&#39;233333&#39;],
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们主要需要实现的是map和reduce两个函数，在map函数中我们把一个话题array映射成了多条记录，reduce函数实现的是对数量的统计，还需要解释的是代码中的&lt;code&gt;out&lt;/code&gt;，因为我不需要将结果写入数据库中而是需要将结果返回给php作进一步处理，所以out对应的值是&lt;code&gt;[&#39;inline&#39;=&amp;gt;1]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为了练习mapreduce，我给自己提了这么一个需求：有张订单表，我希望得到每周周几订单数量最多。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$map = &#39;function(){
    var date = new Date(this.createTS*1000);
    var dayInWeek = date.getDay();
    if(dayInWeek==0){
        dayInWeek = 7;
    }
    emit(dayInWeek,1);
}&#39;;
$reduce = &#39;function(key,value){
    return Array.sum(value);
}&#39;;

$startTS = strtotime(&#39;2016-10-01&#39;);
$endTS = strtotime(&#39;2016-11-01&#39;);

$query = [
    &#39;createTS&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;$startTS,&#39;$lt&#39;=&amp;gt;$endTS],
    &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;60],
    &#39;typ&#39;=&amp;gt;[&#39;$in&#39;=&amp;gt;[10,20,30,40]],
];
$opt = [
    &#39;map&#39;=&amp;gt;$map,
    &#39;reduce&#39;=&amp;gt;$reduce,
    &#39;query&#39;=&amp;gt;$query,
];
$this-&amp;gt;load-&amp;gt;model(&#39;lists/Book_list&#39;,&amp;quot;listInfo&amp;quot;);
$rst = $this-&amp;gt;listInfo-&amp;gt;mapReduce($opt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在map函数中，根据时间戳拿到订单是周几创建的，在reduce函数中，统计出一周的每一天所对应订单数。&lt;/p&gt;

&lt;p&gt;同样是订单表，我希望得到商品销售数量排行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$map = &#39;function(){
    var subbooks = this.jingpinsubbooks;
    for(var i=0;i&amp;lt;subbooks.length;i++){
        emit(subbooks[i].jingpinId,subbooks[i].jinpinNum);
    }
}&#39;;
$reduce = &#39;function(key,value){
    return Array.sum(value);
}&#39;;
$query = [
    &#39;createTS&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;$beginTS,&#39;$lt&#39;=&amp;gt;$endTS],
    &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;20],
];

$opt = [
    &#39;map&#39;=&amp;gt;$map,
    &#39;reduce&#39;=&amp;gt;$reduce,
    &#39;query&#39;=&amp;gt;$query,
];

$rst = $this-&amp;gt;listInfo-&amp;gt;mapReduce($opt);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>观察者模式的一次实践</title>
      <link>https://jiangshanmeta.github.io/post/js/observer/</link>
      <pubDate>Mon, 10 Oct 2016 20:05:11 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/observer/</guid>
      <description>&lt;p&gt;观察者模式是用来解除对象间的耦合同时保证对象间数据通信的一种设计模式，要实现对象间通信数据首先要订阅某个主题，然后监听某个主题发布信息。听起来云里雾里但是前端都见过其中的一个典型例子，就是事件，首先通过&lt;code&gt;addEventListener&lt;/code&gt;订阅事件，然后等待用户触发事件或者脚本触发事件，这时就发布了主题，此时各个对象执行相应的回调。&lt;/p&gt;

&lt;p&gt;我也实现了一个简单的观察者模式( &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/jsdesignpattern/observer.js&#34;&gt;点击下载源码&lt;/a&gt; )：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Observer = (function(){
	var _message = {};
	return {
		register:function(typ,fn){
			if(!_message[typ]){
				_message[typ] = [];
			}
			_message[typ].push(fn);
			return this;
		},
		publish:function(typ,data){
			if(_message[typ]){
				for(var i=0,len=_message[typ].length;i&amp;lt;len;i++){
					_message[typ][i](data);
				}
			}
			return this;
		},
		remove:function(typ,fn){
			if(_message[typ]){
				for(var i=0,len=_message[typ].length;i&amp;lt;len;i++){
					_message[typ][i] ==fn &amp;amp;&amp;amp; _message[typ].splice(i,1);
				}
			}

			return this;
		}
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现是希望将对象之间的通信通过这一个对象进行，这个实现说实话只适用于小型的项目。&lt;/p&gt;

&lt;p&gt;我应用它的场景是这样的：多个对象都有选择地址这么一个操作，在选择地址中有一项是添加地址，然而添加地址这一操作对应一个新的对象，在添加地址对象完成添加后，需要通知其他选择地址对象新的地址array。最开始的实现是判断那几个选择地址的对象存不存在，如果存在就把数据传过去，每多一次引用就要多一个判断。然后我就使用观察者模式改写，更新地址array的时候发布一个更新地址主题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://jiangshanmeta.github.io/post/php/single/</link>
      <pubDate>Sun, 18 Sep 2016 15:42:17 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/php/single/</guid>
      <description>&lt;p&gt;重新学习最好的编程语言的时候看到了&lt;code&gt;static&lt;/code&gt;关键字，于是就想到了可以用这个做单例模式。单例模式的作用是保证一个类最多只有一个实例对象。这里不仅讲php中如何实现单例模式，还顺便说一下在js中如何实现单例模式。&lt;/p&gt;

&lt;p&gt;首先讲一下在php中如何实现单例模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person{
	private static $instance = null;
	private function __construct($name){
		$this-&amp;gt;name = $name;
	}

	public function gen_name(){
		var_dump($this-&amp;gt;name);
	}

	public static function get_instance($name){
		if(!(self::$instance instanceof self)){
			self::$instance = new self($name);
		}
		return self::$instance;
	}

}

$a = Person::get_instance(&#39;a&#39;);
$b = Person::get_instance(&#39;b&#39;);
$a-&amp;gt;gen_name();  // a
$b-&amp;gt;gen_name();	 // a

var_dump($a===$b); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们把构造函数&lt;code&gt;__construct()&lt;/code&gt;加上修饰词&lt;code&gt;private&lt;/code&gt;，这样在外部使用&lt;code&gt;new&lt;/code&gt;关键字实例化一个对象就会报错。然后我们添加一个私有的静态变量&lt;code&gt;$instance&lt;/code&gt;，用来缓存实例化的对象。静态方法&lt;code&gt;get_instance&lt;/code&gt;用来提供单例实例对象。首先判断&lt;code&gt;$instance&lt;/code&gt;有没有缓存的实例，如果有就返回这个缓存的实例对象，如果没有就手动new一个实例对象然后缓存返回该对象。单例模式在php中的实现并不复杂。&lt;/p&gt;

&lt;p&gt;对于js实现上稍微有点复杂，因为js没有&lt;code&gt;static&lt;/code&gt;关键词，但是我们可以模拟它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = (function(){
	var instance = null;

	return function(name){
		// 安全模式，保证是使用new关键字
		if(! (this instanceof Person)){
			return new Person(name);
		}

		// 还没有创建实例对象，需要创建并缓存
		if(!(instance instanceof Person)){
			this.name = name;

			instance = this;
		}
		return instance
	}
})();

var a = Person(&#39;a&#39;);
var b = new Person(&#39;b&#39;);
console.log(a.name); // a
console.log(b.name); // b
console.log(a===b);  // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js中实现单例模式的原理类似，只是使用闭包存了一个变量&lt;code&gt;instance&lt;/code&gt;用来缓存实例对象。顺便说一句在这里被js的操作符优先级给坑了一下，默默加括号。&lt;/p&gt;

&lt;p&gt;其实单例模式的核心是保证最多只有一个实例对象，对于灵活的js其实还有一种更简单粗暴的方法，就是直接暴露一个对象，根本不给你new的机会。&lt;/p&gt;

&lt;p&gt;比如在我们的项目中有这样的一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var AlertPlug = {
	alert:function(){},
	close:function(){},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是使用单例模式的一个例子。&lt;/p&gt;

&lt;p&gt;update 2016/09/21&lt;/p&gt;

&lt;p&gt;上面的js虽然实现了但是模式，但是有一个很严重的问题，就是如果我们想在Person原型上添加一些方法，这些方法由于作用域的原因是无法获取到闭包内的静态私有变量，对于以后的扩展是很不利的。我们可以这样修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window){
	var instance = null;
	var otherStaticPrivateVar = null;

	function Person(name){
		// 安全模式，保证是使用new关键字
		if(! (this instanceof Person)){
			return new Person(name);
		}

		// 还没有创建实例对象，需要创建并缓存
		if(!(instance instanceof Person)){
			this.name = name;

			instance = this;
		}
		return instance
	}

	Person.prototype.logOtherStaticPrivateVar=function(){
		console.log(otherStaticPrivateVar);
	}
	window.Person = Person;
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的结果依然是向全局暴露一个构造函数。&lt;/p&gt;

&lt;p&gt;update 2016/09/21&lt;/p&gt;

&lt;p&gt;后来想了想，prototype是为了不同实例之间共享一些属性和方法才存在的，既然我要做的是单例，那又何必把方法加在prototype上。&lt;/p&gt;

&lt;p&gt;不过，上面的补充其实可以作为在js中模拟静态私有变量的通用写法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript中的继承、私有、静态</title>
      <link>https://jiangshanmeta.github.io/post/js/extend/</link>
      <pubDate>Sun, 04 Sep 2016 20:29:27 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/extend/</guid>
      <description>

&lt;p&gt;javascript是一门奇特的语言，想入门写点小东西很简单，但是一旦深入就觉得难度陡增。这里对比php，简单总结一下。&lt;/p&gt;

&lt;h2 id=&#34;继承:8151693739dce8237269a30642b03e79&#34;&gt;继承&lt;/h2&gt;

&lt;p&gt;先上两段代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Person{
	public function __construct($name=&#39;&#39;){
		$this-&amp;gt;name = $name;
	}

	public function genName(){
		return $this-&amp;gt;name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;php中的类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
}

Person.prototype.genName = function(){
	returrn this.name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js中的构造函数及prototype&lt;/p&gt;

&lt;p&gt;在使用new关键字的时候，两端代码其实功能是一致的，都会生成一个实例，实例具有name这一属性和genName这一方法。在javascript中没有类的概念，所以&lt;strong&gt;用构造函数结合prototype模拟类&lt;/strong&gt;。在第二段代码中，因为genName这一方法是每个实例所共享的，不需要再每个实例上都实现一遍，所以放在了构造函数的prototype上。&lt;strong&gt;js的构造函数，基本上可以类比于php的构造函数&lt;code&gt;__construct()&lt;/code&gt;,而php的其他部分大致对应js的prototype&lt;/strong&gt;。换句话说想要在js中模拟一个类，需要构造函数和prototype两部分。这也是为什么下面js实现继承的时候，需要在构造函数和原型上都做处理。&lt;/p&gt;

&lt;p&gt;在php中的继承是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Kid extends Person{
	public function __construct($name=&#39;&#39;,$age=1){
		parent::construct($name);
		$this-&amp;gt;age = $age;
	}

	public function genAge(){
		returrn $this-&amp;gt;age;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在javascript中要模拟php中的继承，需要模拟在构造函数和prototype两个地方分别模拟（毕竟这两者结合起来才像个类）。&lt;/p&gt;

&lt;p&gt;首先我们要实现构造函数的模拟：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Kid(name,age){
	Person.call(this,name); //相当于php代码的 parent::construct($name);
	this.age = age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们要实现对于基类中的方法的继承，这一点是通过原型链实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kid.prototype = Object.create(Person.prototype);
Kid.prototype.constructor = Kid;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们要实现的是对于子类方法的扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kid.prototype.genAge = function(){
	return this.age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对于js的Kid，我们使用new操作得到的实例，含有name和age两个属性，含有genName和genAge两个方法，与php的Kid类通过new生成的实例一样。&lt;/p&gt;

&lt;h2 id=&#34;私有:8151693739dce8237269a30642b03e79&#34;&gt;私有&lt;/h2&gt;

&lt;p&gt;在php中，静态属性和静态方法都可以直接通过&lt;code&gt;$this&lt;/code&gt;来调用，然而在js中，一旦能够通过&lt;code&gt;this&lt;/code&gt;访问，那么一定是公有的了。&lt;/p&gt;

&lt;p&gt;在js中实现静态属性和静态方法都必须在构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
	var privateName = name; //私有属性
	this.getPrivateName = function(){
		return privateName;
	}
	var sayPrivateName = function(){
		console.log(&amp;quot;private name is &amp;quot; + privateName);
	}  //私有方法
	this.sayPrivateName = function(){
		sayPrivateName();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到想要调用私有属性，对应方法必须写在构造函数内，想要调用私有方法的方法也必须写在构造函数内，总的来说为了实现私有化太折腾了，所以行业里的一个做法是私有的加下划线前缀然后按照公有的实现，我们只是人工认为这是私有的。&lt;/p&gt;

&lt;h2 id=&#34;静态:8151693739dce8237269a30642b03e79&#34;&gt;静态&lt;/h2&gt;

&lt;p&gt;相比较于继承和私有，在js中模拟静态就简单多了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
}
Person.publicStaticMethod1 = function(){
	console.log(&#39;this is a public static method&#39;);
}
Person.publicStaticProperty = &#39;naive&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码就实现了公有静态属性和公有静态方法。&lt;/p&gt;

&lt;p&gt;虽然实现起来不复杂但我没怎么见人用过。&lt;/p&gt;

&lt;p&gt;见得比较多的是静态私有属性的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window){
	var totalPerson = 0;
	function Person(name){
		this.name = name;
		totalPerson++;
	}
	window.Person = Person;
})(window);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/single/&#34;&gt;在js中实现单例模式也使用了静态私有变量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;静态私有方法和静态私有属性的实现差不多(其实都是利用了js的作用域),而且之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/static/&#34;&gt;总结php的静态&lt;/a&gt;的时候我总结过静态方法基本可以被实例方法所替代，所以不多说了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重新学习最好的编程语言</title>
      <link>https://jiangshanmeta.github.io/post/php/relearnphp/</link>
      <pubDate>Thu, 25 Aug 2016 21:07:38 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/php/relearnphp/</guid>
      <description>

&lt;p&gt;从前端入的行，现在前端和后端php一起写，虽然日常的业务逻辑对我来说很轻松，但是感觉自己被框架宠坏了。业务中用的框架是封装过的CI，想着从一个空的CI（3.1.0）开始做起，至少要脱离现在高度封装过的框架。跟着教程看起，发现了自己对于php很多地方理解不足，这里一条条记录下来。&lt;/p&gt;

&lt;h2 id=&#34;构造函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;构造函数&lt;/h2&gt;

&lt;p&gt;CI框架默认的&lt;code&gt;controller&lt;/code&gt;是welcome，不过业界习惯还是index，我就照着welcome这个&lt;code&gt;controller&lt;/code&gt;写了一个index的&lt;code&gt;controller&lt;/code&gt;,然后就报错了。我说我这种动不动就建个&lt;code&gt;controller&lt;/code&gt;写个几百行的咋建个&lt;code&gt;controller&lt;/code&gt;就报错啊。然后百度了一下有人在博客里说是因为这是CI的保留名称所以会报错，可是项目中明明就有controller名为index的啊。后来我发现根本不是这么回事。&lt;/p&gt;

&lt;p&gt;问题出在&lt;strong&gt;构造函数&lt;/strong&gt;上。在php4的时代，构造函数是和类名同名的函数，但是在php5引入了&lt;code&gt;__construct&lt;/code&gt;的概念作为构造函数，同时为了保证向下兼容所以如果没有找到&lt;code&gt;__construct&lt;/code&gt;就把同名函数作为构造函数。在这里，我的controller名称是index，方法名称也是index，并且没有&lt;code&gt;__construct&lt;/code&gt;所以会把index方法当成构造函数。解决方案也就很明了了：写上构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __construct(){
	parent::__construct();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为继承的基类&lt;code&gt;CI_Controller&lt;/code&gt;里有构造函数，显然不作死的方案是调用基类的构造函数。看了一眼项目里的代码，我们是一个类继承了&lt;code&gt;CI_Controller&lt;/code&gt;，调用了&lt;code&gt;CI_Controller&lt;/code&gt;的构造函数，然后做了一些其他的操作。&lt;/p&gt;

&lt;h2 id=&#34;view-template:960e085aadb29182f9448019a6b3c8f1&#34;&gt;view &amp;amp;&amp;amp; template&lt;/h2&gt;

&lt;p&gt;CI是一个MVC框架，最开始我只会画画页面写写js，所以最一开始做的是view层。关于CI的view层&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/views.html&#34;&gt;官方文档里已经给出了很好的说明&lt;/a&gt;，仅仅从用的角度来说已经足够了。然而如果不对其进行封装很容易做一些重复性的操作，比如说声明对header的加载，声明对footer的加载，而真正业务逻辑对应的页面加载只需要一行，对此我们引入了一个新的类&lt;code&gt;template&lt;/code&gt;，把那些header、footer之类的全都放在模板里，在模板里输出真的业务逻辑界面。&lt;/p&gt;

&lt;p&gt;下面代码是从项目代码里按照自己的书写习惯稍微改造的，如果不明白其中一些CI的东西可以看上面链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Template{
	public function __construct(){
		$this-&amp;gt;templateData = [];
		$this-&amp;gt;CI = &amp;amp;get_instance();
	}

	public function set($name,$value){
		$this-&amp;gt;templateData[$name] = $value;
	}

	public function load($template,$view,$view_data = array(),$return = FALSE){
		$this-&amp;gt;set(&#39;contents&#39;,$this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($view,$view_data,TRUE));
		return $this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($template,$this-&amp;gt;templateData,$return);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把这个类放在&lt;code&gt;application/libraries&lt;/code&gt;目录下&lt;code&gt;template.php&lt;/code&gt;文件中，并在autoload中的libraries数组中添加&lt;code&gt;template&lt;/code&gt;,这样我们就可以愉快的使用&lt;code&gt;template&lt;/code&gt;类了，例如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;template-&amp;gt;load(&amp;quot;default_page&amp;quot;,&amp;quot;index/index&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;my-controller:960e085aadb29182f9448019a6b3c8f1&#34;&gt;MY_Controller&lt;/h2&gt;

&lt;p&gt;面向对象一大特征是继承，对于controller里的类也适用。CI官方文档里所讲的controller所继承的都是&lt;code&gt;CI_Controller&lt;/code&gt;，如果需求简单确实足够了，想要封装一层的话可以让这个子类继承自&lt;code&gt;CI_Controller&lt;/code&gt;，在这个类里面进行所需要的封装，controller里的类再继承自这个子类。&lt;/p&gt;

&lt;p&gt;如果熟悉面向对象的话上面所说的实现起来并不复杂，唯一的问题是目录。其实CI已经考虑过这个问题了。把自己封装好的类放到&lt;code&gt;application/core&lt;/code&gt;目录下，文件名称为xxController，然后在&lt;code&gt;application/config/config.php&lt;/code&gt;中找到&lt;code&gt;$config[&#39;subclass_prefix&#39;]&lt;/code&gt;，将其值赋为刚才文件名中的xx，然后你就会发现这个文件会自动被加载（至于具体的子类名称，对于我这种命名困难户显然是选文件名啦）。话说回来，真不嫌麻烦还可以每个controller里手动加载这个文件（何必呢）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/core_classes.html&#34;&gt;扩展核心系统类&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;uri类:960e085aadb29182f9448019a6b3c8f1&#34;&gt;URI类&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://codeigniter.org.cn/user_guide/libraries/uri.html&#34;&gt;URI类&lt;/a&gt;可以帮助从URI字符串中获得一些基本的信息，结合项目中所用到的说一下。&lt;/p&gt;

&lt;p&gt;根据CI的路由规则，第一个参数是控制器的名称，第二个参数是方法名，有的时候会用到这两个名称，最开始的时候我是在controller的构造函数手动声明控制器名称是啥，在具体方法里手动声明方法名是啥。看了文档个人觉得可以封装到上面提到的subclass的构造函数中，毕竟用到的还是比较多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;controller_name = $this-&amp;gt;uri-&amp;gt;segment(1)==null?&#39;index&#39;:$this-&amp;gt;uri-&amp;gt;segment(1);
$this-&amp;gt;method_name = $this-&amp;gt;uri-&amp;gt;segment(2)==null?&#39;index&#39;:$this-&amp;gt;uri-&amp;gt;segment(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外还用到比较多的是&lt;code&gt;$this-&amp;gt;uri-&amp;gt;uri_string()&lt;/code&gt;，这个主要是用在重定向上（因为样式问题以及兼容性、推广等问题对于手机和PC做了两个子站）。&lt;/p&gt;

&lt;h2 id=&#34;mongodb-cimongo:960e085aadb29182f9448019a6b3c8f1&#34;&gt;mongoDB &amp;amp;&amp;amp; cimongo&lt;/h2&gt;

&lt;p&gt;WEB开发离不开数据库，没记错的话新手是首推mysql，然后我就点错科技树学了mongoDB。开始连接数据库吧。&lt;/p&gt;

&lt;p&gt;先说个mongoDB的可视化工具&lt;a href=&#34;https://robomongo.org/&#34;&gt;robomongo&lt;/a&gt;，从一开始写后端程序就在用，毕竟图形界面大法好。&lt;/p&gt;

&lt;p&gt;然后说一下用的库&lt;a href=&#34;https://github.com/vesparny/cimongo-codeigniter-mongodb-library&#34;&gt;cimongo-codeigniter-mongodb-library&lt;/a&gt;，目测作者弃坑了。这个库为我们封装了许多操作数据库的方法。我们需要把config目录下的cimongo.php移动到ci项目 application/config目录下，然后把libraries目录下的cimongo文件夹移动到我们的ci项目中application/libraries目录下。迁移过来之后需要进行一些配置操作，打开cimongo.php配置host、port和db，然后和上面的template类一样作为autoload的libraries，这样我们就可以通过&lt;code&gt;$this-&amp;gt;cimongo&lt;/code&gt;操作数据库了。在实际项目中目测是因为觉得这样写比较长在subclass中做了这个操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db = $this-&amp;gt;cimongo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话我们就可以进行数据库操作了，现在可以随手插入两条数据看看了，然而这样操作数据库是比较危险的操作，随后我们需要进行的是在model层对数据操作进行封装。&lt;/p&gt;

&lt;h2 id=&#34;创建类库:960e085aadb29182f9448019a6b3c8f1&#34;&gt;创建类库&lt;/h2&gt;

&lt;p&gt;今天遇到一个需求是根据权重产生随机结果，实现起来其实并不复杂，我只是想借着这个引出话题 &lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/creating_libraries.html&#34;&gt;在CI中创建类库&lt;/a&gt;。之前的template类就是这个主题的一个体现，不过那个类我是配置成了自动加载，那现在我有一个&lt;code&gt;Utility&lt;/code&gt;类，我想在需要的时候加载，我应该怎么办&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;load-&amp;gt;library(&#39;Utility&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后这个类就挂在了$CI上面。稍微有点开发经验的人应该对utility这个词不陌生，从此可以收集各种小函数啦（我不生产代码，我只是代码的搬运工）。&lt;/p&gt;

&lt;h2 id=&#34;field:960e085aadb29182f9448019a6b3c8f1&#34;&gt;field&lt;/h2&gt;

&lt;p&gt;对于从数据库里拿出来的数据，CI并没有做什么别的操作，我们项目中采用了一系列field类，用于对字段进行处理。&lt;/p&gt;

&lt;p&gt;首先我们实现了对CI的load的扩展，类似于上面说的MY_Controller,在同一目录下我们可以建立我们的Loader，其命名规则和自己建的controller一致，都是根据&lt;code&gt;application/config/config.php&lt;/code&gt;中的&lt;code&gt;$config[&#39;subclass_prefix&#39;]&lt;/code&gt;。这样我们就可以通过&lt;code&gt;$this-&amp;gt;load-&amp;gt;field($show_name,$name,$is_must_input=false)&lt;/code&gt;加载field对象了。&lt;/p&gt;

&lt;p&gt;然后我们需要做的是根据我们对不同字段类型的设定，加载不同的field，进行初始化操作，然后我们就可以在各种field上封装各种方法对数据进行处理啦。&lt;/p&gt;

&lt;h2 id=&#34;链式调用:960e085aadb29182f9448019a6b3c8f1&#34;&gt;链式调用&lt;/h2&gt;

&lt;p&gt;最早接触链式调用是在使用jQuery的时候，其实我觉得使用链式调用能使代码看起来更紧凑一点，除此之外看不出来有什么好处。&lt;/p&gt;

&lt;p&gt;要实现链式调用技术上也并不复杂，最核心的就是&lt;code&gt;return $this;&lt;/code&gt;这一句话。&lt;/p&gt;

&lt;p&gt;很不幸的是在工作项目中除了引用的第三方库中实现过链式调用，我们的后端代码中真心没有自行实现过链式调用，都是使用别人提供的链式调用。&lt;/p&gt;

&lt;p&gt;目前也就发现在model层实现链式调用有点用处，这也提醒我以后一些操作封装在model层，而不是仅仅在controller层实现功能就完了。公司代码里有的没有返回值直接添加 &lt;code&gt;return $this;&lt;/code&gt;就好了，但是有的。。想改就要改一大堆东西，有的甚至都挂在&lt;code&gt;$this&lt;/code&gt;上了还要手动返回一次。历史包袱这种东西真心纠结。&lt;/p&gt;

&lt;p&gt;因为有的代码从controller层迁移到了model层，一些controller里的return在model层就要转化为exit，这个&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/exit/&#34;&gt;已经有了一些经验&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;protected:960e085aadb29182f9448019a6b3c8f1&#34;&gt;protected&lt;/h2&gt;

&lt;p&gt;javascript没有类的概念，因而也没有private、protected、public的概念，但是在php中有啊，在平时的开发中public和private用的比较多，但是真的没找到&lt;code&gt;protected&lt;/code&gt;的使用痕迹（第三封库的不算），但其实我觉得这个概念很好用啊。&lt;/p&gt;

&lt;p&gt;在controller层，写多了就会发现有一些业务上的通用小函数，最开始可能就只在一个controller里面用，显然封装成private就已经足够了，随着业务逻辑的复杂，这样的小函数可能会复制粘贴多次，显然应该向基类里进行封装，最合适的关键词就是&lt;code&gt;protected&lt;/code&gt;。封装到上面提到的&lt;strong&gt;MY_Controller&lt;/strong&gt;里面其实也不是很合适，个人认为那里适合放一些对CI框架的封装及操作，属于框架扩展层面的，而不应该存放业务逻辑。因此我个人认为应该写个专门的类继承&lt;strong&gt;MY_Controller&lt;/strong&gt;，里面放这些业务逻辑通用代码，都是protected的，然后具体的业务类都继承这个类。&lt;/p&gt;

&lt;p&gt;在model层，本身就有一些变量只应该内部使用，比如表名之类的，开发工作中的model层这些变量基本没有被限制过，都是暴露出去的，只有一些私有方法。sign&lt;/p&gt;

&lt;h2 id=&#34;get:960e085aadb29182f9448019a6b3c8f1&#34;&gt;__get()&lt;/h2&gt;

&lt;p&gt;为啥我会提到这个，这是个悲伤的故事。&lt;/p&gt;

&lt;p&gt;上面说到利用&lt;code&gt;protected&lt;/code&gt;的概念改写了一些公司对CI封装的代码，在controller层其实没什么问题，在model层有些问题，因为有些情况下还是会需要访问极个别被保护起来的变量，为了实现这个需求一个方案是在业务model类里面重新设定这些变量的修饰词，但这样就可以修改这些变量了，另一个方案是仅仅给这些变量读的权限，于是我就想到了魔术方法&lt;code&gt;__get()&lt;/code&gt;，然后我就在model层基类写下了以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __get($name){
	if(in_array($name,[&#39;tableName&#39;])) {
		return $this-&amp;gt;$name;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里逻辑上没什么问题，然后我就去测试了，然后就报错了。直接说原因：我封装的model层基类继承自&lt;code&gt;CI_Model&lt;/code&gt;，在这个类里面有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __get($key){
	return get_instance()-&amp;gt;$key;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看代码就差不多明白了吧，同时通过这段代码，CI实现了在model层调用&lt;code&gt;CodeIgniter&lt;/code&gt;的属性和方法。所以修改后的代码是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __get($name){
	if(in_array($name, [&#39;is_inited&#39;])){
		return $this-&amp;gt;$name;
	}else{
		return parent::__get($name);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;final:960e085aadb29182f9448019a6b3c8f1&#34;&gt;final&lt;/h2&gt;

&lt;p&gt;之所以会提及这个关键词也是很偶然的，今天老板吐槽一个同事经常重载诸如&lt;code&gt;insert_db&lt;/code&gt;之类的基础函数，然后就谈到了稍微大型的项目就不会让每个人都接触整个项目代码了，很有可能一个人只负责几个controller或者model，基类整体就是只暴露可以调用的方法，内部实现根本看不到，那问题就是如何防止重载基础函数，老板说跑脚本检测之类的，但是最简单的实现就是在想要防止重载的方法加上&lt;code&gt;final&lt;/code&gt;修饰词，能用语言本身解决的问题还需要跑脚本之类的折腾吗。&lt;/p&gt;

&lt;p&gt;之所以要重载是因为想做些额外的事情，那在使用final关键词的情况下解决如何做这些额外的事情？答案是使用&lt;strong&gt;钩子函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;model:960e085aadb29182f9448019a6b3c8f1&#34;&gt;model&lt;/h2&gt;

&lt;p&gt;根据CI的文档，model层是用来负责和数据库打交道的，在我们的项目中，把model分成了两类，一类是record_model,负责处理一条数据，另一类是list_model，负责处理多条数据，record_model是list_model的基础。这两个类都是继承自CI_model，作为对CI的进一步封装，这两个类上封装了一系列方法，用于对数据进行加载和处理，同时作为业务类的基础。由于一些历史原因，里面有许多方法封装的并不是很合适以至于，所以我要各种修修补补。&lt;/p&gt;

&lt;h2 id=&#34;改变应用路径:960e085aadb29182f9448019a6b3c8f1&#34;&gt;改变应用路径&lt;/h2&gt;

&lt;p&gt;在CI中原始的项目代码是放在&lt;code&gt;application&lt;/code&gt;目录下，而&lt;code&gt;index.php&lt;/code&gt;和该目录同级，出于安全及复杂应用的考虑，我们可以考虑改变入口文件&lt;code&gt;index.php&lt;/code&gt;的位置及项目代码目录的名称。
比如说我们把原来的application目录修改为app_user，在和该目录同级建立一个www_user目录，把入口文件放到该目录下，
为此，我们需要再index.php中进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$application_folder = getcwd().&#39;/../app_user&#39;;
$system_path = &#39;../system&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;辅助函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;辅助函数&lt;/h2&gt;

&lt;p&gt;CI提供了一些使用面向过程写的辅助函数，我扩展的是url_helper，毕竟web开发离不开url的处理。首先是对这个文件的自动加载，在autoload文件中的&lt;code&gt;autoload[&#39;helper&#39;]&lt;/code&gt;数组中添加一项&lt;code&gt;url&lt;/code&gt;这样就能自动加载了。&lt;/p&gt;

&lt;p&gt;然后是添加我的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;static_url&#39;))
{
	function static_url($uri = &#39;&#39;)
	{
		$CI =&amp;amp; get_instance();
		return $CI-&amp;gt;config-&amp;gt;static_url($uri);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数的目标是处理对本地文件的引用路径（比如js、css还有图片）。&lt;/p&gt;

&lt;p&gt;具体实现是在&lt;strong&gt;system/core/config.php&lt;/strong&gt;中。&lt;/p&gt;

&lt;h2 id=&#34;static:960e085aadb29182f9448019a6b3c8f1&#34;&gt;static&lt;/h2&gt;

&lt;p&gt;在使用CI的时候，经常会调用&lt;code&gt;get_instance&lt;/code&gt;这个函数，看一下具体实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_instance()
{
	return CI_Controller::get_instance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来在CI_Controller上有一个静态方法&lt;code&gt;get_instance&lt;/code&gt;，我们再去找CI_Controller的相关代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function &amp;amp;get_instance()
{
	return self::$instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来CI_Controller里面有一个受保护的的静态成员&lt;code&gt;$instance&lt;/code&gt;,再去找它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static $instance;
public function __construct()
{
	self::$instance =&amp;amp; $this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那结果很显然，这个静态私有变量保存着对controller实例的引用。&lt;/p&gt;

&lt;p&gt;最近想优化点代码，遇到了这么一个需求：父类非静态方法中访问子类的静态属性。如果是父类非静态方法访问父类静态/非静态属性，或者子类非静态方法访问父类/子类的静态/非静态属性，或者父类非静态方法访问子类非静态属性，这些都好说，唯独父类非静态方法访问子类静态属性比较折腾。&lt;/p&gt;

&lt;p&gt;最终的解决方案是利用了下面提到的&lt;code&gt;get_class&lt;/code&gt;方法，在父类的非静态方法中，使用&lt;code&gt;get_class($this)&lt;/code&gt; (我想你应该明白为什么我会一直强调非静态方法了吧)，拿到子类的类名之后获取其静态属性就没什么难度了吧。&lt;/p&gt;

&lt;h2 id=&#34;spl-autoload-register:960e085aadb29182f9448019a6b3c8f1&#34;&gt;spl_autoload_register&lt;/h2&gt;

&lt;p&gt;这个函数其实不是CI中使用的，而是项目中对CI进行扩展的时候使用的，其作用相当于是对于&lt;code&gt;__autoload&lt;/code&gt;的加强版。其实稍微大点的项目用得到，小项目用&lt;code&gt;__autoload&lt;/code&gt;就行了。&lt;/p&gt;

&lt;p&gt;我们用它做了什么？在CI中，如果要加载并实例化某个类并挂到CI上，我们需要使用load方法，但是有的时候我们只想使用这个类的实例，并不想挂到CI指针上，比如说在一个model中加载另一个model，我们该怎么办？一个方法是需要的时候手动include或者require，当然这样比较累，另一种方法就是__autoload啦。最终的结果是我们可以使用new关键字实例化一个model而不需要手动加载文件。&lt;/p&gt;

&lt;h2 id=&#34;date:960e085aadb29182f9448019a6b3c8f1&#34;&gt;date&lt;/h2&gt;

&lt;p&gt;之所以说它是因为出了一个小bug，我想要处理时间戳显示时间，然后第一个参数填了&lt;code&gt;&#39;Y-m-d h:i&#39;&lt;/code&gt;,然后就出bug了，因为这里的h是指12小时制。这个函数常用的其实就那么几个参数。&lt;a href=&#34;http://php.net/manual/zh/function.date.php&#34;&gt;手册&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;json-decode:960e085aadb29182f9448019a6b3c8f1&#34;&gt;json_decode&lt;/h2&gt;

&lt;p&gt;一般来说&lt;code&gt;json_decode&lt;/code&gt;用到的很少，主要用到的是&lt;code&gt;json_encode&lt;/code&gt;。以前不知道前端如何向后端传递复杂数据类型，然后就前端转成json然后给后端，后端decode，然后当时也不知道还有第二个参数所以后端以对象的语法访问。后来看其他人的代码，知道在jquery中可以传递数组和对象然后jquery格式化。    今天在看jquery如何实现序列化，突然想到了这个话题。&lt;/p&gt;

&lt;h2 id=&#34;json-encode-转义:960e085aadb29182f9448019a6b3c8f1&#34;&gt;json_encode 转义&lt;/h2&gt;

&lt;p&gt;在写&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/lottery/index.html&#34;&gt;抽奖效果&lt;/a&gt;的时候遇到一个需求，对于奖项进行换行显示，因为canvas本身不支持文字换行，所以我们最开始约定使用\n作为分隔符，人工进行换行处理。然而最开始并不能正常进行分割，一开始以为是中文的问题，然后查了查&lt;a href=&#34;http://php.net/manual/zh/function.json-encode.php&#34;&gt;发现&lt;code&gt;json_encode&lt;/code&gt;有第二个参数（通过json_encode传递奖项array）&lt;/a&gt;，对中文不转义之后发现依然无法正常显示，然后就猜是转义的问题。确实有转义的问题但不仅仅是转义的问题，因为在单引号下，json_encode的结果无法正常分割但是直接php输出这一子项的结果可以正常分割，双引号下json_encode的结果可以分割但是直接输出的结果直接报错。总之，为啥当初用\n这种符号分割呢。&lt;/p&gt;

&lt;h2 id=&#34;变量作用域:960e085aadb29182f9448019a6b3c8f1&#34;&gt;变量作用域&lt;/h2&gt;

&lt;p&gt;之所以会提及这个问题是因为看CI源码时遇到了这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_config(Array $replace = array())
{
	static $config;
	if (empty($config))
	{
		$file_path = APPPATH.&#39;config/config.php&#39;;
		$found = FALSE;
		if (file_exists($file_path))
		{
			$found = TRUE;
			require($file_path);
		}
	}
	return $config;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数首先声明了一个静态局部变量&lt;code&gt;$config&lt;/code&gt;，然后如果这个变量为空就去加载对应文件，文件中有一个名为&lt;code&gt;$config&lt;/code&gt;的变量。觉得这里写的比较巧妙，如果直接加在这个文件，就会设立一个全局变量&lt;code&gt;$config&lt;/code&gt;，容易被修改或者覆盖，这里将其转化为局部静态变量，从而起到了保护的作用，类似于js的闭包。&lt;/p&gt;

&lt;p&gt;说起作用域，js和php还是有点差异的，比如js局部变量没有会沿着作用域链向上查找，而在php中在局部想要访问全局变量需要手动添加&lt;code&gt;global&lt;/code&gt;关键字。php中的静态变量和js中闭包中的变量很类似。写php面向对象惯了反而对作用域关注的少了。&lt;/p&gt;

&lt;h2 id=&#34;server:960e085aadb29182f9448019a6b3c8f1&#34;&gt;$_SERVER&lt;/h2&gt;

&lt;p&gt;以前一直不明白CI是如何根据url确定需要初始化的controller是哪个、调用的方法是哪个、以及参数。看CI源码就明白了，在超全局变量&lt;code&gt;$_SERVER&lt;/code&gt;保存着请求的url，通过&lt;code&gt;CI_Router&lt;/code&gt;和&lt;code&gt;CI_URI&lt;/code&gt;两个类进行字符串处理就可以得到controller、method以及参数。&lt;/p&gt;

&lt;h2 id=&#34;魔术常量:960e085aadb29182f9448019a6b3c8f1&#34;&gt;魔术常量&lt;/h2&gt;

&lt;p&gt;之前提到了魔术方法，这里说一下魔术常量。对于一般的开发工作来说基本上用不到魔术常量，但是对于框架确实需要，在CI框架中见过这么几个魔术常量的使用：&lt;code&gt;__FILE__&lt;/code&gt;、&lt;code&gt;__DIR__&lt;/code&gt;，可以看到都是和文件路径相关的。我觉得可能会用到的有&lt;code&gt;__FUNCTION__&lt;/code&gt;和&lt;code&gt;__CLASS__&lt;/code&gt;,后者可以被系统函数&lt;code&gt;get_class&lt;/code&gt;一定程度上取代。在使用继承的时候，&lt;code&gt;get_class&lt;/code&gt;返回的是最终的子类的类名，而魔术常量&lt;code&gt;__class__&lt;/code&gt;的具体值和调用的位置有关，在哪个类中被调用就是那个类。&lt;/p&gt;

&lt;h2 id=&#34;func-get-args-func-get-arg-func-num-args:960e085aadb29182f9448019a6b3c8f1&#34;&gt;func_get_args  func_get_arg  func_num_args&lt;/h2&gt;

&lt;p&gt;在js中有个arguments,通过这个类数组可以找到函数的参数，题目中的三个函数所起到的作用和js的arguments差不多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>上网的不科学指南</title>
      <link>https://jiangshanmeta.github.io/post/computernetwork/summarize/</link>
      <pubDate>Tue, 16 Aug 2016 20:03:58 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/computernetwork/summarize/</guid>
      <description>&lt;p&gt;看计算机网络已经有一段时间了，对于应用层、传输层、网络层、链路层也有了基本的了解。但是感觉自己学的比较零碎，缺乏一个整体的概念，所以想写一篇总结，把这些东西串起来。&lt;/p&gt;

&lt;p&gt;想要上网的话，首先要通过&lt;strong&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;&lt;/strong&gt;获得一个IP地址。&lt;/p&gt;

&lt;p&gt;客户端这里首先生成一个DHCP发现报文，然后把这个报文交给传输层传输层的&lt;code&gt;UDP&lt;/code&gt;，DHCP有固定的源端口号和目的端口号。&lt;code&gt;UDP&lt;/code&gt;封装好之后，交给网络层去处理，网络层的IP报文需要填写目的IP地址和源IP地址，然而目前自身的IP待分配、目的IP地址也未知，这里就需要两个特殊的IP地址了，源IP地址为&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，目的IP地址为&lt;code&gt;255.255.255.255&lt;/code&gt;表示广播地址。网络层处理完交给数据链路层处理，需要源MAC地址和目的MAC地址，现在连DHCP服务器是谁都不知道怎么确定MAC地址？答案和刚提到的广播IP地址类似，目的MAC地址填上广播MAC地址&lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;局域网内部的每一台主机都能收到这个报文，但是只有DHCP服务器才会做出响应。对于DHCP服务器，数据自下传递到上层，然后把分配的IP地址、DNS服务器地址、默认网关地址、子网掩码 作为DHCP ACK报文，然后向下逐层封装。形成IP报文的时候目的地址依然为广播地址。在这里说一句无论是DHCP发现报文还是DHCP ACK报文，中间都经过&lt;code&gt;链路层交换机&lt;/code&gt;，链路层交换机会根据源MAC地址和输入链路的接口在交换机表中记录一条记录，作为转发的基础。&lt;/p&gt;

&lt;p&gt;现在我们这台主机获得了自己的IP地址，顺便还有默认DNS服务器地址、默认网关地址、子网掩码。当我们在地址栏中输入一个url的时候，比如 &lt;a href=&#34;http://jiangshanmeta.github.io&#34;&gt;http://jiangshanmeta.github.io&lt;/a&gt; ，就需要通过&lt;code&gt;DNS&lt;/code&gt;服务（至少对于chrome调用DNS不见得一定在输入url然后确认之后，我们没有必要关心这个调用的时机）。DNS服务器地址是在DHCP返回的，有可能和我们的主机在一个子网内，也可能不在一个子网内，这需要结合两者的IP地址和&lt;strong&gt;子网掩码&lt;/strong&gt;判断，通常不要指望在一个子网内。要和子网外部进行通信需要通过网关，我们已经有了默认网关地址（一个IP地址），但是数据链路层需要MAC地址，因而我们需要&lt;code&gt;ARP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;ARP是根据IP地址返回MAC地址，它也是利用广播，子网内每台主机都会收到ARP报文，但是只有IP地址对应的才会返回MAC地址。通过ARP获得默认网关MAC地址，这样在主机那里各层发送DNS报文所需要的基本信息就有了，DNS交给UDP、UDP交给IP然后交给链路层封装成帧，所形成的数据帧传递到路由器，路由器这里根据由&lt;code&gt;路由协议&lt;/code&gt;（这么复杂的协议我说这么一句话真的好吗）决定的转发表决定转发的输出链路，根据转发表提供的下一跳IP地址利用ARP获得新的目的MAC地址重写数据链路层（在路由器网络层首部和数据链路层都会有一些首部字段被修改，目的MAC地址是每经过一次路由器就修改，但是目的IP地址相一般不会修改，除非是经过了&lt;code&gt;NAT&lt;/code&gt;）。本地DNS服务器获得请求之后，可能&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;经过一系列请求&lt;/a&gt;，也可能直接根据缓存返回要查询的IP地址。这样我们的主机获得了请求域名的IP地址，对网页的请求的准备工作基本完成了。&lt;/p&gt;

&lt;p&gt;现在需要发起HTTP请求了，以我上面提到的网址为例就是发送一个GET请求，应用层把http报文交给TCP，TCP相比较上面提到的传输层协议UDP，提供可靠传输功能。它需要首先建立连接，然后才能传递上层传来的数据。再往下层的东西上面已经提及了，通过网关出子网，然后经过各种路由转发最终到达目标服务器，目标服务器根据请求的url提供文件，然后又是一层层封装路由转发解封装到达应用层，这样我们得到了请求的文件，比如html，剩下的就是浏览器如何解析返回的数据了，这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;这样我基本上把所学到的计算机网络知识串了起来，包括&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;DNS&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/&#34;&gt;http&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;传输层&lt;/a&gt;的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/&#34;&gt;TCP&lt;/a&gt;和UDP、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;、网络层的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/ip/&#34;&gt;网际协议&lt;/a&gt;和路由协议、NAT、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/mac/&#34;&gt;链路层MAC地址、ARP协议（这是个跨层的协议）、链路层交换机&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;每一层都有了一定的了解，下面的任务是转入http协议的学习和设计模式的学习了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初识链路层</title>
      <link>https://jiangshanmeta.github.io/post/computernetwork/mac/</link>
      <pubDate>Mon, 15 Aug 2016 20:48:45 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/computernetwork/mac/</guid>
      <description>

&lt;p&gt;数据链路层是五层协议栈的第二层，其实对于一般的web开发已经离得有点远了（至少在目前的我看来是这样的），而且个人学习起来这一层感觉东西略杂，尽可能抽出一点主线来吧，并且尽可能对比其它层的协议，这样能加深理解。首先要介绍的是MAC地址的概念。&lt;/p&gt;

&lt;h2 id=&#34;mac地址:7be74c584635419861677fc2502187c9&#34;&gt;MAC地址&lt;/h2&gt;

&lt;p&gt;其实MAC地址这个概念还是比较大众的，它的作用和网络层中的IP地址类似，是对链路层的唯一标示。你可能会问通过IP地址就已经能标示到唯一的主机（网络层接口了），何苦再加一层呢？原因比较复杂，这里就说一个我比较认同的理由，是为了分层，出于分层的考虑网络层的寻址和数据链路层的寻址就应该独立的，而且网络层也不仅仅是IP协议啊。&lt;/p&gt;

&lt;p&gt;介绍完MAC地址的作用，接下来要介绍的是MAC地址到底长什么样了。MAC地址是一个48位的二进制数（而IP地址仅有32位），一个网卡对应的MAC地址不是由什么协议动态分配的，而是出厂就设定好了的，换句话说MAC地址是物理层面一块网卡的唯一标示，类似于人的身份证号（对比IP地址，IP地址需要利用DHCP从DHCP获取）。&lt;/p&gt;

&lt;p&gt;有了之前传输层（源端口号、目的端口号）、网络层（源IP地址、目的IP地址）的经验，很自然我们会想到数据链路层的报文中会含有源MAC地址和目的MAC地址。源MAC地址很好获得，毕竟是网卡一出生就带有的，那目的MAC地址是如何获得的呢？这就需要请出ARP来了。&lt;/p&gt;

&lt;h2 id=&#34;arp:7be74c584635419861677fc2502187c9&#34;&gt;ARP&lt;/h2&gt;

&lt;p&gt;ARP协议的作用类似于DNS，根据IP地址返回对应的MAC地址。发送方构建ARP报文，包含源和目的IP、MAC地址。你可能会说，目的IP可以通过DNS、DHCP获得，这个目的MAC地址不是我们要查找的吗，怎么会在发送报文里出现（类似的问题在DHCP中也遇到过）。既然在DHCP中也遇到过，在那里我们提到了一个广播IP地址（255.255.255.255）的概念，我们很容易猜想到也应该有个广播MAC地址的概念，显然确实是有，对应为 &lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;，48位全为1，这样同一个局域网内的主机都会收到ARP报文，但是只有IP地址和目的地址一致的才会作出相应，返回MAC地址。&lt;/p&gt;

&lt;p&gt;源主机得到这条IP地址到MAC地址的映射关系之后，不会只用这么一次然后以后用到的时候再去查询一遍，而是维护一个ARP表表示这种映射关系。（类似结构的表已经见过不少次了，比如DNS、NAT、路由转发表）。&lt;/p&gt;

&lt;p&gt;上面介绍的时候我加了一个限制词：&lt;strong&gt;在同一个局域网内&lt;/strong&gt;，那要出了局域网怎么办？根据目的主机IP地址找对应的MAC地址？答案是不行的。要想出这个子网需要通过网关（通过DHCP可以获得默认网关IP地址，再通过ARP获得默认网关的的MAC地址），网关那里查询路由转发表，根据下一跳IP地址同样通过ARP获得相应的MAC地址，也就是说每经过一次路由器链路层的目的MAC地址都会被改写。&lt;/p&gt;

&lt;h2 id=&#34;以太网:7be74c584635419861677fc2502187c9&#34;&gt;以太网&lt;/h2&gt;

&lt;p&gt;局域网可以大体分为有线局域网和无线局域网，以太网几乎占领了有线局域网。&lt;/p&gt;

&lt;p&gt;仅仅从以太网帧的角度来看这并不复杂，以太网帧包含上层数据、源MAC地址、目的MAC地址、类型（类似于IP报文中的上层协议、TCP/UDP报文中的端口号）、CRC（功能上类似于各层的校验和字段，但是实现上不太一致）、前同步码。&lt;/p&gt;

&lt;p&gt;以太网比较复杂的一个问题是如何让多个节点共享一个广播链路，即多路访问问题。解决这个问题有许多方案，每个方案也有许多变种，目前的我认为没有必要去关心如何实现的，我们仅需知道能够解决碰撞带来的问题即可。&lt;/p&gt;

&lt;h2 id=&#34;链路层交换机:7be74c584635419861677fc2502187c9&#34;&gt;链路层交换机&lt;/h2&gt;

&lt;p&gt;让我们把目光集中到一个子网内，看一下子网内的主机是如何互联起来的。既然是子网内，就没有路由器什么事了，设备只有链路层交换机。每台主机与链路层交换机相连，链路层交换机既可以与主机相连，也可以与其他链路层交换机相连。对于主机而言，链路层交换机是透明的，在一个子网内传递报文，只需要目的主机的MAC地址与IP地址即可，不需要这个链路层交换机的MAC地址（链路层交换机本身不具有MAC地址这个概念）。数据到达链路层交换机，那链路层交换机根据什么决定到哪条出链路上的呢？这个问题形式上看起来很熟悉，路由器的转发功能和这个简直是如出一辙，路由器转发是根据路由转发表，路由转发表由路由协议进行维护更新，数据链路层也有一个类似的交换机表，但这个表中的数据不是由什么协议维护的，而是交换机自学习得到的。&lt;/p&gt;

&lt;p&gt;下面解释一下这个自学习是怎么回事。当一条数据通过接口A经过交换机的时候，交换机可以读取到报文中的源MAC地址B，这样在转发表中就记录一条 如果目的MAC地址是B，则通过A接口转发。这条记录也有一个类似TTL的概念，用于更新交换机表。&lt;/p&gt;

&lt;p&gt;当数据通过交换机时，如果在交换机表中有一条记录，那显然转发到响应接口上，根据上面说的自学习这点不难理解。如果没有相应记录，交换机就在所有链路上广播该报文，让主机自行决定是否是目的主机 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>终于bootstrap满足不了我了——用flex实现一个栅格系统</title>
      <link>https://jiangshanmeta.github.io/post/css/flex/</link>
      <pubDate>Sat, 13 Aug 2016 14:16:46 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/css/flex/</guid>
      <description>&lt;p&gt;bootstrap样式方面我觉得最重要的就是栅格系统了，然而在实际项目中觉得有些情况它所能提供的满足不了我的需求了。最近感受比较深的就是列表展示页面，每一个列表项对应的图片文字大小所需空间不一致，我的一个解决方案是利用CSS文字强制只显示一行或多行（不知道如何实现的自行百度），然后图片&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;放在一个正方形的盒子里展示&lt;/a&gt;，确实是一个解决问题的方法但我觉得不够优雅。其实根本问题出现在bootstrap的栅格系统是基于浮动的，每一个列高度不一致导致布局错乱显然是不可避免的。bootstrap也考虑到了这个问题，他们的解决方案是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;建议联合使用 .clearfix 和 响应式工具类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说的没错，只要在每行之间加上一个&lt;code&gt;.clearfix&lt;/code&gt;确实能解决问题。但是我显然是动态输出页面的啊，我还要手动写个计数器然后输出这个清除浮动的标签，总觉得略折腾。&lt;/p&gt;

&lt;p&gt;那既然问题是不等高造成的做个等高布局怎么样？ 说的就和等高布局好做似的。padding撑出去+margin缩回来方案hack意味太浓，table的同行单元格等高这一属性可以利用但是我还要输出表示行的标签，折腾程度差不多，响应式处理起来更折腾，那似乎就剩下flex了。但是对于flex float又直接失效。&lt;/p&gt;

&lt;p&gt;于是我想着干脆用flex模拟一个bootstrap的栅格系统，对于熟悉flex布局和bootstrap的同学这并不难。&lt;/p&gt;

&lt;p&gt;首先是container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
	box-sizing:border-box;
}
.flex-container {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
@media (min-width: 768px) {
  .flex-container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .flex-container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .flex-container {
    width: 1170px;
  }
}
.flex-container-fluid {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是每一列的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-12 {
	flex:0 0 100%;
}
.flex-col-xs-11 {
	flex:0 0 91.66666667%;
}
.flex-col-xs-10 {
	flex:0 0 83.33333333%;
}
.flex-col-xs-9 {
	flex:0 0 75%;
}
.flex-col-xs-8 {
	flex:0 0 66.66666667%;
}
.flex-col-xs-7 {
	flex:0 0 58.33333333%;
}
.flex-col-xs-6 {
	flex:0 0 50%;
}
.flex-col-xs-5 {
	flex:0 0 41.66666667%;
}
.flex-col-xs-4 {
	flex:0 0 33.33333333%;
}
.flex-col-xs-3 {
	flex:0 0 25%;
}
.flex-col-xs-2 {
	flex:0 0 16.66666667%;
}
.flex-col-xs-1 {
	flex:0 0 8.33333333%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是列的响应式处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media (min-width: 768px) {
	.flex-col-sm-12 {
		flex:0 0 100%;
	}
	.flex-col-sm-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-sm-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-sm-9 {
		flex:0 0 75%;
	}
	.flex-col-sm-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-sm-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-sm-6 {
		flex:0 0 50%;
	}
	.flex-col-sm-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-sm-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-sm-3 {
		flex:0 0 25%;
	}
	.flex-col-sm-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-sm-1 {
		flex:0 0 8.33333333%;
	}
}


@media (min-width: 992px) {
	.flex-col-md-12 {
		flex:0 0 100%;
	}
	.flex-col-md-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-md-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-md-9 {
		flex:0 0 75%;
	}
	.flex-col-md-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-md-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-md-6 {
		flex:0 0 50%;
	}
	.flex-col-md-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-md-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-md-3 {
		flex:0 0 25%;
	}
	.flex-col-md-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-md-1 {
		flex:0 0 8.33333333%;
	}

}

@media (min-width: 1200px) {
	.flex-col-lg-12 {
		flex:0 0 100%;
	}
	.flex-col-lg-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-lg-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-lg-9 {
		flex:0 0 75%;
	}
	.flex-col-lg-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-lg-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-lg-6 {
		flex:0 0 50%;
	}
	.flex-col-lg-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-lg-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-lg-3 {
		flex:0 0 25%;
	}
	.flex-col-lg-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-lg-1 {
		flex:0 0 8.33333333%;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列偏移部分，只列出了xs部分，没写响应式部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-offset-12 {
  margin-left: 100%;
}
.flex-col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.flex-col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.flex-col-xs-offset-9 {
  margin-left: 75%;
}
.flex-col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.flex-col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.flex-col-xs-offset-6 {
  margin-left: 50%;
}
.flex-col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.flex-col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.flex-col-xs-offset-3 {
  margin-left: 25%;
}
.flex-col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.flex-col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.flex-col-xs-offset-0 {
  margin-left: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列排序，和bootstrap一样，基于&lt;code&gt;position:relative&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-1,
.flex-col-xs-2,
.flex-col-xs-3,
.flex-col-xs-4,
.flex-col-xs-5,
.flex-col-xs-6,
.flex-col-xs-7,
.flex-col-xs-8,
.flex-col-xs-9,
.flex-col-xs-10,
.flex-col-xs-11,
.flex-col-xs-12{
	position:relative;
}

.flex-col-xs-pull-12 {
  right: 100%;
}
.flex-col-xs-pull-11 {
  right: 91.66666667%;
}
.flex-col-xs-pull-10 {
  right: 83.33333333%;
}
.flex-col-xs-pull-9 {
  right: 75%;
}
.flex-col-xs-pull-8 {
  right: 66.66666667%;
}
.flex-col-xs-pull-7 {
  right: 58.33333333%;
}
.flex-col-xs-pull-6 {
  right: 50%;
}
.flex-col-xs-pull-5 {
  right: 41.66666667%;
}
.flex-col-xs-pull-4 {
  right: 33.33333333%;
}
.flex-col-xs-pull-3 {
  right: 25%;
}
.flex-col-xs-pull-2 {
  right: 16.66666667%;
}
.flex-col-xs-pull-1 {
  right: 8.33333333%;
}
.flex-col-xs-pull-0 {
  right: auto;
}
.flex-col-xs-push-12 {
  left: 100%;
}
.flex-col-xs-push-11 {
  left: 91.66666667%;
}
.flex-col-xs-push-10 {
  left: 83.33333333%;
}
.flex-col-xs-push-9 {
  left: 75%;
}
.flex-col-xs-push-8 {
  left: 66.66666667%;
}
.flex-col-xs-push-7 {
  left: 58.33333333%;
}
.flex-col-xs-push-6 {
  left: 50%;
}
.flex-col-xs-push-5 {
  left: 41.66666667%;
}
.flex-col-xs-push-4 {
  left: 33.33333333%;
}
.flex-col-xs-push-3 {
  left: 25%;
}
.flex-col-xs-push-2 {
  left: 16.66666667%;
}
.flex-col-xs-push-1 {
  left: 8.33333333%;
}
.flex-col-xs-push-0 {
  left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个基于flex的栅格系统就差不多了，包含响应式布局、列偏移、列排序，其实还可以列嵌套，我其实还可以宣称自己基于移动优先的理念之类的。和bootstrap的栅格系统相比，还差点兼容性以及gutter的概念，这个没什么难的，就这样吧。&lt;/p&gt;

&lt;p&gt;还有，女神叫我出去浪，我却在这写博客，终于明白为什么我会孤独一生了。&lt;/p&gt;

&lt;p&gt;update 2016/08/17&lt;/p&gt;

&lt;p&gt;还是把&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.less&#34;&gt;less文件&lt;/a&gt;  和 &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.css&#34;&gt;编译出来的CSS文件放到这里吧&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>网际协议</title>
      <link>https://jiangshanmeta.github.io/post/computernetwork/ip/</link>
      <pubDate>Tue, 02 Aug 2016 23:26:56 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/computernetwork/ip/</guid>
      <description>

&lt;p&gt;IPv4协议&lt;/p&gt;

&lt;p&gt;计算机网络的网络层主要功能是&lt;strong&gt;转发&lt;/strong&gt;和&lt;strong&gt;路由&lt;/strong&gt;，转发是将分组从一个输入链路接口转移到合适的输出链路接口的路由器本地动作，路由是指网络范围内的过程，以决定分组从源到目的地所采取的端到端路径。&lt;/p&gt;

&lt;p&gt;合适的输出路径是如何确定的？输出链路是通过查询转发表根据&lt;strong&gt;最长前缀匹配规则&lt;/strong&gt;进行确定的。转发表是根据路由选择协议设定的，并且是动态更新的，换句话说，源和目的地址相同的两个IP报文，可能走不同的路线，因而不能保证先后顺序。&lt;/p&gt;

&lt;p&gt;那这个&lt;strong&gt;最长前缀匹配规则&lt;/strong&gt;又是什么？为了讲清楚这个，首先需要对IP地址有一定的基础了解。&lt;/p&gt;

&lt;h2 id=&#34;ipv4地址:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;IPv4地址&lt;/h2&gt;

&lt;p&gt;之前我&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;描述了计算机如何获取IP地址&lt;/a&gt;，在那里对IP地址做了最基本的描述。&lt;/p&gt;

&lt;p&gt;IPv4地址是一个32位的二进制数字，为了便于人类阅读，通常我们按照&lt;strong&gt;点分十进制记法&lt;/strong&gt;表示IP地址。一台主机的IP地址不是完全自由分配的，而是要根据其所在的子网进行分配。那么如何表示这个子网？如何表示子网大小？解决方案是将IP地址分为两部分，前面表示网络号，后面的表示主机号，表现为&lt;code&gt;a.b.c.d/x&lt;/code&gt;的形式。比如&lt;code&gt;233.233.233.0/24&lt;/code&gt;，这表示这个这个子网前24位是网络号，后面的8位才能分配给主机（有些特殊的号码不能分配，这个另说）。在window下查看当前所属子网前缀是多少位，可在cmd下输入&lt;code&gt;ipconfig&lt;/code&gt;，可以看到如下内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/ipconfig.jpg&#34; alt=&#34;ipconfig&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这显示我所在的子网前24位（子网掩码转换成二进制就是前24位都是1），图中所示的IP地址是&lt;code&gt;192.168.1.12&lt;/code&gt;，这是一个私有地址，全球现在应该有N个这么一个地址，这一点我稍后再说。&lt;/p&gt;

&lt;p&gt;在上古时期，还有A类网址、B类网址、C类网址的说法，从现在的角度来看就是上面说的几个特例而已，A类网址的子网掩码为&lt;code&gt;255.0.0.0&lt;/code&gt;，也就是说前八位为网络号，后24位为主机号，A类网址每个子网很大但是数量上比较少。B类网址子网掩码为&lt;code&gt;255.255.0.0&lt;/code&gt;，前16位为网络号，后16位为主机号，C类网址子网掩码为&lt;code&gt;255.255.255.0&lt;/code&gt;，我当前所属的就是个C网，前24位为网络号，后8位为主机号。C网数量很多但是每个子网的规模较小。其实对于A类网址、B类网址、C类网址，还有IP地址范围的限制，分别对应&lt;code&gt;0.0.0.0&lt;/code&gt;——&lt;code&gt;127.255.255.255&lt;/code&gt;、&lt;code&gt;128.0.0.0&lt;/code&gt;——&lt;code&gt;191.255.255.255&lt;/code&gt;、&lt;code&gt;192.0.0.0&lt;/code&gt;——&lt;code&gt;223.255.255.255&lt;/code&gt;。看到这你可能会问，应该还有空缺的位置啊，其实还有D类网址、E类网址，但是都不能作为公网地址。&lt;/p&gt;

&lt;p&gt;IP地址中还有一些特殊值，先以表格的形式归纳在这里&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;网络号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;主机号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;做源&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;做目标&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在本网内部表示本机&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;本网内广播地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;特定值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;网络地址，表示一个网络&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;特定值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;直接广播地址，对特定网络进行广播&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;127&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;非全0或非全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;本地环回地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于前两个，在学习&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;&lt;strong&gt;DHCP&lt;/strong&gt;&lt;/a&gt;中已经遇到过了，&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，只能做源，&lt;code&gt;255.255.255.255&lt;/code&gt;表示本子网内的广播地址。后两个其实可以和前两个类比看，主机号全0表示当前网络，全1表示对这个网络进行广播，从另一个层面上看，不是所有合法数字都可以分配作为主机号，对于我这个C类网络，有8位主机号，并不意味着可以容纳2^8=256个ip，而是2^8-2=254个。最后一个对于搞web开发的人其实很熟悉，大家经常会看到&lt;code&gt;127.0.0.1&lt;/code&gt;就是一个环回地址。&lt;/p&gt;

&lt;p&gt;除了上面说的限制，还有私有地址的概念，上面截图中所示我的ip地址就处于一个私有网络中，对于A类网址、B类网址、C类网址，每一个均有一块作为私有地址，不能作为公网地址使用，C网的对应 &lt;strong&gt;192.168.0&lt;/strong&gt;——&lt;strong&gt;192.168.255&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然谈到私有地址的话题的，那我问个问题，为了实现主机到主机的逻辑通信，需要ip标示唯一主机，但是一个私有地址可以对应多台主机，那该怎么办？我们需要把私有地址映射到公有地址上去，这就需要下面要介绍的&lt;strong&gt;NAT&lt;/strong&gt;了。&lt;/p&gt;

&lt;h2 id=&#34;nat:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;NAT&lt;/h2&gt;

&lt;p&gt;NAT全称是网络地址转换，它的作用可以这么理解：NAT相当于是对整个子网进行了封装，在外界看来这个子网就像是一台主机，而不是多台设备。&lt;/p&gt;

&lt;p&gt;互联网的通信最终是应用进程和应用进程的通信，我们需要ip地址和端口号标示唯一的一个主机上的特定应用进程。使用了NAT，网络层报文的ip地址在路由器上被改写成路由器在公网上的地址，解决了私有地址不能在公网出现的问题，目标主机会把这台路由器当成是源主机看待，但是路由器上并不存在端口号对应的应用进程，我们需要把目标主机的返回报文传给真正的源主机，那又如何找到源主机呢？&lt;/p&gt;

&lt;p&gt;其实在报文进入公网的时候，不仅仅是ip地址被重写了，端口号也被重写了，新端口号和源主机ip及端口号的映射关系保存在&lt;strong&gt;NAT&lt;/strong&gt;转换表中。通过查询这张表即可找到源主机ip及源端口号。&lt;/p&gt;

&lt;p&gt;这么说可能比较晦涩，举个例子，我使用的这台主机的ip &lt;code&gt;192.168.1.12&lt;/code&gt;，在端口号2333发送一个报文到公网某个主机某个端口，这个地址是私有地址，通过了&lt;strong&gt;NAT路由器&lt;/strong&gt;之后网络层报文 源ip地址字段被修改成了路由器的公网ip，比如&lt;code&gt;233.233.233.233&lt;/code&gt;，然后根据源主机ip&lt;code&gt;192.168.1.12&lt;/code&gt;和源端口号2333生成一个新的端口号 5678，并在路由器中保存类似&lt;code&gt;5678=&amp;gt;[&#39;ip&#39;=&amp;gt;&#39;192.168.1.12&#39;,&#39;port&#39;=&amp;gt;2333]&lt;/code&gt;这样的一条记录，对于目的主机，它认为与自己通信的主机ip是&lt;code&gt;233.233.233.233&lt;/code&gt;，端口号是5678。到了&lt;strong&gt;NAT路由器&lt;/strong&gt;这里，发现端口号是5678，从&lt;strong&gt;NAT转换表&lt;/strong&gt;中找到真实源主机ip&lt;code&gt;192.168.1.12&lt;/code&gt;和真实端口号2333，然后修改报文把信息传给相应的进程。&lt;/p&gt;

&lt;p&gt;关于NAT其实有很多争议，作为强迫症晚期患者我最不能忍的是路由器这里竟然修改了传输层首部字段中的源端口号，说好的只到网络层呢。&lt;/p&gt;

&lt;h2 id=&#34;ipv4报文:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;IPv4报文&lt;/h2&gt;

&lt;p&gt;IPv4报文和传输层报文结构上很类似，都是上层传过来的数据加上一堆自己的首部。前面已经提到了IPv4报文中含有源主机IP地址，下面具体讲一下IPv4报文的首部字段。&lt;/p&gt;

&lt;p&gt;首先源主机IP地址和目的主机IP地址，这个就类似于传输层报文中的端口号，用于标示通信的主机。&lt;/p&gt;

&lt;p&gt;传输层用端口号标示要把报文向上传递到哪里，对于IPv4报文，起到类似作用的是一个上层协议字段，网络层通过这个字段知道把报文传到TCP还是UDP还是其他。&lt;/p&gt;

&lt;p&gt;类似于TCP报文，IPv4报文也包含一些选项（虽然基本用不上），所以需要首部长度字段表明首部的长度信息，一般的IPv4报文具有20字节的首部，即不包含任何的选项。这里我们可以比较一下UDP报文、TCP报文和IPv4报文：TCP报文和IPv4报文都具有可选的首部，所以需要首部长度字段来反应可选字段的使用情况跟，而UDP报文首部字段的数量是一定的，因而不需要这个字段。UDP报文和IPv4报文都有一个报文长度字段，但是TCP却没有，这又是为什么？因为TCP提供面向连接的可靠地数据传输，它有确认字段表明哪些字段被成功接收到了，而UDP和IPv4没有连接什么事，你不告诉对方你发了多少数据对方怎么知道要接收多少、处理多少。&lt;/p&gt;

&lt;p&gt;update 2016/08/11 稍微看了一下数据链路层的知识，这里补充一下，对于以太网的数据报文，其对所包含的数据有最小长度限度，如果长度不足会补齐，但这些填充的数据也会被提交给网络层的IP，因而需要长度字段找出哪些是真正的数据，哪些是填充。&lt;/p&gt;

&lt;p&gt;而TCP、UDP、IPv4报文都含有校验和字段检测比特错误，不过IPv4和UDP都不具有差错恢复机制，IPv4会通过下面要说的&lt;strong&gt;ICMP&lt;/strong&gt;进行报错。&lt;/p&gt;

&lt;p&gt;下面介绍的几个字段就比较复杂了，他们是 标识、标志、片偏移。之所以出现三个字段是因为网络层的下层数据链路层，因为数据链路层对于数据包的大小有不同的要求，可能出现这样的情况：输入链路的能容得下数据包，但是输出链路容不下，那怎么办，总不能把数据包就这么丢了是吧。于是路由器会把IPv4报文进行进一步分割成片，使输出链路能容得下，在最终的端系统中对分出来的片进行组装。标识字段相当于是IPv4报文的一个id，表明那些片是属于同一个IP报文里的，标志字段有两个作用，一个是表明允不允许进行分片操作，如果不允许容不下的情况下只能丢掉了，另一个作用是表明是否是最后一个分片。片偏移字段表示的是在原数据报中的位置。通过上面三个字段，我们就能把数据从片还原成原来的IP报文。&lt;/p&gt;

&lt;p&gt;在上面我一直在写IPv4报文，但是大家熟悉的不是IP吗，为啥我要强调v4，这牵扯到版本字段了，其实IPv6这个概念应该也不陌生，到这里就说出关键点了，有两种版本的IP报文格式，所以需要版本字段表明按哪种格式去解读报文。&lt;/p&gt;

&lt;p&gt;最后要介绍的是寿命字段，每经过一台路由器时，这个字段就要减1，当减到零的时候该数据报就要被丢弃。&lt;/p&gt;

&lt;h2 id=&#34;icmp:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;ICMP&lt;/h2&gt;

&lt;p&gt;ICMP通常被认为是IP的一部分，但是从体系结构上讲它应该和TCP、UDP并列，话句话说，ICMP报文是作为IP报文的有效载荷的，ICMP的主要功能是进行差错报告。&lt;/p&gt;

&lt;h2 id=&#34;从传输层角度看网络层:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;从传输层角度看网络层&lt;/h2&gt;

&lt;p&gt;网络层通过网际协议实现了转发功能，通过路由选择协议实现路由功能，然而路由选择的东西真的看起来比较虐心，我们先就只关心网际协议吧。&lt;/p&gt;

&lt;p&gt;对于传输层，把需要传输的东西交给网络层，然后坐等网络层把数据交给自己，但是网络层有时候并不能把一些数据传送给传输层，这里就根据我个人的理解，说一下网络层不能把数据传送给传输层的原因。&lt;/p&gt;

&lt;p&gt;第一个原因是在路由器因为排队原因发生的丢包。毕竟路由器处理能力是有限的。&lt;/p&gt;

&lt;p&gt;第二个原因是数据错误，丢弃数据包，主要是利用校验和字段。&lt;/p&gt;

&lt;p&gt;第三个原因是分片无法被组装。&lt;/p&gt;

&lt;p&gt;第四个原因是因为寿命字段被减为零，路由器丢弃数据包，出现这个现象的原因可能是转发表错误进入了网络中的无限循环。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DHCP</title>
      <link>https://jiangshanmeta.github.io/post/computernetwork/dhcp/</link>
      <pubDate>Mon, 01 Aug 2016 19:40:53 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/computernetwork/dhcp/</guid>
      <description>&lt;p&gt;在学习传输层的基本知识的时候，知道了传输层实现不同主机应用进程之间的逻辑通信，当时还与网络层比较，网络层实现的是不同主机间的逻辑通信，标记应用进程用端口号，标记主机用IP。严格来说IP标记的接口（主机与物理链路的边界），而不是主机与路由器（换句话说一台主机或者路由器可能有多个接口，对应多个IP），我这里并不严格区分。&lt;/p&gt;

&lt;p&gt;IP地址其实是IP（网际协议）的一部分，对于IP地址，即使是不搞计算机相关领域的人也应该听说过，我们一般写作形如 233.233.233.233 的形式，但这本质上是一个32位的二进制数，只是我们每8位看成一个整体，转换成十进制数字，才有了上面的形式。那一台主机刚接入计算机网络的时候，是如何获得IP地址的呢？&lt;/p&gt;

&lt;p&gt;一个方法是手动设置，在window下可以在如下界面进行设置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/manualip.jpg&#34; alt=&#34;手动设置ip&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过对于广大人民群众（包括我）还是利用 &lt;strong&gt;DHCP&lt;/strong&gt; 动态获取IP地址的。下面的内容是描述如何通过 &lt;strong&gt;DHCP&lt;/strong&gt; 获取一个IP地址。&lt;/p&gt;

&lt;p&gt;首先，DHCP服务器发现。动态获得IP是通过&lt;strong&gt;DHCP服务器&lt;/strong&gt;分配的，对于一台新接入的计算机，显然要先找到这台服务器，那么问题来了，我怎么知道&lt;strong&gt;DHCP服务器&lt;/strong&gt;的IP（毕竟无论如何需要建立主机之间的逻辑通信）？答案是不知道，那就拿个大喇叭广播，我们使用 &lt;code&gt;255.255.255.255&lt;/code&gt; 作为目的地址，这样报文就会交付给同一个子网所有主机，并且此时这台主机没有IP地址，所以源地址是 &lt;code&gt;0.0.0.0&lt;/code&gt;。这时发送的报文称为 &lt;strong&gt;DHCP发现报文&lt;/strong&gt;，顺便说一句DHCP是基于UDP的。&lt;/p&gt;

&lt;p&gt;然后，DHCP服务器提供。广播的 &lt;strong&gt;DHCP发现报文&lt;/strong&gt; 子网内所有主机都会收到，但是只有 &lt;strong&gt;DHCP服务器&lt;/strong&gt; 会去做出响应。响应的报文称为 &lt;strong&gt;DHCP提供报文&lt;/strong&gt;，在这个报文中，源地址是这台服务器的地址，这点毫无疑问，目标地址是 &lt;code&gt;255.255.255.255&lt;/code&gt;，因为请求的主机此时还没有IP地址。那么问题来了，要接入网的主机通过什么知道这条信息是给自己的而不是给其它接入网的主机？通过 &lt;code&gt;transaction id&lt;/code&gt;，在&lt;strong&gt;DHCP发现报文&lt;/strong&gt; 里就包含这一信息，然后在 &lt;strong&gt;DHCP提供报文&lt;/strong&gt; 原样返回&lt;code&gt;transaction id&lt;/code&gt;。&lt;strong&gt;DHCP提供报文&lt;/strong&gt;里还会包含着一个分配到新客户的ip地址。&lt;/p&gt;

&lt;p&gt;随后，DHCP请求。由于一个子网可能会有多个&lt;strong&gt;DHCP服务器&lt;/strong&gt;，所以一条&lt;strong&gt;DHCP发现报文&lt;/strong&gt;可能会对应多条&lt;strong&gt;DHCP提供报文&lt;/strong&gt;，也就可能对应多个推荐ip地址。客户端需要选择一个最终的ip，发送&lt;strong&gt;DHCP请求报文&lt;/strong&gt;，因为可能有多个&lt;strong&gt;DHCP服务器&lt;/strong&gt;，所以采用的目的ip仍然是&lt;code&gt;255.255.255.255&lt;/code&gt;，通知最终结果，便于其他&lt;strong&gt;DHCP服务器&lt;/strong&gt;及时回收发出去的冗余ip地址。&lt;/p&gt;

&lt;p&gt;最后，DHCP服务器用 &lt;strong&gt;DHCP ACK报文&lt;/strong&gt;响应，进行最终确认。这样这台新接入的主机就获得了一个ip地址，同时获得的还有本地DNS服务器地址、网关地址。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>