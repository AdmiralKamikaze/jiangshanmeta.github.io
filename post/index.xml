<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on jsmeta</title>
    <link>http://jiangshanmeta.github.io/post/</link>
    <description>Recent content in Posts on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 Jul 2016 00:43:18 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DNS原理入门</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/dns/</link>
      <pubDate>Sun, 17 Jul 2016 00:43:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/dns/</guid>
      <description>&lt;p&gt;作为半路出发搞web开发的，计算机网络的知识很薄弱，我可不想一辈子写写页面做做增删查改就完了，要提高一下自己的知识水平。光看书也不行，把自己学到的讲出来，这样能够加深理解。&lt;/p&gt;

&lt;p&gt;一般的介绍计算机网络会从OSI模型或者TCP/IP模型开始介绍，虽然目前有个整体的概念但是理解还是不深，所以我想放到最后说。首先要说的应用层的DNS。DNS基本不会被用户手动使用，但是会被其他应用层程序调用，因为DNS的主要作用是将主机名映射到IP地址。为什么需要这么做？因为不同端系统之间的通信需要IP地址来帮助寻找目标主机。&lt;/p&gt;

&lt;p&gt;除了将主机名映射到IP地址这个作用外，DNS还有以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主机别名&lt;/li&gt;
&lt;li&gt;邮件服务器别名&lt;/li&gt;
&lt;li&gt;负载分配。这一点需要说一说，对于一些大站，为了性能优化会部署在多个服务器上。此时一个主机名就会对应多个IP地址。用户请求的时候DNS服务器返回的不是一个IP，而是一组，但是在每次响应时会循环地址次序。在客户端根据返回的IP发起请求的时候通常会先请求排在前面的IP地址，于是便实现了负载分配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整体掌握DNS的功能后，然后我们要看的是DNS查询的过程。&lt;/p&gt;

&lt;p&gt;处于种种原因（大家可以自行想象），DNS采取了分布式、分层次的数据库。DNS服务器大体分为三种类型：根DNS服务器、顶级域DNS服务器、权威DNS服务器。还有一个本地DNS服务器，通常本地DNS服务器是由ISP提供的，相当于是我们DNS查询的一个代理，并且还起到缓存的作用。&lt;/p&gt;

&lt;p&gt;我们要进行DNS查询，首先是查询本地hosts，如果有结果就直接返回IP，这就是为什么本地开发要改hosts。一般的用户是不会配置本地hosts的，不考虑浏览器缓存的话会向本地DNS服务器查询（其实是应用程序如浏览器的缓存优先级更高）。其实也不见得是向本地DNS服务器请求，因为可以设置DNS服务器IP，然而对于一般用户本地DNS服务器地址是接入网的时候就分配好的。通用过程是DNS服务器先向根DNS服务器请求，根DNS服务器会返回顶级域DNS服务器的地址，然后本地DNS服务器据此地址请求顶级域DNS服务器，顶级域DNS服务器返回权威DNS服务器的地址。本地DNS服务器再向权威DNS服务器请求，最终由权威DNS返回查询主机的IP。其实这只是一个简化模型，因为返回的可能不是下一层DNS服务器地址，而是一个中间DNS服务器地址。&lt;/p&gt;

&lt;p&gt;要获得一个主机到IP的映射本地DNS服务器至少要发起三次请求，接受三次回复，如果每次都重复此过程其实是比较昂贵的，所以就有了DNS缓存，通常本地DNS服务器会起到这么一个作用。在查询过程中，会先判断本地缓存有没有相关信息，再进行操作。DNS缓存也会有过期时间的概念，这点不难理解，毕竟互联网是一个动态的网络。&lt;/p&gt;

&lt;p&gt;最终本地DNS服务器向端系统返回IP。换句话说，对于客户端来说，直接发生作用的只有本地DNS服务器，向其他各级DNS服务器请求是本地DNS服务器帮助我们完成的。&lt;/p&gt;

&lt;p&gt;这里还会有 &lt;strong&gt;递归查询&lt;/strong&gt;、&lt;strong&gt;迭代查询&lt;/strong&gt;的概念，理解了上述过程，这两个概念理解起来就没什么难度了。&lt;/p&gt;

&lt;p&gt;DNS协议运行在传输层的UDP协议之上。&lt;/p&gt;

&lt;p&gt;DNS查询基本过程了解了，我们要看一下DNS记录的内容。DNS记录的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Name,Value,Type,TTL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TTL是生存时间，Name和Value的含义决定于Type&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;A&lt;/code&gt;，则Name是主机名，Value是主机名对应IP地址&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;NS&lt;/code&gt;，则Name是域，Value是知道如何获得该域权威DNS服务器的&lt;strong&gt;主机名&lt;/strong&gt;，注意Value是一个主机名，不是IP&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;CNAME&lt;/code&gt;，则Name是别名，Value是规范主机名。这就是为什么DNS会提供别名服务&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;MX&lt;/code&gt;，则Name是邮件服务系统的主机名，Value是别名。这就是为什么DNS会提供邮件服务器别名服务&lt;/p&gt;

&lt;p&gt;至于DNS报文，我目前认为没有太多值得在这里去说的。&lt;/p&gt;

&lt;p&gt;DNS的功能、DNS查询过程、DNS记录和报文相关的内容就说到这里吧。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考资料&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;James F. Kurose， Keith W. Ross. 计算机网络-自顶向下方法（原书第6版）. 机械工业出版社. 2014.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——tab.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/tab/</link>
      <pubDate>Thu, 14 Jul 2016 22:56:40 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/tab/</guid>
      <description>&lt;p&gt;tab切换是网页中的常见设计，从实现上讲也并不复杂，基本思路是导航监听事件，然后把之前显示的tab窗口隐藏掉，然后把导航对应的窗口展示出来，并且更新导航条的状态。bootstrap也对此提供了相应的插件支持，基本思路上都差不太多。先说一下依赖的html结构和css代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
  &amp;lt;!-- Nav tabs --&amp;gt;
  &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;active&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#home&amp;quot; aria-controls=&amp;quot;home&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Home
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#profile&amp;quot; aria-controls=&amp;quot;profile&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
   			 Profile
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#messages&amp;quot; aria-controls=&amp;quot;messages&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Messages
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#settings&amp;quot; aria-controls=&amp;quot;settings&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Settings
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;!-- Tab panes --&amp;gt; 
  &amp;lt;div class=&amp;quot;tab-content&amp;quot;&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane active&amp;quot; id=&amp;quot;home&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;profile&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;messages&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;settings&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体上分为两大块，一部分是导航，一部分是tab窗口，tab窗口的css比较简单，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tab-content &amp;gt; .tab-pane {
  display: none;
}
.tab-content &amp;gt; .active {
  display: block;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说白了只要控制&lt;code&gt;active&lt;/code&gt;类就能控制tab窗口的切换。比较复杂的是导航条的样式，基本款式有两种&lt;code&gt;nav-tabs&lt;/code&gt;和&lt;code&gt;nav-pills&lt;/code&gt;，这两个都可以配合&lt;code&gt;nav-justified&lt;/code&gt;类形成两端对齐的导航。其实这些样式层面的东西对于js代码没什么影响，我就说几个比较好玩的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs &amp;gt; li {
  float: left;
  margin-bottom: -1px;
}
.nav-tabs &amp;gt; li &amp;gt; a {
  margin-right: 2px;
  line-height: 1.42857143;
  border: 1px solid transparent;
  border-radius: 4px 4px 0 0;
}
.nav-tabs &amp;gt; li.active &amp;gt; a,
.nav-tabs &amp;gt; li.active &amp;gt; a:hover,
.nav-tabs &amp;gt; li.active &amp;gt; a:focus {
  color: #555;
  cursor: default;
  background-color: #fff;
  border: 1px solid #ddd;
  border-bottom-color: transparent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tab标签页我觉得是写的比较好的，尤其是对于导航条下面那条线的处理上。每一个标签项都是浮动的，显然会有清除浮动影响，没写在这里。那条线是写在整个导航条上的。那么如何实现 当前标签页没有下面那条线的？首先是利用&lt;code&gt;margin-bottom:-1px&lt;/code&gt;把每个标签项向下移动1px，然后每个标签项都有一个透明的1px边框，这时候标签项的下边框和导航条的下边框正好是重合的，由于颜色是透明的所以可以看得到导航条的边框。对于当前标签页，加了一个白色背景颜色，相当于是用背景色把导航边框色给盖住了。然而，为什么不用边框色盖住呢？非要写一个白色背景色，因为要处理&lt;code&gt;:hover&lt;/code&gt;和&lt;code&gt;:focus&lt;/code&gt;的情况。&lt;/p&gt;

&lt;p&gt;样式的东西就写这些，其实我觉得&lt;code&gt;nav-justified&lt;/code&gt;写得也很好，既实现了所有标签项占据100%空间，又能兼顾标签项内容的长度分配剩余空间，&lt;a href=&#34;http://stackoverflow.com/a/27846774&#34;&gt;stackoverflow上面有评论&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;说js部分了，利用data形式绑定事件以前已经说过了，然而我怀疑有没有必要整出&lt;code&gt;[data-toggle=&amp;quot;tab&amp;quot;]&lt;/code&gt;和&lt;code&gt;[data-toggle=&amp;quot;pill&amp;quot;]&lt;/code&gt;两个来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data(&#39;bs.tab&#39;)

	  if (!data) $this.data(&#39;bs.tab&#39;, (data = new Tab(this)))
	  if (typeof option == &#39;string&#39;) data[option]()
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和以往一样是把生成的对象挂到了data上，然后根据传入的参数做一些操作。在&lt;code&gt;Tab&lt;/code&gt;的原型上主要挂了两个方法&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;activate&lt;/code&gt; , &lt;code&gt;show&lt;/code&gt;方法主要的功能是判断要不要进行tab切换，切换的对象是谁。具体的切换是&lt;code&gt;activate&lt;/code&gt;方法实现的，这个方法相当于是对切换这个操作剥离出来，导航条标签的切换、tab窗口的切换都通过这个方法实现，这两个切换没有耦合在一起，这一点很不错。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;show&lt;/code&gt;方法里确定要展示的tab窗口是通过tab标签的&lt;code&gt;data-target&lt;/code&gt;或者&lt;code&gt;href&lt;/code&gt;实现的，弱弱的说一句，在bootstrap的插件里，有的是&lt;code&gt;href&lt;/code&gt;优先，有的是&lt;code&gt;data-target&lt;/code&gt;优先，不过正常人是不会两个都加上的。在&lt;code&gt;show&lt;/code&gt;方法里还触发了一些事件，相较于之前看过的几个插件，这里的事件复杂在有&lt;code&gt;relatedTarget&lt;/code&gt;的概念。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;activate&lt;/code&gt;方法中，首先获取当前活动的元素，然后判断是否要过渡。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var transition = callback
  &amp;amp;&amp;amp; $.support.transition
  &amp;amp;&amp;amp; ($active.length &amp;amp;&amp;amp; $active.hasClass(&#39;fade&#39;) || !!container.find(&#39;&amp;gt; .fade&#39;).length)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而我不太明白的是为啥一定要有callback才支持过渡。然后就是判断是否要过渡，如果要过渡的首先把当前展示的页面过渡、逐渐淡出，淡出完成后当前的移除&lt;code&gt;active&lt;/code&gt;类，target元素添加&lt;code&gt;active&lt;/code&gt;类，如果target元素需要过渡出来的话，还要先强制重绘一次，再添加&lt;code&gt;in&lt;/code&gt;这个类，否则会直接进入最终状态。如果不需要过渡直接从移除&lt;code&gt;active&lt;/code&gt;类开始执行。&lt;/p&gt;

&lt;p&gt;说实话，bootstrap的插件长的差不多，一开始觉得写法很独特，后来就习惯了，熟悉了写法之后其实插件的业务逻辑很好懂。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C#的基本语法</title>
      <link>http://jiangshanmeta.github.io/post/blog/csharp/</link>
      <pubDate>Wed, 13 Jul 2016 00:16:02 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/csharp/</guid>
      <description>

&lt;p&gt;今天老板问我，想学C#吗？于是我就念了两句诗：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;苟利国家生死以,岂因祸福避趋之&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;想想一个语言基本语法其实没多少，无非就是&lt;/p&gt;

&lt;h2 id=&#34;变量-常量-关键字-运算符-数组:daae90d06331bc886739d748003841f1&#34;&gt;变量、常量、关键字、运算符、数组&lt;/h2&gt;

&lt;h2 id=&#34;条件语句:daae90d06331bc886739d748003841f1&#34;&gt;条件语句&lt;/h2&gt;

&lt;h2 id=&#34;循环语句:daae90d06331bc886739d748003841f1&#34;&gt;循环语句&lt;/h2&gt;

&lt;p&gt;和我常用的javascript和php没什么太大区别，只是感觉有点像当年学的谭浩强的C。&lt;/p&gt;

&lt;p&gt;又想起来，被谭浩强支配的恐怖。&lt;/p&gt;

&lt;p&gt;为什么数组的长度是固定。。。。为什么数组内部元素要是一个类型。。。&lt;/p&gt;

&lt;p&gt;没有代码，因为真的不需要代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>本地存储的一些比较</title>
      <link>http://jiangshanmeta.github.io/post/blog/storage/</link>
      <pubDate>Sat, 09 Jul 2016 23:45:02 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/storage/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/blog/ebussiness/&#34;&gt;最近的项目中使用了localStorage实现了本地购物车&lt;/a&gt;，借着这个机会总结一下各种本地存储。还有，发现以往过于关注API层面的东西了，反而对API是为了解决什么忽视了。&lt;/p&gt;

&lt;h2 id=&#34;cookie:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;cookie&lt;/h2&gt;

&lt;p&gt;cookie应该是最早的本地存储，本来今天不想谈API的东西，但是cookie的api设计的简直反人类。&lt;/p&gt;

&lt;p&gt;cookie的一个很重要的应用是用来判断用户是谁（登录功能）。因为http是无状态协议，无法根据之前的状态进行本次的请求处理。在登录成功后后端返回的报文中会设定包含用户登录信息的cookie，以后请求的时候会在请求头信息中包含cookie。&lt;/p&gt;

&lt;p&gt;cookie在每次http请求中都是默认自带的，这点有好处也有坏处。好处是不用手动把cookie信息写入报文，并且一般后端语言也会默认支持对cookie的读取，比如php的&lt;code&gt;$_COOKIE&lt;/code&gt;，坏处是不管用不用得到都会一股脑传过去，虽然对于现在的网络环境而言这并不是什么太大的问题。cookie还有一个缺点是大小限制为4k，复杂点的web应用应该就不够用了。&lt;/p&gt;

&lt;p&gt;最近在看http相关的东西，发现还有个&lt;code&gt;httponly&lt;/code&gt;属性，我觉得挺好的，以前是以一个纯前端的角度去看cookie，因为js无法控制&lt;code&gt;httponly&lt;/code&gt;的cookie，所以没见过有人提。这个属性很好的提升了cookie的安全性。&lt;/p&gt;

&lt;h2 id=&#34;localstorage:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;localStorage&lt;/h2&gt;

&lt;p&gt;最近的项目中是要做一个购物车，因而使用了localStorage，相比较于cookie，它的存储空间更大，并且没有过期时间的概念，也就是说除非手动删除它会一直保存。&lt;/p&gt;

&lt;p&gt;和cookie还有一点不同就是需要自己手动向后端提交localStorage的内容，服务器端无法直接访问localStorage。确实可以减少网络传输。。毕竟设计的最大存储比cookie大多了，要是和cookie似的自动写到报文里每次请求估计最大的内容就是localStorage了吧。&lt;/p&gt;

&lt;p&gt;对于我的购物车功能，我觉得写得最折腾的就是同步本地数据和线上数据，每一次增删查改之后都要拿一份线上数据处理后然后返回给前端，前端再更新页面和更新localStorage。&lt;/p&gt;

&lt;h2 id=&#34;sessionstorage:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;sessionStorage&lt;/h2&gt;

&lt;p&gt;这是为了会话控制而存在的，看起来和localStorage很像但是生命周期短得多，如果关了网页重开就没了，开一个新的tab也不会有当前的sessionStorage。&lt;/p&gt;

&lt;h2 id=&#34;indexeddb:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;indexedDB&lt;/h2&gt;

&lt;p&gt;？？这货出现是为了解决啥？没想明白，难道是出来自high的？？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——collapse.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/collapse/</link>
      <pubDate>Fri, 08 Jul 2016 20:33:24 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/collapse/</guid>
      <description>&lt;p&gt;最近工作忙，好不容易闲下来身体又出bug了，好久没更新了。接着读bootstrap的代码，今天要说的是collapse.js。这个插件实现的展开与收缩效果。&lt;/p&gt;

&lt;p&gt;先看一下data-api&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).on(&#39;click.bs.collapse.data-api&#39;, &#39;[data-toggle=&amp;quot;collapse&amp;quot;]&#39;, function (e) {
	var $this   = $(this)

	if (!$this.attr(&#39;data-target&#39;)) e.preventDefault()

	var $target = getTargetFromTrigger($this)
	var data    = $target.data(&#39;bs.collapse&#39;)
	var option  = data ? &#39;toggle&#39; : $this.data()

	Plugin.call($target, option)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体绑定的方式和之前分析的alert、button差不多，都是利用事件委托机制。具体的回调函数比较复杂了。collapse.js设定了两种绑定展开收缩对象的形式，一种是通过a标签的&lt;code&gt;href&lt;/code&gt;属性，另一种是通过&lt;code&gt;data-target&lt;/code&gt;属性，并且还封装了一个小函数&lt;code&gt;getTargetFromTrigger&lt;/code&gt;找到对应的绑定元素。如果是通过&lt;code&gt;href&lt;/code&gt;属性指定展开收缩对象的话，需要阻止默认事件，至于阻止的是啥，还用我说嘛。然后的三行就写的比较巧妙了，先获取data上面保存的信息，然后如果之前保存过collapse的实例，给*option*赋值为&amp;rsquo;toggle&amp;rsquo;,如果没有，赋值为一个对象。为什么要返回一个data的对象？一开始我也没想明白，看到插件的具体内容才想明白为什么要加这个，因为这个插件还负责实现手风琴效果，手风琴效果总归需要一个包裹元素吧，这里的实现是通过&lt;code&gt;data-parent&lt;/code&gt;来决定这个包裹元素是谁。如果是最简单的展开收缩效果，option里面的只会有toggle，对于手风琴效果会对一个parent，针对这个parent有一些额外的操作。&lt;/p&gt;

&lt;p&gt;然后是Plugin的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data(&#39;bs.collapse&#39;)
	  var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == &#39;object&#39; &amp;amp;&amp;amp; option)

	  if (!data &amp;amp;&amp;amp; options.toggle &amp;amp;&amp;amp; /show|hide/.test(option)) options.toggle = false
	  if (!data) $this.data(&#39;bs.collapse&#39;, (data = new Collapse(this, options)))
	  if (typeof option == &#39;string&#39;) data[option]()
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bootstrap的插件基本上是按照一个模板出来的。在bootstrap插件里第一次见到使用&lt;code&gt;$.extend&lt;/code&gt;方法，使用过jquery的人应该了解这是合并对象用的，原生js的一个实现是&lt;code&gt;Object.assign&lt;/code&gt;，只是有点兼容问题。而且这里重新利用了&lt;strong&gt;toggle&lt;/strong&gt;属性，通过判断是否需要调用toggle方法，看Collapse构造函数就会明白这样会保证如果传入的不是&lt;code&gt;show&lt;/code&gt;或者&lt;code&gt;hide&lt;/code&gt;这两个字符串，就会&lt;strong&gt;toggle&lt;/strong&gt;一次。如果传入的是字符串，会调用相关方法。&lt;/p&gt;

&lt;p&gt;上面说的是写法上的巧妙之处，然而重点是这个展开收缩是如何实现的，在文档上有这么一句&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Collapse requires the transitions plugin to be included in your version of Bootstrap.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是说展开收缩效果是通过CSS3过渡实现的，我曾经想过如果用纯CSS实现这种展开收缩效果，但是由于&lt;code&gt;height&lt;/code&gt;无法从&lt;code&gt;auto&lt;/code&gt;过渡到一个具体数字，所以只能用有点hack意味的方案，我最终采用的是过渡&lt;code&gt;transform&lt;/code&gt;的&lt;code&gt;scale&lt;/code&gt;，这样有个问题的别的元素会认为这个元素依然是占据原来的大小。bootstrap的解决方案利用了js。&lt;/p&gt;

&lt;p&gt;当调用&lt;code&gt;show&lt;/code&gt;方法的时候，先做一些隔离，保证此时操作的元素处于hide状态。这时收缩状态的元素含有一个类&lt;code&gt;collapse&lt;/code&gt;，对应内容是&lt;code&gt;display:none&lt;/code&gt;，然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.$element
  .removeClass(&#39;collapse&#39;)
  .addClass(&#39;collapsing&#39;)[dimension](0)
  .attr(&#39;aria-expanded&#39;, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除&lt;code&gt;collapse&lt;/code&gt;这个类，这时候元素理应正常显示，这里强行设定高度为0，等一下我再吐槽这个&lt;code&gt;dimension&lt;/code&gt;，顺便吐槽&lt;code&gt;collapsing&lt;/code&gt;这个类。现在这个需要展开的元素高度为0，我们需要确定最终高度，bootstrap的实现我觉得挺巧的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scrollSize = $.camelCase([&#39;scroll&#39;, dimension].join(&#39;-&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是利用scrollHeight来确定最终高度的，初始高度、最终高度有了，过渡的最基本的条件就有了。过渡完成后的回调其实也比较有意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var complete = function () {
  this.$element
    .removeClass(&#39;collapsing&#39;)
    .addClass(&#39;collapse in&#39;)[dimension](&#39;&#39;)
  this.transitioning = 0
  this.$element
    .trigger(&#39;shown.bs.collapse&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除了&lt;code&gt;collapsing&lt;/code&gt;这个类，添加&lt;code&gt;collapse&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;两个类，并且把高度设置为默认值。为什么要这么做？因为以后这个展开收缩区域可能会动态添加或者删除内容，此时写死高度就有些不合适了。&lt;/p&gt;

&lt;p&gt;对应的&lt;code&gt;hide&lt;/code&gt;方法基本过程类似，其实只要看明白一个另一个也就差不多了。说一下要说的几点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.$element[dimension](this.$element[dimension]())[0].offsetHeight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前说过，无法实现、&lt;strong&gt;height&lt;/strong&gt;的从&lt;strong&gt;auto&lt;/strong&gt;到一个数值的过渡，我们需要获取元素的具体高度，这里还强行重绘了一次，保证把高度值从auto转换为具体的数值，之前&lt;code&gt;show&lt;/code&gt;方法里其实也强行重绘了一次，是在利用&lt;code&gt;scrollHeight&lt;/code&gt;获得高度的时候。其他的基本上就是&lt;code&gt;show&lt;/code&gt;方法的逆过程了。&lt;/p&gt;

&lt;p&gt;下面开始预告的吐槽&lt;/p&gt;

&lt;p&gt;在上面的解说中，我是直接把&lt;code&gt;dimension&lt;/code&gt;说成是&lt;code&gt;height&lt;/code&gt;，我们还是看代码把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collapse.prototype.dimension = function () {
	var hasWidth = this.$element.hasClass(&#39;width&#39;)
	return hasWidth ? &#39;width&#39; : &#39;height&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dimension就是上面几行代码的返回值，水平方向的展开收缩虽然不多见，但也总归是有，但是呢，你看你的控制过渡的类&lt;code&gt;collapsing&lt;/code&gt;的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  -webkit-transition-timing-function: ease;
       -o-transition-timing-function: ease;
          transition-timing-function: ease;
  -webkit-transition-duration: .35s;
       -o-transition-duration: .35s;
          transition-duration: .35s;
  -webkit-transition-property: height, visibility;
       -o-transition-property: height, visibility;
          transition-property: height, visibility;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你们写js的和写css的看来不是一个人啊，根本没实现对于宽度过渡的支持啊，你们。。。。&lt;/p&gt;

&lt;p&gt;这其实都是小事，我觉得一个让我很迷惑的问题是为啥&lt;code&gt;visibility&lt;/code&gt;这个属性也能过渡？于是&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2013/05/transition-visibility-show-hide/&#34;&gt;张鑫旭大神又解释过这个问题了&lt;/a&gt;。其中张鑫旭前辈提到了应用场景&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;举个例子，我们要实现淡入淡出效果，显然是需要改变透明度的，但是，元素即使透明度变成0，虽然肉眼看不见，但是，在页面上，元素还是可以点击，还是可以覆盖其他元素的，这显然是有问题的，我们最最希望的是在元素淡出动画结束后，元素可以自动隐藏！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人觉得他对&lt;code&gt;opacity:0;&lt;/code&gt;和&lt;code&gt;visibility:hidden&lt;/code&gt;的区别没有说清楚。这时候就要搬出&lt;a href=&#34;http://stackoverflow.com/a/273076&#34;&gt;stackoverflow上的回答&lt;/a&gt;。这两个都是不脱离文档流，但是前者依然响应事件，而后者不响应事件。不过回到这个插件里来，并没有用到&lt;code&gt;visibility&lt;/code&gt;的过渡。&lt;/p&gt;

&lt;p&gt;主体内容差不多就完了，关于手风琴效果的具体实现，以及其他的细节自己去看源码吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一个电商网站的基本实现</title>
      <link>http://jiangshanmeta.github.io/post/blog/ebussiness/</link>
      <pubDate>Tue, 05 Jul 2016 20:05:02 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/ebussiness/</guid>
      <description>&lt;p&gt;最近在做的是一个简易的购物系统，因为并不是主营业务，所以并不像电商网站那样复杂，否则就我一个人做这件事情会崩溃的。虽然只是一个简易版的电商，但是各项功能还是有的。有商品的展示列表，商品的详情展示，购物车功能，订单功能，金流管理。其中支付功能和金流我要处理的并不多，只是在以往基础上添加几个参数写几个if else。其他的就要一个一个慢慢写。&lt;/p&gt;

&lt;p&gt;第一个要实现的是商品的本身。&lt;/p&gt;

&lt;p&gt;关于这些商品，一开始我们是线上部分只做纯展示使用，线下负责具体的业务，所以这个商品表的结构并不困难，一个名称，一段描述，一张图，一个价格范围，这些都是很简单的东西，比较复杂的是商品的分类，于是我们又建了一个商品分类表，商品表里保存着商品分类表里的一个id。这个商品分类表其实不复杂，一个名称，再加上一个enum的基础分类即可，其余字段都是小的辅助。有了商品做商品列表和商品详情页就没什么难的了，就是个纯展示的工作。因为种类本身就不多，连搜索都没加。第一阶段的工作就这样结束了，也没有后面这个小型电商网站什么事。&lt;/p&gt;

&lt;p&gt;后来，后来就开始做了呗。首先要做的是补充商品信息。原来只有一个简单的商品描述，但是型号、颜色之类的都没有去添加。针对这个问题，本来是想和淘宝似的做个正交的分类。然后老板直接说就做一级分类。这数据上的复杂度就直接下来了。一个商品对应多个型号，每个型号有自己的价格，与淘宝不同的是，我们线下有多家实体店，所以每个型号需要对应多个库存。一般来说这种多型号的应该建张商品型号表然后关联起来，然而本来为了偷懒我就建了个array然后多个型号都扔到这个这个array里。最终的后台编辑这个型号是用vue做的。深深感觉我在这里留了的坑。希望后人重构的时候能够淡定。其实还有个坑，是我在数据库的最终保存形式是json而不是一个array。我已经遇到一个坑了。自己挖的坑，含着泪也要踩下去。&lt;/p&gt;

&lt;p&gt;商品的必要信息有了，然后是购物车的实现。&lt;/p&gt;

&lt;p&gt;作为一个穷的只逛淘宝的人，其他的电商网站我还真的不熟悉。淘宝最近实在推app，对于购物车功能要求登录。然而传统的电商是不要求登陆的。于是我们需要本地存储。我们使用的本地存储方案是localStorage。之所以采用这个方案一个很重要的方案是因为同事也在用它做本地存储，当然，从纯技术角度来看localStorage比cookie好用，而且作为移动端项目也不用太过于担心兼容性问题。&lt;/p&gt;

&lt;p&gt;然后是购物车的数据结构。一开始有两个大的方向，一个是在用户本身建一个购物车字段存具体信息，因为我们使用的是mongoDB数据库，可以存一个array，另一个方案是拆一张表出来。于是我就问头其他电商的思路，头说考虑性能还是建张表吧。表的结构不复杂，用户的id，用户基本信息的快照，商品的id，商品型号，商品基本信息快照，商品数量，加入时间。最后一个我是见有的电商购物车保存多少天然后就删掉而预留的字段，目前并没有用到。用户每次想购物车加入商品，就会插入一条记录。&lt;/p&gt;

&lt;p&gt;数据结构约定好了就要实现同步了。其实我的做法是比较投机取巧的，如果是非登录态，添加商品的时候只会快照一些基本信息存到localStorage里，但是如果是在登录态，向购物里添加东西是需要ajax请求的，后端插入数据后返回的数据包含这个购物车记录的id，我就利用有没有这个id判断数据库是否已插入这条数据。遍历post过来的本地数据，如果没购物车id就直接插入一条新的记录，如果有这个id就update一下（可能会修改数量，本身我只支持修改数量，并不支持修改型号），一些安全校验就不说了。但是上面的实现有个问题，一开始我也没有想到，就是一条购物车记录线上有数据，但是用户在非登录态删除了，同步的时候上面的方法并无法识别。我的解决方案是 在处理post过来的数据之前先拿到此时线上购物车的ids 存成一个array（这个时间点很重要），然后处理post过来的数据，把post过来的数据库id也存成一个array，两者比较如果线上有post过来的没有，就说明本地删了数据，要把线上数据也删除。&lt;/p&gt;

&lt;p&gt;其他的就是些增删查改之类的工作了，没什么太大的难度，就是注意同步数据这个问题，顺便感谢vue。&lt;/p&gt;

&lt;p&gt;购物车实现完成之后就是从购物车到订单了。&lt;/p&gt;

&lt;p&gt;从购物车到订单这一步牵扯到的表比较多。购物车表、商品表、订单表，还有一个子订单表。购物车表就不用说了，商品表是因为要查一遍最新的商品信息，拿到最新的价格等信息，用户选中的购物车中的每一条记录都会转化成子订单中的一条记录，同时在订单表中更新。订单表除了子订单这一个字段外，还有一些用户的基本信息，状态、各种时间戳。&lt;/p&gt;

&lt;p&gt;从购物车生成订单后，还需要用户确认。因为业务的需要，有些商品虽然是线上卖，但是要到线下实体店处理（我不会告诉你处理这个写了不少代码），还有有的商品可以邮寄，就有了满多少钱包邮的问题。所以需要用户确认取货方式、去哪家店处理、最终支付金额。在这里用户可以选择删除部分子订单，或者把一些订单里的商品重新放回购物车，或者把订单彻底取消。前两个处理的时候需要考虑订单中商品价格的重新计算、顺带着还有是否达到包邮价格。&lt;/p&gt;

&lt;p&gt;后来同事吐槽我说你见过哪个电商有放回购物车这个功能的？于是我就念了两句诗。不要在乎这些细节，反正我实现了。&lt;/p&gt;

&lt;p&gt;用户确认订单后后进入支付环节。此时，用户依然可以取消订单。支付是用的同事封装好的代码，虽然我也改了几行，毕竟同事写的代码考虑的都是主营业务订单，我们这个小电商系统实际是自己写着玩的。在支付成功的回调函数中，我更新了订单的状态，写入了金流信息。&lt;/p&gt;

&lt;p&gt;现在用户已付款，剩下的就是门店获取订单信息，准备货，就是一些基本的增删查改。&lt;/p&gt;

&lt;p&gt;这个小电商基本上是实现了，但是我的主要工作是实现功能，也就是把js和php写完，换句话说就是样式完全没理，根本没法看。看看是让美术设计一套还是抄一套别的电商的样式。&lt;/p&gt;

&lt;p&gt;基本就这样。写了差不多一个星期，完活，撒花。&lt;/p&gt;

&lt;p&gt;然后就遇到坑了。在商品分类那里，原来是要考虑多家门店多个库存的，后来老板说这样维护起来压力过大，让我在商品分类那里存一个配件id，把这个当成一个配件，然后在库存表里查库存信息。其实写起来并没有什么问题，多查一次表而已。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>图文混排布局的一个小tip</title>
      <link>http://jiangshanmeta.github.io/post/tabletip/</link>
      <pubDate>Tue, 28 Jun 2016 23:14:10 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/tabletip/</guid>
      <description>&lt;p&gt;如果想实现一个左图右文布局，可以使用浮动，这是很普遍的一点。但是如果如果右侧文字很少，会显得右侧很空，这时候我们会希望一些文字能够拿到下面来，差不多和图片齐平，显然浮动无法实现，一个很直接的想法是需要等高布局。等高布局比较靠谱的解决方案是利用&lt;a href=&#34;http://jiangshanmeta.github.io/post/table/&#34;&gt;css table&lt;/a&gt;，利用同一行中单元格等高这一特性来实现。但是说实话table真的很难驯服，再加上图文混排出幺蛾子的概率很高。如果按照默认样式的可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/table/tabletip.png&#34; alt=&#34;乱的布局&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要实现上面的结果其实还做过一些处理，因为图可能很大，但是我只希望图片区占有一定比例，其他的所以采用&lt;code&gt;table-layout:fixed&lt;/code&gt;属性加上百分比的宽度，具体的分析上面那个连接给出了说明。&lt;/p&gt;

&lt;p&gt;为什么文字会这么靠下呢，因为&lt;code&gt;vertical-align&lt;/code&gt;属性默认值为&lt;code&gt;baseline&lt;/code&gt;,把右侧文字区的&lt;code&gt;vertical-align&lt;/code&gt;设为&lt;code&gt;top&lt;/code&gt;就好了。然后想放在下面的文字就绝对定位就好了，别忘了给右侧文字区域加上&lt;code&gt;position:ralative&lt;/code&gt;，基本常识了。&lt;/p&gt;

&lt;p&gt;这样基本上差不多了，可以上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;了。&lt;/p&gt;

&lt;p&gt;稍微精益求精的可以发现左侧图片区的高度比图片高度大那么一点，换句话说就是图片下面还有一定空间，这一因为行高，可行的解决方案有如下几个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图片设置为&lt;code&gt;display:block;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片区行高设置&lt;code&gt;line-height:0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片&lt;code&gt;vertical-align&lt;/code&gt;设置为&lt;code&gt;top&lt;/code&gt; || &lt;code&gt;bottom&lt;/code&gt; || &lt;code&gt;middle&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是第二天就用到相关知识了。老板想做类似的东西，左侧依然是图片区，中间是文字区，右侧是一个垂直居中的箭头。这个设计确实挺常见的。然后我就把上面的实现说了一下，然后最右侧加了一个&lt;code&gt;vertical-align:middle&lt;/code&gt;,我实现的demo和上面的demo放在一个页面里了。老板听完我的实现后就默默地决定最右边的那个箭头放背景图里然后默默切图去了。嘤嘤嘤。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>table那些事</title>
      <link>http://jiangshanmeta.github.io/post/table/</link>
      <pubDate>Mon, 27 Jun 2016 21:09:14 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/table/</guid>
      <description>

&lt;p&gt;最近我的知乎时间线上出现了这么一个问题:&lt;a href=&#34;https://www.zhihu.com/question/20003535&#34;&gt;网页的 Table 布局和 DIV+CSS 布局从哪里可以看出来？Table 布局已经过时了吗？&lt;/a&gt;，于是便想着总结一下关于table的一些知识点。先声明一下，这里table是指css table，而不是html table，以下所说的可能用html的形式来写，但都是指的css table。&lt;/p&gt;

&lt;h2 id=&#34;基本概念:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;基本概念&lt;/h2&gt;

&lt;h4 id=&#34;关于表格的display值:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于表格的display值&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;table                对应html中的&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row            对应html中的&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-cell           对应htnl中的&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row-group      对应html中的&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-header-group   对应html中的&lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-footer-group   对应html中的&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-caption        对应html中的&lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column         对应html中的&lt;code&gt;&amp;lt;col&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column-group   对应html中的&lt;code&gt;&amp;lt;colgroup&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最重要的是前三个属性，而最后两个可以认为没什么用处，因为css将其表模型定义为以行为主，也就是说，它认为web开发者会显式声明行，而列是从单元格行的布局推导出来的。&lt;/p&gt;

&lt;h4 id=&#34;匿名表对象:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;匿名表对象&lt;/h4&gt;

&lt;p&gt;在html的table，有一些嵌套标签即使你不去写，浏览器也会去帮你填充，css的table也有类似的现象，可以将“遗漏的”组件作为匿名对象插入。插入遵循以下规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一个table-cell元素的父元素不是table-row元素，则会在该table-cell元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素的所有连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的父元素不是table、table-row-group元素，则会在该table-row元素及其父元素之间插入一个匿名table元素。插入的这个对象将包含该table-row元素的连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-column元素的父元素不是table、table-column-group元素，则在该table-column元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在该table元素及其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素及所有不是table-row-group、table-header-group、table-footer-group、table-row、table-caption元素的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row对象，则在该元素及其子元素之间插入一个匿名table-row对象。这个匿名对象包含该子元素及其所有非table-row对象的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象。这个匿名对象包含该子元素及其所有非table-cell元素的连续兄弟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看起来比较理论，大家自己读读就好。&lt;/p&gt;

&lt;h4 id=&#34;固定布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;固定布局&lt;/h4&gt;

&lt;p&gt;熟悉css属性的人对于&lt;code&gt;table-layout&lt;/code&gt;应该不陌生，这个属性很大程度上影响了table的布局。首先介绍的固定布局，对应的属性值是&lt;code&gt;fixed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要实现固定布局，首先要设定&lt;code&gt;table-layout&lt;/code&gt;为&lt;code&gt;fixed&lt;/code&gt;,这是显然的，但是也是不足的，除此之外还要设定table的宽度，否则会按照自动布局进行。&lt;/p&gt;

&lt;p&gt;具体实现上包括以下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;width属性不是auto的列元素会根据width值设置该列的宽度。&lt;/li&gt;
&lt;li&gt;如果一个列的宽度为auto，但是表首行中该列的单元格width不为auto，则根据单元格宽度设置此列宽度。其它行设定的宽度无效。&lt;/li&gt;
&lt;li&gt;经过前两步，如果列的宽度依然为auto，会自动确定其大小，使其宽度尽可能相等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;固定布局速度比较快，因为布局不依赖与内容，而是根据表的宽度、列和单元格的width决定。&lt;/p&gt;

&lt;p&gt;上面提到的第三点是table实现等分布局的基础。&lt;/p&gt;

&lt;h4 id=&#34;自动布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;自动布局&lt;/h4&gt;

&lt;p&gt;自动布局是table的默认布局，但是因为要根据内容决定布局，所以布局速度较慢。&lt;/p&gt;

&lt;p&gt;对于自动布局，具体宽度的计算比较复杂，而且对于中英文分割也比较复杂。所以这里就简要介绍一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于一列的各个单元格，计算最小和最大单元格宽度。&lt;/li&gt;
&lt;li&gt;对于各列，计算最小和最大列宽&lt;/li&gt;
&lt;li&gt;计算出表的真正宽度和各列宽度。如果表的&lt;code&gt;width&lt;/code&gt;属性不是auto，则将width属性值与所有列宽之和比较，取较大的作为表的宽度。如果最终宽度大于各列宽度之和，多余宽度各列均分。如果表的&lt;code&gt;width&lt;/code&gt;属性为auto，则将各列宽度之和作为表的宽度。换句话说，表的宽度恰好足够显示其内容，这一点是&lt;strong&gt;不定宽元素水平居中&lt;/strong&gt;的基础。然而，在&lt;code&gt;width&lt;/code&gt;为&lt;code&gt;auto&lt;/code&gt;的情况下，一个表可能会很难看，尤其是中文，有的时候可能发现每一列宽度都很小甚至只能写下一个字然后整个文字就竖起来了。目测bootstrap也是因为这个所以给table一个&lt;code&gt;width:100%&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;关于height:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于height&lt;/h4&gt;

&lt;p&gt;对于web开发者来说，一般很少显式声明一个元素的高度，但是对于table来说，就有点有趣了&lt;/p&gt;

&lt;p&gt;先约定一下页面结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;display:table;height:600px;&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果行高度不限制，三行内容一致，你会发现三行等分了整个表的高度，共同占据了600px的高度，这一点和常规div表现不一致。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果高度不限制，三行内容不一致，那么三行均分剩余高度。看起来上面说的内容一致的是这里的特殊情况。你不觉得和&lt;code&gt;flex&lt;/code&gt;有点像吗，&lt;code&gt;flex-grow&lt;/code&gt;属性就可以分配剩余空间，不过能设置分配系数，比这里强大点。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;//于是，我无意间实现了简单模拟&lt;code&gt;flex-grow&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;如果高度限制了比例，你会发现这里的比例只是参考比例，如果足够放得下，那么就按照这个比例，如果不够放，那么会调整比例使其恰能放开。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（依然和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上面的情况延伸一下，如果有一个行高度设为了100%，其它行高度会调整为恰好够填充，而这一行会填充满剩余空间。之前提到过这一点可以用来实现sticky footer，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;table的用处:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;table的用处&lt;/h2&gt;

&lt;h4 id=&#34;不定宽元素水平居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;不定宽元素水平居中&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-table{
  display:table;
  margin-left:auto;
  margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面有说，是自动布局&lt;code&gt;width&lt;/code&gt;属性为&lt;code&gt;auto&lt;/code&gt;时&lt;code&gt;display:table&lt;/code&gt;的元素宽度为内容宽度&lt;/p&gt;

&lt;h4 id=&#34;垂直居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;垂直居中&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&#34;http://jiangshanmeta.github.io/post/center/&#34;&gt;我的总结&amp;ndash;居中的实现&lt;/a&gt;中提到到过，利用的是&lt;code&gt;vertical-align:middle&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;等分布局-多列布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等分布局/多列布局&lt;/h4&gt;

&lt;p&gt;这两类基本布局我更习惯用浮动实现，对于&lt;code&gt;table&lt;/code&gt;实现没有什么特别大的爱好，等分布局需要&lt;code&gt;table-layout:fixed;&lt;/code&gt;这一属性。&lt;/p&gt;

&lt;h4 id=&#34;等高布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等高布局&lt;/h4&gt;

&lt;p&gt;如果不用table，实现等高布局的最简单方式应该是&lt;code&gt;flex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还是直接上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;吧，我这里实现了图文混排下的等高。&lt;/p&gt;

&lt;h4 id=&#34;sticky-footer:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;sticky footer&lt;/h4&gt;

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/stickyfooter/&#34;&gt;总结过sticky footer的实现&lt;/a&gt;,以及&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——button.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/button/</link>
      <pubDate>Sun, 26 Jun 2016 20:22:23 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/button/</guid>
      <description>&lt;p&gt;button.js我个人觉得是属于从一开始就没想明白要做什么。和其他的bootstrap的插件一样，button也能用data的形式调用插件，但是我真心没想明白使用data调用的有什么实际用途。反而我觉得手动调用的对我来说更有实际意义，所以这里只说&lt;a href=&#34;http://v3.bootcss.com/javascript/#buttons-stateful&#34;&gt;button.js改变状态的部分&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在web应用中免不了用户触发ajax请求，比如提交表单（实际项目中没有用表单的直接提交，而是使用了ajax提交表单），点击加载更多。在ajax过程中我们需要告诉用户正在进行中，需要等待。在实际项目中为了实现这一个需求我们使用了一个插件blockUI,可以自行百度一下，我觉得挺好用的。另一种方案是改变button的状态，把他标记为不可点击。&lt;/p&gt;

&lt;p&gt;整体形式是标准的bootstrap插件的形式，关于如何绑定方法，如何防冲突，这些都在 &lt;a href=&#34;http://jiangshanmeta.github.io/post/bootstrap/alert/&#34;&gt;bootstrap源码解读——alert.js&lt;/a&gt;中分析过了，没有必要去做过多的说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.button&#39;)
    var options = typeof option == &#39;object&#39; &amp;amp;&amp;amp; option

    if (!data) $this.data(&#39;bs.button&#39;, (data = new Button(this, options)))

    if (option == &#39;toggle&#39;) data.toggle()
    else if (option) data.setState(option)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和alert.js类似，这里也是采用data的形式进行缓存&lt;code&gt;Button&lt;/code&gt;实例，我们不需要去关心&lt;code&gt;toggle&lt;/code&gt;的实现，因为我连应用场景都没想到，我们只需关心调用&lt;code&gt;setState&lt;/code&gt;方法。setState传入的参数其实只有&lt;code&gt;loading&lt;/code&gt;和&lt;code&gt;reset&lt;/code&gt;是有效的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Button.prototype.setState = function (state) {
  var d    = &#39;disabled&#39;
  var $el  = this.$element
  var val  = $el.is(&#39;input&#39;) ? &#39;val&#39; : &#39;html&#39;
  var data = $el.data()

  state += &#39;Text&#39;

  if (data.resetText == null) $el.data(&#39;resetText&#39;, $el[val]())

  // push to event loop to allow forms to submit
  setTimeout($.proxy(function () {
    $el[val](data[state] == null ? this.options[state] : data[state])

    if (state == &#39;loadingText&#39;) {
      this.isLoading = true
      $el.addClass(d).attr(d, d)
    } else if (this.isLoading) {
      this.isLoading = false
      $el.removeClass(d).removeAttr(d)
    }
  }, this), 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读起来并不是很难懂，一个要注意的地方是&lt;code&gt;setTimeout&lt;/code&gt;，这个函数一方面会改变&lt;code&gt;this&lt;/code&gt;的指向，我以前也分析过&lt;a href=&#34;http://jiangshanmeta.github.io/post/jsthis/&#34;&gt;javascript的this坑&lt;/a&gt;，另一方面是定时器的原理，不是相隔多长时间后执行，而是相隔多长时间后加入任务队列，这个&lt;a href=&#34;http://jiangshanmeta.github.io/post/browser/&#34;&gt;我以前也提及过&lt;/a&gt;。另一个要注意的点是data的使用，利用data保存button中原来的内容就不说了，很常规的一个写法。比较有趣的是对于加载时显示内容的处理。文档上说加载时保存的信息保存在了&lt;code&gt;data-loading-text&lt;/code&gt;中，但是我们在代码中读取的时候是以&lt;code&gt;loadingText&lt;/code&gt;的形式读写，这就比较有意思了，一个中划线没了，然后一个大小写改变了。查了查MDN找到了答案：&lt;/p&gt;

&lt;p&gt;data-*,*可以被任何符合以下限制的the producton rule of xml names(xml的命名规则)代替：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;名字不能以xml开头，除此之外其他任何情形都可是使用这3个字母；&lt;/li&gt;
&lt;li&gt;名字不能含有分号；&lt;/li&gt;
&lt;li&gt;名字不能含有大写字母。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：HTMLElement.dataset是一个 StringMap。一个名叫data-test-value的自定义属性可以通过HTMLElment.dataset.testValue来访问，属性的名字中的中线(U+002D)被挨着它字母的大写字母代替了（驼峰命名）。&lt;/p&gt;

&lt;p&gt;自定义的data 属性名称转化成 DOMStringMap 的键值时会遵循下面的规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;前缀  data- 被去除(包括减号)；&lt;/li&gt;
&lt;li&gt;对于每个在ASCII小写字母 a到 z前面的减号 (U+002D)，减号会被去除，并且字母会转变成对应的大写字母。其他字符（包含其他减号）都不发生变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体链接: &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-data-*&#34;&gt;data-*&lt;/a&gt;,&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset&#34;&gt;dataset&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——栅格系统</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/grid/</link>
      <pubDate>Sat, 25 Jun 2016 19:23:09 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/grid/</guid>
      <description>

&lt;p&gt;bootstrap的CSS部分中最出名的应该就是栅格系统了，它解决了网页中常见的多列布局问题。对应的实现其实并不是特别复杂，主要包括以下知识点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;盒模型&lt;/li&gt;
&lt;li&gt;浮动&lt;/li&gt;
&lt;li&gt;相对定位&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;基本概念:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;栅格系统的行（row）必须包裹在&lt;code&gt;.container&lt;/code&gt;或者&lt;code&gt;container-fluid&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}
@media (min-width: 768px) {
  .container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .container {
    width: 1170px;
  }
}
.container-fluid {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中看出bootstrap中移动优先的理念，默认的都是小屏下的样式，再逐步通过媒体查询实现大屏下的样式。&lt;code&gt;container&lt;/code&gt;和&lt;code&gt;container-fluid&lt;/code&gt;在小屏下的行为是一致的，但是在pad屏或者更大的屏幕下，前者表现为有固定宽度居中显示，而后者一直保持宽度100%，虽然我很好奇后者为什么要添加上&lt;code&gt;margin-left:auto;margin-right:auto;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而列的样式比较有趣&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.row {
  margin-right: -15px;
  margin-left: -15px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;row要包含在container中，container包含了15px的左右padding，row却用左右各-15px的margin撑了出去，抵消了container的padding，写这个框架的人在想什么？问题的答案在于列的样式以及列嵌套。在列的通用样式里，有这样的设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;padding-right: 15px;
padding-left: 15px;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想要实现列嵌套，例如如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-sm-9&amp;quot;&amp;gt;
    Level 1: .col-sm-9
    &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;col-xs-8 col-sm-6&amp;quot;&amp;gt;
        Level 2: .col-xs-8 .col-sm-6
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;col-xs-4 col-sm-6&amp;quot;&amp;gt;
        Level 2: .col-xs-4 .col-sm-6
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要内层的row抵消掉外层的col的padding。&lt;/p&gt;

&lt;h2 id=&#34;盒模型部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;盒模型部分&lt;/h2&gt;

&lt;p&gt;默认情况下box-sizing为content-box，bootstrap上来就重置了盒模型为border-box。为什么要这么做呢？因为栅格系统的每一列的宽度都是根据百分比计算得到的，如果使用默认的content-box，如果有的列加上border或者padding，布局直接会乱掉。基本上等分布局的实现离不开这一设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* {
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;浮动部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;浮动部分&lt;/h2&gt;

&lt;p&gt;如果让你实现多列布局，你想怎么办？最容易想到的就是浮动啊。bootstrap确实是使用浮动实现多列布局的。&lt;/p&gt;

&lt;p&gt;部分代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {
  float: left;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然使用了浮动，那么就免不了要处理浮动带来的盒子塌陷问题。具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container:after,
.container-fluid:after,
.row:after{
  display: table;
  content: &amp;quot; &amp;quot;;
  clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的时候我们需要对列进行偏移，bootstrap提供了&lt;code&gt;col-*-offset-*&lt;/code&gt;一系列类，实现原理是通过margin-left。&lt;/p&gt;

&lt;h2 id=&#34;相对定位部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;相对定位部分&lt;/h2&gt;

&lt;p&gt;一开始读bootstrap 源码的时候，发现列的公共样式里面有这么一条：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position: relative;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说相对定位是和绝对定位结合使用的，这里有没有绝对定位是干什么的呢？当我读到关于列顺序的代码的时候我就明白了。&lt;/p&gt;

&lt;p&gt;相对定位的元素，如果是使用top left right bottom ，其定位是相对于原来的位置进行定位。举个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.col-xs-push-6 {
  left: 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用此类后col相对于原来的位置向右偏移了50%。看起来是在模拟flex布局的order。然而我真的没在生产环境里用过，真的没有。&lt;/p&gt;

&lt;h2 id=&#34;响应式布局:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;响应式布局&lt;/h2&gt;

&lt;p&gt;作为一个前端框架，bootstrap显然要处理不同屏幕下的显示问题，所以使用了响应式布局。处于移动优先这一概念的考虑，bootstrap默认设施都是在手机小屏下，然后通过媒体查询实现其他较大屏幕的样式设置。当浏览器宽度超过了分界点，如果没有设置此区间的新样式，按照更小屏幕的样式显示。&lt;/p&gt;

&lt;p&gt;其实对于手机端来说，bootstrap一方面可能太重了，另一方面响应式布局也不见得是万能的。这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;对于bootstrap的css，目前觉得也就是它的栅格系统有必要说一下，其他的再说吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何将页脚固定在页面底部</title>
      <link>http://jiangshanmeta.github.io/post/stickyfooter/</link>
      <pubDate>Fri, 24 Jun 2016 20:05:51 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/stickyfooter/</guid>
      <description>

&lt;p&gt;在一个网页中通常会有页脚的设置。如果页面内容较少，看起来页脚就像是浮了起来，在浏览器的下面还有一块白色，显得非常难看。我不会告诉你我最近看到的新鲜的页面里还有这种问题，都是同行，给人个面子，不给链接了。那么如何解决这一问题呢？&lt;/p&gt;

&lt;h2 id=&#34;javascript方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;javascript方案&lt;/h2&gt;

&lt;p&gt;不难，请自行百度。然而我总是想能用css解决的绝对不用js。先约定一下页面结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
	&amp;lt;header id=&amp;quot;header&amp;quot;&amp;gt;

	&amp;lt;/header &amp;gt;
	&amp;lt;main id=&amp;quot;header&amp;quot;&amp;gt;

	&amp;lt;/main&amp;gt;
	&amp;lt;footer id=&amp;quot;footer&amp;quot;&amp;gt;

	&amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公共的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;table方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;table方案&lt;/h2&gt;

&lt;p&gt;这里所说的table并不是说html table，而是css table。在css的display属性中，有一堆关于table的值，比如&lt;code&gt;table&lt;/code&gt;,&lt;code&gt;table-row&lt;/code&gt;,&lt;code&gt;table-cell&lt;/code&gt;。这些值可以帮助我们像表格一样布局而不使用html table。这里用到的是&lt;code&gt;table&lt;/code&gt;和&lt;code&gt;table-row&lt;/code&gt;两个值。&lt;/p&gt;

&lt;p&gt;我们可以把整个body视为一个table，然后header、main、footer三部分视为table-row。并且让main占据100%高度。可能你觉得很奇怪如果main高度设为100%，那么header和footer的高度岂不是零了？但是table有许多神奇的特性，header和footer会正常显示。这里的header和footer的高度会变成恰能放下内容的高度，main占据剩余空间。因为table的话无论是宽度还是高度计算都比较复杂，web开发者所设置的width或者height都是参考值。&lt;/p&gt;

&lt;p&gt;这样你会发现依然没有实现固定在底部。因为body的高度现在是由内容决定的，我们要设置body的最小高度设为视口高度。可以采用100vh这么一个方案，如果担心兼容性问题，可以把高度设为百分比。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body{
	display:table;
	width:100%;
	min-height:100vh;
}
#main{
	display:table-row;
	height:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在线demo：&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;固定在底部的页脚——table方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flex方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;flex方案&lt;/h2&gt;

&lt;p&gt;flex作为布局神器，基本上你想到的用flex都能做。这里所需要的是两个属性&lt;code&gt;flex-direction&lt;/code&gt;和&lt;code&gt;flex-grow&lt;/code&gt;。我们需要把body作为 flex盒子，并把flex盒子方向设为column，把我们的主体内容的扩展属性设为1，header和footer不扩展，这样就会让主体内容自动填充空余部分。&lt;/p&gt;

&lt;p&gt;代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body{
	display:flex;
	flex-direction:column;
	min-height:100vh;
}
#main{
	flex-grow:1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在线demo：&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/flex.html&#34;&gt;固定在底部的页脚——flex方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结:57c3c18f56fe86510d201aa293fed882&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于如何实现固定在底部的页脚，其实也有许多方案，但是有各种各样的问题，比如footer的高度必须是固定的。我上面所说的两种纯CSS方案都不需要固定footer的高度，基本上可以直接拿到生产环境里用。另外，关于css table的使用自己还需要多多学习，希望近期能够写篇总结。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——alert.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/alert/</link>
      <pubDate>Thu, 23 Jun 2016 21:59:53 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/alert/</guid>
      <description>&lt;p&gt;之前已经&lt;a href=&#34;http://jiangshanmeta.github.io/post/bootstrap/transition/&#34;&gt;解读过bootstrap的transition.js&lt;/a&gt;，今天继续解读alert插件。&lt;/p&gt;

&lt;p&gt;bootstrap的alert插件从功能上看并不复杂，就是让一个警告框消失，所以重要的不是这个功能。重要的是bootstrap如何通过data属性使用插件的，以及bootstrap的插件是如何暴露方法和事件的。&lt;/p&gt;

&lt;p&gt;先解答第一个问题，直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dismiss = &#39;[data-dismiss=&amp;quot;alert&amp;quot;]&#39;
$(document).on(&#39;click.bs.alert.data-api&#39;, dismiss, Alert.prototype.close)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用事件委托，监听&lt;code&gt;document&lt;/code&gt;的click事件，然后子元素的选择器是&lt;code&gt;[data-dismiss=&amp;quot;alert&amp;quot;]&lt;/code&gt;。第一个问题回答完毕。利用data的形式使用bootstrap的插件是官方推荐的，当然也可以手动调用，虽然我觉得这样的需求很少。手动调用需要了解方法是如何暴露的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data(&#39;bs.alert&#39;)

	  if (!data) $this.data(&#39;bs.alert&#39;, (data = new Alert(this)))
	  if (typeof option == &#39;string&#39;) data[option].call($this)
	})
}

$.fn.alert             = Plugin
$.fn.alert.Constructor = Alert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果写过jquery插件，对这种形式应该很熟悉，在jquery的prototype上添加了alert方法，这样就暴露了&lt;code&gt;alert&lt;/code&gt;方法。手动调用&lt;code&gt;alert&lt;/code&gt;方法的时候，首先会确保data上面挂着一个&lt;code&gt;Alert&lt;/code&gt;实例，挂在data上面是为了缓存这么一个实例。如果传入了参数，则调用&lt;code&gt;Alert&lt;/code&gt;对应方法。个人认为不传参数的情况其实用的不多，传参手动关闭警告框有实际应用价值。以前自己写jq插件的时候，对于面向对象的理解不是很到位，对于jq插件的写法了解的也少，这种写法值得学习。&lt;/p&gt;

&lt;p&gt;看一下Alert构造函数的具体内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Alert   = function (el) {
$(el).on(&#39;click&#39;, dismiss, this.close)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和上面在&lt;code&gt;document&lt;/code&gt;上做的差不多，都是监听click事件做事件委托。&lt;/p&gt;

&lt;p&gt;Alert的原型上有具体的&lt;code&gt;close&lt;/code&gt;方法，在这个方法里定义了两个事件&lt;code&gt;close.bs.alert&lt;/code&gt; 和&lt;code&gt;closed.bs.alert&lt;/code&gt;，看一下源代码吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Alert.prototype.close = function (e) {
	var $this    = $(this)

	var selector = $this.attr(&#39;data-target&#39;)
	if (!selector) {
	  selector = $this.attr(&#39;href&#39;)
	  selector = selector &amp;amp;&amp;amp; selector.replace(/.*(?=#[^\s]*$)/, &#39;&#39;) 
	}
	var $parent = $(selector)
	if (e) e.preventDefault()
	if (!$parent.length) {
	  $parent = $this.closest(&#39;.alert&#39;)
	}

	$parent.trigger(e = $.Event(&#39;close.bs.alert&#39;))

	if (e.isDefaultPrevented()) return

	$parent.removeClass(&#39;in&#39;)

	function removeElement() {
	  // detach from parent, fire event then clean up data
	  $parent.detach().trigger(&#39;closed.bs.alert&#39;).remove()
	}

	$.support.transition &amp;amp;&amp;amp; $parent.hasClass(&#39;fade&#39;) ?
	  $parent
	    .one(&#39;bsTransitionEnd&#39;, removeElement)
	    .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	  removeElement()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先做的是寻找关闭时要移除的元素，查找的优先顺序是 data-target、href、最近的含有&lt;code&gt;alert&lt;/code&gt;类的元素。在官方文档里其实并没有提及前两种情况，事实上第三种情况更接近实际需求。对于警告框的删除，一种是有过渡效果的，一种是没有过渡效果的。有过渡效果的情况警告框含有&lt;code&gt;fade&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;两个类并支持过渡，可以在相关css文件看一下代码，就是实现透明度从1过渡到0 。没过渡效果的情况可能是根本不支持css3过渡，也可能是没有&lt;code&gt;fade&lt;/code&gt;这个类。有过渡效果的是在过渡完成后删除警告框，没有过渡的直接删除了，无过渡代码里没有尝试对淡出效果进行模拟。两个事件分别是在移除前和移除后触发的，注意&lt;code&gt;removeElement&lt;/code&gt;的具体实现，先是detach，然后触发事件，最后remove，说实话这两个方法的区别我还体会不深，求大神指教。在实现过渡时使用了transition.js里提供的emulateTransitionEnd，为的是保证回调能够顺利执行。&lt;/p&gt;

&lt;p&gt;最后是防冲突，自己看源码吧，写的挺巧妙的，旧的函数和新的函数都能很好地得到保存。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——transition.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/transition/</link>
      <pubDate>Wed, 22 Jun 2016 19:07:30 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/transition/</guid>
      <description>&lt;p&gt;bootstrap是一个出名的前端框架，它预制了一些常见的js插件。从头开始解读吧。&lt;/p&gt;

&lt;p&gt;这里要介绍的是transition.js，它的作用是对css3的过渡的兼容处理。&lt;/p&gt;

&lt;p&gt;立即执行的匿名函数就不说了，算是基本常识了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function transitionEnd() {
	var el = document.createElement(&#39;bootstrap&#39;)

	var transEndEventNames = {
	  WebkitTransition : &#39;webkitTransitionEnd&#39;,
	  MozTransition    : &#39;transitionend&#39;,
	  OTransition      : &#39;oTransitionEnd otransitionend&#39;,
	  transition       : &#39;transitionend&#39;
	}

	for (var name in transEndEventNames) {
	  if (el.style[name] !== undefined) {
	    return { end: transEndEventNames[name] }
	  }
	}

	return false 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一段是对transitionend事件做兼容，如果浏览器支持各种形式的transitionend，就以对象的形式返回兼容后的结果，否则返回false，表明不支持transitionend事件，另一层意思就是不支持css3过渡。&lt;/p&gt;

&lt;p&gt;之前我收集过一个类似功能的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function whichTransitionEvent(){  
    var t;  
    var el = document.createElement(&#39;p&#39;);  
    var transitions = {  
      &#39;transition&#39;:&#39;transitionend&#39;,  
      &#39;OTransition&#39;:&#39;oTransitionEnd&#39;,  
      &#39;MozTransition&#39;:&#39;mozTransitionEnd&#39;,  
      &#39;WebkitTransition&#39;:&#39;webkitTransitionEnd&#39;,  
      &#39;MsTransition&#39;:&#39;msTransitionEnd&#39;  
    }  
    for(t in transitions){  
        if( el.style[t] !== undefined ){  
            return transitions[t];  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是调用上面那个函数，并且为transitionend起了一个别名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function () {
$.support.transition = transitionEnd()

if (!$.support.transition) return

$.event.special.bsTransitionEnd = {
  bindType: $.support.transition.end,
  delegateType: $.support.transition.end,
  handle: function (e) {
    if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
  }
}
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里把最终的transitionend事件挂到了$.support.transition上，相当于一个缓存。然后是一段让我很纠结的代码，$.event.special.bsTransitionEnd是干啥的的？搜索了一下中文文章发现虽然有提的但是完全不靠谱（这么不靠谱的文章竟然有一堆转载），然后我就在&lt;a href=&#34;http://stackoverflow.com/questions/29861597/what-is-jquery-event-special/29867037#29867037&#34;&gt;stackoverflow上找到了答案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它的意思是这里的bsTransitionEnd相当于兼容后的transitionend事件的别名。为什么要去一个别名而不是直接使用兼容后的transitionend呢？因为怕你我手抖移除transitionend事件的时候不传具体的回调而是直接移除整个事件然后bootstrap插件的回调也一并移除然后报bug。算是为了代码的健壮性吧。&lt;/p&gt;

&lt;p&gt;还有一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.emulateTransitionEnd = function (duration) {
	var called = false
	var $el = this
	$(this).one(&#39;bsTransitionEnd&#39;, function () { called = true })
	var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	setTimeout(callback, duration)
	return this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$.fn.emulateTransitionEnd，看这个形式是直接挂到了jquery的prototype上了。看函数名猜测这一段代码是为了模拟transitionend事件的。不理解作者想干啥，但是&lt;a href=&#34;https://blog.alexmaccaw.com/css-transitions&#34;&gt;源码中给了一个连接&lt;/a&gt;，于是我就找来这篇博客看，原作者是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Be aware that sometimes this event doesn’t fire, usually in the case when properties don’t change or a paint isn’t triggered. To ensure we always get a callback, let’s set a timeout that’ll trigger the event manually.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换句话说作者是为了保证即使没有过渡也要触发transitionend事件保证相应的回调能够执行。其实我很怀疑为什么要这么做，毕竟这种情况下应该测试会报bug。&lt;/p&gt;

&lt;p&gt;具体实现上called变量保存的是transitionend是否被触发，这个变量的存在是为了保证transitionend只触发一次。可能触发多次的情况一个是transition多个属性会触发多个transitionend事件，另一个是真的transitionend事件已经触发，不需要模拟transitionend。一些具体的细节上可以结合setTimeout以及jquery的相关内容理解。突然想到之前写的&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/org/h5page/h5page.html&#34;&gt;h5页面&lt;/a&gt;里面也是监听了transitionend事件，可以参照这个思路改一改。&lt;/p&gt;

&lt;p&gt;顺便提一句，上面那篇文章提到了强制重绘，有一句话我觉得很好&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This will work in most browsers, but I’ve had occasions in Android where this hasn’t been enough. The alternative is to either use timeouts, or by toggling a class name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就在上个周我就遇到了这个问题，强制重绘在pc上测试没问题，在微信内置浏览器上就报bug，最终解决方案也是使用定时器，&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/lottery/index.html&#34;&gt;实现的代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;transition.js内容不多，就只有三块，但是却是bootstap js插件非常重要的一环，后面只要用到css过渡的插件都依赖transition.js。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于CSS3 transition 的几个小tip</title>
      <link>http://jiangshanmeta.github.io/post/transitiontip/</link>
      <pubDate>Tue, 21 Jun 2016 20:19:53 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/transitiontip/</guid>
      <description>

&lt;p&gt;关于CSS3的transition一般写过一阵的基本玩法也都会了，这里收集一些transition的小细节&lt;/p&gt;

&lt;h2 id=&#34;关于伪元素的过渡:fe079bb6a643aa02f488f646a5d5f38e&#34;&gt;关于伪元素的过渡&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/pseudo/&#34;&gt;之前总结过伪元素的一些应用&lt;/a&gt;，但是没有提及如何使用伪元素进行过渡。
直接修改伪元素的属性或者给伪元素添加类名都是很折腾的。常见的改变伪元素的方案是给其父元素添加类名或者利用父元素的伪类。提到伪类，那么能否直接对伪元素本身应用伪类？比如:hover，希望伪元素hover的时候状态改变。然而尝试的结果是否定的。目前对其父元素添加类名或者伪类是对伪元素应用过渡的最简单可行的方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/transitiontip/pseudo.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;模拟input宽度的改变:fe079bb6a643aa02f488f646a5d5f38e&#34;&gt;模拟input宽度的改变&lt;/h2&gt;

&lt;p&gt;如果想利用硬件加速，避免重绘，我们一般要避免width、height、margin之类的属性过渡。然而，有的时候我们确实需要宽度变化的过渡，比如输入框在获取焦点的时候变长，失去焦点后宽度又恢复原状。&lt;a href=&#34;http://t.imooc.com/learn/42&#34;&gt;慕课网一个美化表单案例&lt;/a&gt;就提到了这么一种需求。想实现这一需求可以使用width、padding属性的过渡实现，但是免不了大量的重绘，从前端性能优化的角度来看实现地并不优雅。&lt;/p&gt;

&lt;p&gt;其实换一种思路，我们不见得让输入框真的变长，只要是输入框看起来变长了就行，毕竟我们的目的是加一个动画效果提升用户体验。于是就有了这么一个障眼法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;clipped&amp;quot; &amp;gt;
	&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
	&amp;lt;div class=&amp;quot;clip&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.clipped{
	position:relative;
	width:154px;
}
.clipped .clip{
	position:absolute;
	right:0;
	top:0;
	width:50px;
	height:25px;
	border:2px solid #ccc;
	border-left:0;
	border-radius:4px;
	/*pointer-events:none;*/
	z-index:-1;
	transition:0.4s linear;
}
.clipped input{
	width:150px;
	height:25px;
	border:2px solid #ccc;
	border-radius:4px;
	border-right:0px;
	
}
.clipped input:focus{
	outline:none;
	
}
.clipped input:focus ~.clip{
	transform:translate3d(40px,0,0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/transitiontip/clipping.html&#34;&gt;在线demo&lt;/a&gt;
基本原理是一个绝对定位的div，定位到输入框的右边，模拟输入框右边的样子，input框获得焦点的时候把这个div transform。具体的看代码。如果可以的话想用伪元素实现这个div，然而input并不支持伪元素。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解贝塞尔曲线之如何实现匀加/减速动画</title>
      <link>http://jiangshanmeta.github.io/post/cubicbezier/</link>
      <pubDate>Tue, 14 Jun 2016 19:24:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/cubicbezier/</guid>
      <description>

&lt;p&gt;如果要实现web动画，通常有三个方式，第一是使用gif图，第二是使用CSS3中的transition和animation，第三是使用javascript。gif图一般交给美术去制作，不需要coding，js实现web动画是一个比较成熟的方案了，它的特点是兼容性好，能控制的动画效果多，适合制作复杂的动画效果。随着CSS3的浏览器支持程度越来越高，使用CSS3写web动画也成为一个流行的方式。&lt;/p&gt;

&lt;p&gt;为了控制动画进行过程，CSS3为我们提供了缓动函数，分别为transition-timing-function和animition-timing-function (以下统称timing-function),通常用的是几个关键字属性：linear、ease、ease-in、ease-out、ease-in-out。&lt;/p&gt;

&lt;p&gt;linear是线性动画；ease是默认的动画效果，特点是先快后慢，时间50%的时候已经完成80%的动画效果了；ease-in是动画进行过程中一直加速；ease-out是动画进行过程中一直减速；ease-in-out和ease很相似，都是先加速后减速，但是时间50%的时候完成动画的50%；一般来说，如果没太大的追求这些关键字就足够了。有这种想法的可以直接点击右上角的那个X了。&lt;/p&gt;

&lt;p&gt;稍微高级一点的玩法是使用cubic-bezier,通过指定贝塞尔曲线的两个控制点控制缓动函数。其实三次贝塞尔曲线有四个控制点，然而对于CSS来说第一个控制点是(0,0)，第四个控制点是(1,1)，所以留给我们操作的只有两个控制点了。而且这两个控制点也是有限制的，横坐标∈[0,1]，纵坐标可以大于1。上面几个关键字其实是预定义好的贝塞尔曲线。&lt;/p&gt;

&lt;p&gt;这个贝塞尔曲线就是我们今天的主角。原始需求是：实现匀加/减速动画。最一开始的想法是使用js控制，好像也没什么难度，会高中物理的就能解决。后来我就想能不能用CSS实现这一效果，毕竟我的一个原则是能用CSS实现的绝对不用js。&lt;/p&gt;

&lt;p&gt;先上图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/beziercurve.jpg&#34; alt=&#34;贝塞尔曲线的物理含义&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用这张图说明一下对应的物理含义。横轴是时间进度，纵轴是动画进度。有高中物理水平的就能看得出来这不就是 *路程-时间曲线*嘛。所以曲线一阶导数的物理含义就是速度，二阶导数的物理含义就是加速度。想要实现匀加/减速动画，只要使二阶导数是一个不为零的常数就好了。&lt;/p&gt;

&lt;h4 id=&#34;前方高能预警-大量数学出没-请做好战斗准备:eec53d87b272616feb247dfa262869de&#34;&gt;前方高能预警，大量数学出没，请做好战斗准备&lt;/h4&gt;

&lt;p&gt;三次贝塞尔曲线公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/cubicbezier.jpg&#34; alt=&#34;三次贝塞尔曲线公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于CSS的限制 P0为(0,0)，P3为(1,1)将其带入方程并展开，可以得到对x,y方向的两个方程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation1.jpg&#34; alt=&#34;x,y方向的两个方程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们得到的是两个参数方程。要想得到y对x的二阶导数，需要下面的公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/derivative.jpg&#34; alt=&#34;参数方程二阶导数公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看不懂过程就不要在乎这些细节了，公式推导里有一步我应该曾经明白但我现在不明白。直接看结论，我们需要两个参数方程对t的一阶导数和二阶导数&lt;/p&gt;

&lt;p&gt;于是便有了下面的几个式子&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation2.jpg&#34; alt=&#34;一阶导数和二阶导数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;带入不明觉厉的公式，我们可以观察到，分母最高次项是六次，而分子最高次项是三次，要使结果为一个常数，六次项的系数要为零&lt;/p&gt;

&lt;p&gt;于是我们得到了第一个公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation3.jpg&#34; alt=&#34;第一个公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;将第一个公式带入二阶导数中，我们会发现分母最高次项为3，分子最高此项为2，和上面类似的思路，我们可以得到第二个公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation4.jpg&#34; alt=&#34;第二个公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两个方程联立我们可以解得&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation5.jpg&#34; alt=&#34;第一个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样分母就是一个常数了，分子还有一个一次项，所以&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation6.jpg&#34; alt=&#34;第二个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation7.jpg&#34; alt=&#34;第三个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意到&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/conclusion.jpg&#34; alt=&#34;第四个结论&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>