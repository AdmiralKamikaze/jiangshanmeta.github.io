	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> 初识传输层 &middot; jsmeta </title>
  
  <link rel="stylesheet" href="https://jiangshanmeta.github.io/css/index.css">
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

</head>

	<body class=" article-body">
		<nav class="article-nav">
			<a href="https://jiangshanmeta.github.io/">Home</a>
			<a href="https://jiangshanmeta.github.io/demo/index.html">前端作品</a>
			<a href="https://jiangshanmeta.github.io/categories/index.html">日志分类</a>
		</nav>
		<div class="article ">
			<div >
			  <h1 class="text-center">初识传输层</h1>
			  <p >Sun, Jul 24, 2016</p>
			      

<p>传输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。作为WEB开发者虽然并不直接接触传输层，但是了解一下基本原理对于理解应用层还是有帮助的。</p>

<h2 id="传输层的功能:7d394745458fab98d1011e5dc7ce06d1">传输层的功能</h2>

<p>传输层的功能是为不同主机上的应用进程之间提供了<strong>逻辑通信</strong>。注意这里是逻辑通信，而不是物理通信，传输层是在端系统中实现的而不是在路由器中实现的。在发送端，传输层将从应用进程收到的报文转换成传输层报文段，添加传输层首部。在接收端，网络层从数据报中提取传输层报文，并将其交给传输层。传输层处理收到的报文段，为应用层提供数据。</p>

<p>常见的传输层协议有UDP和TCP。UDP为应用层提供了不可靠、无连接的服务，而TCP提供了可靠、面向连接的服务。</p>

<h2 id="多路复用-多路分解:7d394745458fab98d1011e5dc7ce06d1">多路复用/多路分解</h2>

<p>应用层和传输层之间不是直接交换数据，而是通过套接字socket。每一个套接字都有唯一标识符。</p>

<p>为了在不同主机之间标示套接字，需要在传输层报文中有几个字段。在接收端，传输层检查这些字段，标识出接收套接字，进而将报文段定向到套接字。将传输层报文中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>。从源主机中不同套接字中收集数据块，为其封装首部信息，然后将报文段传给网络层，这些工作称为<strong>多路复用</strong>。</p>

<p>在UDP中一个套接字是通过 目的IP和目的端口号标示的。在TCP中一个套接字是通过 源IP地址、源端口号、目的IP地址、目的端口号标示的。</p>

<h2 id="udp协议:7d394745458fab98d1011e5dc7ce06d1">UDP协议</h2>

<p>UDP协议为应用层提供了不可靠、无连接的服务。UDP是应用层协议比较简单的实现，能提供的功能仅有多路复用/多路分用和差错检验。</p>

<p>先说一下UDP报文的结构。传输层报文是在应用层报文基础上添加了首部信息，即传输层报文 = 传输层首部 + 应用信息。我们的关注点显然是首部字段。</p>

<p><img src="http://jiangshanmeta.github.io/blogimg/computernetwork/udp.jpg" alt="UDP报文结构" /></p>

<p>UDP有四个首部，分别是：源端口号、目的端口号、长度、校验和。源端口号和目的端口号是多路复用/多路分用的基础，长度字段指明了UDP报文的字节数（首部+数据）。校验和是为了差错检验功能。然而不幸的是UDP协议仅仅能够发现错误，但无法从错误中恢复出来，所以UDP协议无法提供可靠地数据传输。</p>

<p>应用UDP协议的应用，一般是对数据可靠性要求没那么高的，比如DNS查询、网络电话、在线直播之类的。</p>

<h2 id="可靠数据传输原理:7d394745458fab98d1011e5dc7ce06d1">可靠数据传输原理</h2>

<p>这个问题说实话有点大了，其实写一个系列丛书讨论这个问题都不为过。我这里就说点总结性的。</p>

<p>为了检验数据是否有差错，采用了校验和。</p>

<p>为了返回检查结果和接受信息，采用了反馈机制。</p>

<p>为了处理丢包，采用了超时机制。</p>

<p>为了处理数据错误和丢包，采用了重传机制（重传大法好）。</p>

<p>为了标识每一个分组、处理冗余分组、检测丢包，采取了序号。</p>

<p>为了解决管线化操作中的差错恢复，出现了回退N步和选择重传。</p>

<h2 id="tcp报文与tcp连接:7d394745458fab98d1011e5dc7ce06d1">TCP报文与TCP连接</h2>

<p>TCP相较于UDP，具有面向连接、可靠传输、流量控制、拥塞控制的功能，显然其所添加的首部字段更加复杂。</p>

<p><img src="http://jiangshanmeta.github.io/blogimg/computernetwork/tcppost.png" alt="TCP报文结构" /></p>

<p>源端口号和目的端口号是多路复用/多路分用的基础，显然TCP报文也会具有这两个字段。与UDP报文类似，TCP报文也具有检验和字段，用于检验比特错误。TCP具有序号和确认号两个字段，用于实现可靠的数据传输。接收窗口字段，用于流量控制。SYN、FIN字段用于建立连接和结束连接。ACK字段用于指示确认字段中的值是有效的。</p>

<p>TCP是面向连接的，我们首先要看的是如何建立TCP连接。</p>

<p>首先客户端TCP向服务器TCP发送一个特殊的TCP报文，该报文段不包含任何应用层传来的数据，但是在报文首部SYN字段标为1，因此这个特殊的报文被称为<strong>SYN报文段</strong>。在序号字段中，会填入客户端随机产生的初始序号。</p>

<p><img src="http://jiangshanmeta.github.io/blogimg/computernetwork/tcpestablish.jpg" alt="三次握手" /></p>

<p>服务器端接收到这个建立连接的请求后会发送一个同意建立连接的响应报文。这个响应报文也不包含应用层信息，但是SYN字段标为1，确认字段为客户端传来的初始序号+1，ACK字段标为1表示确认字段有效，服务器会根据源IP、源端口号、目的主机、目的端口号以及其他信息利用散列函数生成一个服务器的初始序号，放到响应报文的序号字段中。因为SYN和ACK两个字段都被标为1，因此这个返回报文也被称为<strong>SYNACK报文段</strong>。</p>

<p>客户端收到服务器发回来的响应报文，明白了服务器同意建立连接，发送第三个报文，该报文中SYN字段被标为0，并且可以传递应用层信息了。这个报文的序列号是第一步中的序列号+1，确认号是服务器发回来的初始序号+1，因为确认字段有效所以ACK字段标为1。</p>

<p>以上三步一般会统称为<strong>三次握手</strong>，有一些程序员冷笑话就是根据这个来的。言归正传，你说为什么非要三次呢？两次不就解决了，还有为什么服务器初始序号的产生那么复杂？这两个问题的答案是有交叉的。服务器根据客户端的信息利用散列函数生成服务器初始序号，但此时服务器并不保存这个序号，也不为这个连接分配资源，仅仅是同意了建立连接。服务器的响应报文发出去之后，可能用户接收不到，需要第三次握手表示客户端已经收到服务器同意接受请求。同时通过第三次握手的确认字段表明曾经发起过连接请求。</p>

<p>TCP建立连接之后，就可以进行可靠传输了。为了提高传输效率采用了管线化（也有翻译成流水线的）技术。可靠传输基本的原理上面已经提过了，TCP综合利用了检验和、累积确认、定时器、重传、序号、确认号。在传输过程中，通过报文中的接收窗口字段表明还可以接受多少内容，从而实现了流量控制，防止接收端数据溢出。这里还需要说的一句是确认信息正确到达和传递应用层信息是两个不同的功能，只是会倾向于将两个一起发送减少不必要的数据传输，这样就产生了<strong>延迟确认</strong>的问题。</p>

<p>在完成传输任务后，这个TCP连接可以保持一段时间后再拆除，也可以立即拆除。拆除连接时首先客户端向服务器端发送一个TCP报文，其中FIN字段被设为1。服务器接收到该报文段后，发送一个确认报文段。然后服务器连接关闭，发送它自己的终止报文段，FIN字段被置为1。最后，客户端对这个来自于服务器的终止报文确认，发送确认报文，进入TIME_WAIT状态，经过等待后释放相关资源，连接完全关闭。</p>

<p><img src="http://jiangshanmeta.github.io/blogimg/computernetwork/tcpfinish.jpg" alt="拆除连接" /></p>

<h2 id="tcp拥塞控制:7d394745458fab98d1011e5dc7ce06d1">TCP拥塞控制</h2>

<p>拥塞是TCP发送报文速率相较于路由器接受能力过大，使得出现丢包、延迟的现象。TCP可以进行拥塞控制，那么，首先，TCP是如何感受拥塞的呢？TCP发送方定义了一个丢包事件：要么定时器超时、要么收到三个冗余ACK。然后TCP是如何进行拥塞控制、限制传输速率的？和流量控制中的接收窗口类似，TCP发送端也有一个拥塞窗口的概念，调节这个拥塞窗口即可改变传输速率。</p>

<p>最后一个问题，TCP具体的拥塞控制实现是怎样的？总结起来是这么几句话：<strong>慢启动、加性增、乘性减</strong>
。初始拥塞窗口比较小，随着发送拥塞窗口指数增长，称为慢启动（虽然感觉名字怪怪的）。到达一定传输速率后线性增加传输速率，丢包事件后快速减速，这一过程称为加性增，乘性减。这里的“一定传输速率”说起来就复杂了，目前我认为自己只需要知道有个“一定传输速率”的动态分界线即可。</p>

<p>说到这里流量控制和拥塞控制这两者也应该能区分开了，流量控制解决的是接收端缓存不足的问题，拥塞控制为了解决路由缓存不足的问题。两者差的不是一点半点，虽然有些最终表现上是一致的。</p>

<h2 id="最后的总结:7d394745458fab98d1011e5dc7ce06d1">最后的总结</h2>

<p>这里这篇文章并没有深入去描述传输层，只是简单地描述了传输层的功能、多路复用/多路分用的概念、UDP报文及应用、可靠传输需要的辅助字段、TCP连接过程/拆除过程、TCP可靠传输、TCP流量控制以及TCP拥塞控制。</p>

<p>因为目前是以WEB开发的角度看待传输层，这些基本的描述性的东西对于我也应该足够了，或许以后会遇到socket编程吧，当然这是后话了。既然是从WEB开发的角度，我所熟悉的是应用层，传输层更像是一个API，最近我会写一篇文章，从应用层角度看待传输层。</p>

			</div>


		</div>
		<script>
console.log("联系我吧   540118044@qq.com");
</script>   
  </body>
</html>
