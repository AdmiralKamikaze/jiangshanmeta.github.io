	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> 初识链路层 &middot; jsmeta </title>
  
  <link rel="stylesheet" href="http://jiangshanmeta.github.io/css/index.css">
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

</head>

	<body class=" article-body">
		<nav class="article-nav">
			<a href="http://jiangshanmeta.github.io/">Home</a>
			<a href="http://jiangshanmeta.github.io/demo/index.html">前端作品</a>
			<a href="http://jiangshanmeta.github.io/categories/index.html">日志分类</a>
		</nav>
		<div class="article ">
			<div >
			  <h1 class="text-center">初识链路层</h1>
			  <p >Mon, Aug 15, 2016</p>
			      

<p>数据链路层是五层协议栈的第二层，其实对于一般的web开发已经离得有点远了（至少在目前的我看来是这样的），而且个人学习起来这一层感觉东西略杂，尽可能抽出一点主线来吧，并且尽可能对比其它层的协议，这样能加深理解。首先要介绍的是MAC地址的概念。</p>

<h2 id="mac地址:7be74c584635419861677fc2502187c9">MAC地址</h2>

<p>其实MAC地址这个概念还是比较大众的，它的作用和网络层中的IP地址类似，是对链路层的唯一标示。你可能会问通过IP地址就已经能标示到唯一的主机（网络层接口了），何苦再加一层呢？原因比较复杂，这里就说一个我比较认同的理由，是为了分层，出于分层的考虑网络层的寻址和数据链路层的寻址就应该独立的，而且网络层也不仅仅是IP协议啊。</p>

<p>介绍完MAC地址的作用，接下来要介绍的是MAC地址到底长什么样了。MAC地址是一个48位的二进制数（而IP地址仅有32位），一个网卡对应的MAC地址不是由什么协议动态分配的，而是出厂就设定好了的，换句话说MAC地址是物理层面一块网卡的唯一标示，类似于人的身份证号（对比IP地址，IP地址需要利用DHCP从DHCP获取）。</p>

<p>有了之前传输层（源端口号、目的端口号）、网络层（源IP地址、目的IP地址）的经验，很自然我们会想到数据链路层的报文中会含有源MAC地址和目的MAC地址。源MAC地址很好获得，毕竟是网卡一出生就带有的，那目的MAC地址是如何获得的呢？这就需要请出ARP来了。</p>

<h2 id="arp:7be74c584635419861677fc2502187c9">ARP</h2>

<p>ARP协议的作用类似于DNS，根据IP地址返回对应的MAC地址。发送方构建ARP报文，包含源和目的IP、MAC地址。你可能会说，目的IP可以通过DNS、DHCP获得，这个目的MAC地址不是我们要查找的吗，怎么会在发送报文里出现（类似的问题在DHCP中也遇到过）。既然在DHCP中也遇到过，在那里我们提到了一个广播IP地址（255.255.255.255）的概念，我们很容易猜想到也应该有个广播MAC地址的概念，显然确实是有，对应为 <code>FF-FF-FF-FF-FF-FF</code>，48位全为1，这样同一个局域网内的主机都会收到ARP报文，但是只有IP地址和目的地址一致的才会作出相应，返回MAC地址。</p>

<p>源主机得到这条IP地址到MAC地址的映射关系之后，不会只用这么一次然后以后用到的时候再去查询一遍，而是维护一个ARP表表示这种映射关系。（类似结构的表已经见过不少次了，比如DNS、NAT、路由转发表）。</p>

<p>上面介绍的时候我加了一个限制词：<strong>在同一个局域网内</strong>，那要出了局域网怎么办？根据目的主机IP地址找对应的MAC地址？答案是不行的。要想出这个子网需要通过网关（通过DHCP可以获得默认网关IP地址，再通过ARP获得默认网关的的MAC地址），网关那里查询路由转发表，根据下一跳IP地址同样通过ARP获得相应的MAC地址，也就是说每经过一次路由器链路层的目的MAC地址都会被改写。</p>

<h2 id="以太网:7be74c584635419861677fc2502187c9">以太网</h2>

<p>局域网可以大体分为有线局域网和无线局域网，以太网几乎占领了有线局域网。</p>

<p>仅仅从以太网帧的角度来看这并不复杂，以太网帧包含上层数据、源MAC地址、目的MAC地址、类型（类似于IP报文中的上层协议、TCP/UDP报文中的端口号）、CRC（功能上类似于各层的校验和字段，但是实现上不太一致）、前同步码。</p>

<p>以太网比较复杂的一个问题是如何让多个节点共享一个广播链路，即多路访问问题。解决这个问题有许多方案，每个方案也有许多变种，目前的我认为没有必要去关心如何实现的，我们仅需知道能够解决碰撞带来的问题即可。</p>

<h2 id="链路层交换机:7be74c584635419861677fc2502187c9">链路层交换机</h2>

<p>让我们把目光集中到一个子网内，看一下子网内的主机是如何互联起来的。既然是子网内，就没有路由器什么事了，设备只有链路层交换机。每台主机与链路层交换机相连，链路层交换机既可以与主机相连，也可以与其他链路层交换机相连。对于主机而言，链路层交换机是透明的，在一个子网内传递报文，只需要目的主机的MAC地址与IP地址即可，不需要这个链路层交换机的MAC地址（链路层交换机本身不具有MAC地址这个概念）。数据到达链路层交换机，那链路层交换机根据什么决定到哪条出链路上的呢？这个问题形式上看起来很熟悉，路由器的转发功能和这个简直是如出一辙，路由器转发是根据路由转发表，路由转发表由路由协议进行维护更新，数据链路层也有一个类似的交换机表，但这个表中的数据不是由什么协议维护的，而是交换机自学习得到的。</p>

<p>下面解释一下这个自学习是怎么回事。当一条数据通过接口A经过交换机的时候，交换机可以读取到报文中的源MAC地址B，这样在转发表中就记录一条 如果目的MAC地址是B，则通过A接口转发。这条记录也有一个类似TTL的概念，用于更新交换机表。</p>

<p>当数据通过交换机时，如果在交换机表中有一条记录，那显然转发到响应接口上，根据上面说的自学习这点不难理解。如果没有相应记录，交换机就在所有链路上广播该报文，让主机自行决定是否是目的主机 。</p>

			</div>


		</div>
		<script>
console.log("联系我吧   540118044@qq.com");
</script>   
  </body>
</html>
