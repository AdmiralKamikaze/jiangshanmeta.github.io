<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jsmeta</title>
    <link>http://jiangshanmeta.github.io/</link>
    <description>Recent content on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Jun 2016 20:46:09 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>百度Touch.js代码解读</title>
      <link>http://jiangshanmeta.github.io/post/touchjs/</link>
      <pubDate>Mon, 06 Jun 2016 20:46:09 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/touchjs/</guid>
      <description>

&lt;p&gt;在移动端各种手势事件很常见，然而不幸的是原生的js只提供了touchstart、touchmove、touchend、touchcancel这么几个事件的。所以我们需要手势库帮助我们判断手势。&lt;a href=&#34;https://github.com/Clouda-team/touch.code.baidu.com&#34;&gt;百度的touch&lt;/a&gt;是其中一个例子。之所以选择它是因为在之前的hammer我连文档都读不下去，中文文档实在是太有诱惑力了。然而hammer推荐的比例挺高的，还是抽空去看看吧。&lt;/p&gt;

&lt;p&gt;touch.js主要分为以下几块，第一个是工具函数，第二个是底层事件代理，第三个是手势判断。虽然这是一个手势库，但是自己资历尚浅，没有从具体的手势判断中读出多少东西，所以主要说一下前两个部分。&lt;/p&gt;

&lt;p&gt;先看一下封装的一些工具函数，代码中把工具函数封装到了&lt;code&gt;utils&lt;/code&gt;这个对象中。&lt;/p&gt;

&lt;h2 id=&#34;工具函数:8c3dfd5f7a431f6dbb28cd40ffd93e79&#34;&gt;工具函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;utils.PCevts = {
    &#39;touchstart&#39;: &#39;mousedown&#39;,
    &#39;touchmove&#39;: &#39;mousemove&#39;,
    &#39;touchend&#39;: &#39;mouseup&#39;,
    &#39;touchcancel&#39;: &#39;mouseout&#39;
};
utils.hasTouch = (&#39;ontouchstart&#39; in window);
utils.getPCevts = function(evt) {
    return this.PCevts[evt] || evt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这几个函数是为了兼容PC的，&lt;code&gt;&#39;ontouchstart&#39; in window&lt;/code&gt;是用来检测是否有touch事件的，进而判断是移动端还是pc端，这个写法其实挺常见的，而PCevts相当于是一个兼容PC事件的config，getPCevts这一工具函数会获得pc对应事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.getType = function(obj) {
    return Object.prototype.toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个工具函数是用来判断变量类型的，这是js的一个很坑的地方，最简单的&lt;code&gt;typeof&lt;/code&gt;关键字只能判断基本类型，引用类型没法区别。&lt;code&gt;Object.prototype.toString.call(obj)&lt;/code&gt;返回的是一个形如&lt;code&gt;[object Number]&lt;/code&gt;的字符串，后面的正则是用来匹配字符串中的&lt;code&gt;Number&lt;/code&gt;这一区域的，并将其小写化。这一个方法可以用来判断基本类型和引用类型。我见过的类似的实现不是使用正则而是使用截取字符串的方法，其实大同小异，都是对字符串进行处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.matchSelector = function(target, selector) {
    return target.webkitMatchesSelector(selector);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;a href=&#34;http://caniuse.com/#search=matchess&#34;&gt;can I use&lt;/a&gt;查到的兼容性来看兼容性问题还勉强能接受，然而touch是大约两年前写的。这里的&lt;code&gt;webkitMatchesSelector&lt;/code&gt;只考虑了webkit内核，根据&lt;a href=&#34;https://dom.spec.whatwg.org/#dom-element-matches&#34;&gt;文档的说法&lt;/a&gt;，这个方法只是历史遗留下来，是&lt;code&gt;matches&lt;/code&gt;方法的等价品。&lt;/p&gt;

&lt;p&gt;如果从现在的角度来看应该这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.matchSelector = function(target, selector) {
    if(target.matches){
        return target.matches(selector);
    }else if(target.webkitMatchesSelector){
        return target.webkitMatchesSelector(selector);
    }else if(target.msMatchesSelector){
        return target.msMatchesSelector(selector);
    }
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chrome浏览器没问题，但是安卓浏览器，IE，还有万恶的微信内置浏览器都要兼容一下。这个方法以前也知道，但是没有用过，通常都是判断是否满足某个class。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.forceReflow = function() {
    var tempDivID = &amp;quot;reflowDivBlock&amp;quot;;
    var domTreeOpDiv = document.getElementById(tempDivID);
    if (!domTreeOpDiv) {
        domTreeOpDiv = document.createElement(&amp;quot;div&amp;quot;);
        domTreeOpDiv.id = tempDivID;
        document.body.appendChild(domTreeOpDiv);
    }
    var parentNode = domTreeOpDiv.parentNode;
    var nextSibling = domTreeOpDiv.nextSibling;
    parentNode.removeChild(domTreeOpDiv);
    parentNode.insertBefore(domTreeOpDiv, nextSibling);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看名字也能看的出来是用来强制重绘的，重绘的原理是一个没内容的空div，先移除，再插回到原来的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.simpleClone = function(obj) {
    return Object.create(obj);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原型式继承，实现对obj的浅复制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.getPosOfEvent = function(ev) {
    if (this.hasTouch) {
        var posi = [];
        var src = null;

        for (var t = 0, len = ev.touches.length; t &amp;lt; len; t++) {
            src = ev.touches[t];
            posi.push({
                x: src.pageX,
                y: src.pageY
            });
        }
        return posi;
    } else {
        return [{
            x: ev.pageX,
            y: ev.pageY
        }];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个工具函数的作用是获得事件的坐标，并存在一个array中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.getXYByElement = function(el) {
    var left = 0,
        top = 0;

    while (el.offsetParent) {
        left += el.offsetLeft;
        top += el.offsetTop;
        el = el.offsetParent;
    }
    return {
        left: left,
        top: top
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法返回了元素相对于页面的位置。具体内容可以参见&lt;strong&gt;《JavaScript 高级程序设计（第三版）》&lt;/strong&gt;第十二章的有关内容&lt;/p&gt;

&lt;p&gt;还有几个工具函数是关于数学计算的，以及判断事件类型的，没什么太大提及的必要。&lt;/p&gt;

&lt;h2 id=&#34;整体结构及手势判断:8c3dfd5f7a431f6dbb28cd40ffd93e79&#34;&gt;整体结构及手势判断&lt;/h2&gt;

&lt;p&gt;曾经我在写一个h5页面页面之间切换的js的时候，尝试着写手势判断，但是我写的太笨了。我当时是在element上绑定了touchstart、touchmove、touchend几个事件，在我自己的应用场景下没什么问题，因为最终我只是绑定在了document这一个元素之上。但是如果要绑定手势事件的元素特别多，就有性能问题了。touch的处理就比较巧妙，它只在document上绑定了touchstart、touchmove、touchend、touchcancel几个事件，然后利用&lt;code&gt;event.target&lt;/code&gt;获取触发事件的元素，在相应元素上触发手势事件。道理大家都懂，只是别人用的巧啊。&lt;/p&gt;

&lt;p&gt;整体结构的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(root, factory) {
    if (typeof define === &#39;function&#39; &amp;amp;&amp;amp; (define.amd || define.cmd)) {
        define(factory); //Register as a module.
    } else {
        root.touch = factory();
    }
}(this, function() {

    function init(){
        var mouseEvents = &#39;mouseup mousedown mousemove mouseout&#39;,
            touchEvents = &#39;touchstart touchmove touchend touchcancel&#39;;
        var bindingEvents = utils.hasTouch ? touchEvents : mouseEvents;

        bindingEvents.split(&amp;quot; &amp;quot;).forEach(function(evt) {
            document.addEventListener(evt, handlerOriginEvent, false);
        });
    }
    init();
    var exports = {};

    exports.on = exports.bind = exports.live = _on;
    exports.off = exports.unbind = exports.die = _off;
    exports.config = config;
    exports.trigger = _dispatch;

    return exports;

}))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体上是一个匿名函数自执行。一开始判断define是否为函数，如果是则注册为模块，如果不是则向window对象上添加一个全局变量touch，touch的内容是返回的exports，在文档里看到的on、off、config、trigger就是出自这里。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init函数&lt;/code&gt; 首先判断环境是移动环境还是PC环境，据此绑定事件。绑定事件到&lt;code&gt;document&lt;/code&gt;上，具体的回调函数是&lt;code&gt;handlerOriginEvent&lt;/code&gt;，在这个函数内部根据具体条件调用封装在&lt;code&gt;gesture&lt;/code&gt;里的方法，算是对手势事件的整体掌控+分流吧。在gesture内部根据条件在&lt;code&gt;event.target&lt;/code&gt;上触发手势事件。&lt;/p&gt;

&lt;p&gt;具体的手势判断过于复杂，我也没读出太多的东西出来，等以后理解深入了再说吧。&lt;/p&gt;

&lt;h2 id=&#34;底层事件处理:8c3dfd5f7a431f6dbb28cd40ffd93e79&#34;&gt;底层事件处理&lt;/h2&gt;

&lt;p&gt;底层事件处理是判断手势的基础，也是暴露给开发者的几个接口&lt;code&gt;on&lt;/code&gt;,&lt;code&gt;off&lt;/code&gt;,&lt;code&gt;trigger&lt;/code&gt;的基础。事实上只要能够理解底层事件是如何处理的，就自然明白那几个暴露的接口是如何写的了。&lt;/p&gt;

&lt;p&gt;作者封装了一个&lt;code&gt;engine&lt;/code&gt;，进行了对事件的底层处理。
基本结构是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var engine = {
	proxyid: 0,
    proxies: [],
    trigger: function(el, evt, detail) {

	},
	bind: function(el, evt, handler) {

	},
	unbind: function(el, evt, handler) {

	},
	delegate: function(el, evt, sel, handler) {

	},
	undelegate: function(el, evt, sel, handler) {

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我向来喜欢手动代理事件，所以后两个方法直接没用过，也没有什么想用的欲望。主要讲前三个方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trigger: function(el, evt, detail) {

    detail = detail || {};
    var e, opt = {
            bubbles: true,
            cancelable: true,
            detail: detail
        };

    try {
        if (typeof CustomEvent !== &#39;undefined&#39;) {
            e = new CustomEvent(evt, opt);
            if (el) {
                el.dispatchEvent(e);
            }
        } else {
            e = document.createEvent(&amp;quot;CustomEvent&amp;quot;);
            e.initCustomEvent(evt, true, true, detail);
            if (el) {
                el.dispatchEvent(e);
            }
        }
    } catch (ex) {
        console.warn(&amp;quot;Touch.js is not supported by environment.&amp;quot;);
    }
},

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器内置的事件类型数量有限，所幸允许我们自定义事件，这也是我们能够写手势库的前提。&lt;/p&gt;

&lt;p&gt;我曾经封过一个类似的小函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var triggerEvent = function (el, eventName, detail) {
    var event = document.createEvent(&amp;quot;CustomEvent&amp;quot;);
    event.initCustomEvent(eventName, true, true, detail);
    if(typeof detail == &amp;quot;object&amp;quot;){
    	for( k in detail){
    		if(detail.hasOwnProperty(k)){
    			event[k]=detail[k]
    		}
    	}
    }
    el.dispatchEvent(event);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本思路大差不差，只是这里为了模仿jQuery里的event将detail里的内容都挂到了event上面。在touch.js里面也有类似的操作，是在绑定事件里面，稍后就会提到。看到这里基本就已经把相关的&lt;code&gt;_dispatch&lt;/code&gt;函数给讲完了。说实话，我看到的资料里没有讲到过&lt;code&gt;new CustomEvent(evt, opt)&lt;/code&gt;,只有其中的&lt;code&gt;document.createEvent(&amp;quot;CustomEvent&amp;quot;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后是绑定事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind: function(el, evt, handler) {
    el.listeners = el.listeners || {};
    if (!el.listeners[evt]) {
        el.listeners[evt] = [handler];
    } else {
        el.listeners[evt].push(handler);
    }
    var proxy = function(e) {
        if (utils.env.ios7) {
            utils.forceReflow();
        }
        e.originEvent = e;
        for (var p in e.detail) {
            if (p !== &#39;type&#39;) {
                e[p] = e.detail[p];
            }
        }
        e.startRotate = function() {
            __rotation_single_finger = true;
        };
        
        var returnValue = handler.call(e.target, e);
        if (typeof returnValue !== &amp;quot;undefined&amp;quot; &amp;amp;&amp;amp; !returnValue) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    handler.proxy = handler.proxy || {};
    if (!handler.proxy[evt]) {
        handler.proxy[evt] = [this.proxyid++];
    } else {
        handler.proxy[evt].push(this.proxyid++);
    }
    this.proxies.push(proxy);
    if (el.addEventListener) {
        el.addEventListener(evt, proxy, false);
    }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实我觉得这是整个touch.js里最关键的一个方法。&lt;/p&gt;

&lt;p&gt;我以前尝试写的时候直接在元素上绑定了相应的回调函数，但是touch给这个回调函数包裹了一层代理，在这个代理内部调用了对应的回调函数。element身上绑定的不是原来的回调函数，而是这一层代理。这样做有什么好处呢？一个是改写event对象。上面提及的我封装的&lt;code&gt;triggerEvent&lt;/code&gt;也做了类似的事情。这里作者把&lt;code&gt;detail&lt;/code&gt;对象上的东西挂到了&lt;code&gt;event&lt;/code&gt;对象上，这也是为什么文档里提及的&lt;code&gt;event&lt;/code&gt;对象上新增的属性的来源。在jQuery也有类似的改写event对象，原理目测大同小异。另一方面做一些兼容，这里判断是否是iOS7然后强制重绘了，不知道hack的是什么。看库有时候就这样，完全不清楚作者想hack什么地方。&lt;/p&gt;

&lt;p&gt;具体调用原始回调函数是使用&lt;code&gt;call&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var returnValue = handler.call(e.target, e);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作者还对调用原始回调的返回值做了处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (typeof returnValue !== &amp;quot;undefined&amp;quot; &amp;amp;&amp;amp; !returnValue) {
    e.stopPropagation();
    e.preventDefault();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我认为作者考虑到有人喜欢用&lt;code&gt;return false&lt;/code&gt;阻止默认事件和阻止事件冒泡。然后手动做了这两个操作。然而我不太明白的是判断的写法，直接判断返回值是否为&lt;code&gt;false&lt;/code&gt;不行吗？不知道作者还在考虑什么。&lt;/p&gt;

&lt;p&gt;proxyid和proxies这两个是为了接触绑定而存在的，这是因为实际绑定的回调不是原来的回调，我们要解除事件绑定需要解除的是绑定的代理事件，明确这一点就知道他的解除绑定是如何写的了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术类文章工具汇总</title>
      <link>http://jiangshanmeta.github.io/post/blog/techblog/</link>
      <pubDate>Fri, 03 Jun 2016 19:55:29 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/techblog/</guid>
      <description>

&lt;p&gt;收藏一些提高知识水平的技术类文章&lt;/p&gt;

&lt;h2 id=&#34;css相关:7c5004fa5e3547b8952a8bdb79e9c4fc&#34;&gt;CSS相关&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2015/03/background-object-position-value-percent/&#34;&gt;&lt;position&gt;值简介,相对底部右侧定位,理解百分比定位——张鑫旭&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/aaronjs/p/4642015.html&#34;&gt;深入理解CSS3 Animation 帧动画——艾伦 Aaron&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://web.jobbole.com/86079/&#34;&gt;利用伪元素美化加载失败的图片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://verou.me/css3patterns/&#34;&gt;能用渐变实现的图案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cubic-bezier.com&#34;&gt;贝赛尔曲线在线展示&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://easings.net/zh-cn&#34;&gt;常见缓动函数&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;移动端:7c5004fa5e3547b8952a8bdb79e9c4fc&#34;&gt;移动端&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/6e2b68a93c88&#34;&gt;移动端300ms点击延迟和点击穿透问题&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript的this坑</title>
      <link>http://jiangshanmeta.github.io/post/jsthis/</link>
      <pubDate>Thu, 02 Jun 2016 21:36:26 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/jsthis/</guid>
      <description>&lt;p&gt;JavaScript有许多坑，一个典型的代表就是this，动不动this的指向就变了。&lt;/p&gt;

&lt;p&gt;我也不想扯太多理论性的东西，那些是属于看着明白看完就忘的。我想干脆找个例子去说一下吧。今天在某个前端群里看到有人问相关问题。干脆就借用别人遇到的问题说一下吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/right.png&#34; alt=&#34;最原始的代码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是最原始的代码。目测是在一个构造函数里截取的一段。这张图里的this我想大家都很明白，而在回调函数里，出现的不是this，而是_this,目测是对上面this的保存。因为在回调里，this已经指向了ul_wrap，和外面的this不一样了。&lt;/p&gt;

&lt;p&gt;然后群里的人想改这段代码称为如下的样子&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/wrong.png&#34; alt=&#34;想要改成的代码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是报错信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/error.png&#34; alt=&#34;报错信息&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是里面提到的几个回调的具体实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/prototype.png&#34; alt=&#34;prototype&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看报错信息是出在 touchMove 和touchEnd两个内部对move方法的调用上。
那么，目测应该有一段是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UcanSlide.prototype.move=function(){
	//do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那就很明确问题在哪里了。修改代码之后，其实就相当于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.ul_wrap.addEventListener(&amp;quot;touchmove&amp;quot;,function(e){
	e.preventDefault();
	this.autoScroll = false;
	this.dirX+=e.targetTouches[0].clientX-this.startX;
	this.startX=e.targetTouches[0].clientX;
	this.move();
},false);
this.ul_wrap.addEventListener(&amp;quot;touchend&amp;quot;,function(e){
	var _this = this;
	this.autoScroll = true;
	this.setTime = setInterval(function(){
		_this.move();
	},_this.scrollSpeed)
},false)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写就看的明白多了。现在回调内部的this指的是ul_wrap，而不是外面的this，而move方法是在外面的this上的，而不是ul_wrap上的，所以内部调用move方法相当于调用ul_wrap的move方法，显然会报错。&lt;/p&gt;

&lt;p&gt;还有值得一提的是在touchend的回调里先是缓存了当前的this，因为在setInterval的回调里this也飘了，指向了window。&lt;/p&gt;

&lt;p&gt;js的this坑其实也不算什么坑，熟悉了就好了。&lt;/p&gt;

&lt;p&gt;//话说我的表达能力还是too young啊&lt;/p&gt;

&lt;p&gt;//update 2016/6/3
于是今天的项目中就用到了缓存this&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解CSS3中width新的几个关键字成员</title>
      <link>http://jiangshanmeta.github.io/post/css3width/</link>
      <pubDate>Mon, 30 May 2016 21:39:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css3width/</guid>
      <description>

&lt;p&gt;最近看了&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/&#34;&gt;张鑫旭大神的一片文章&lt;/a&gt;,介绍了&lt;code&gt;width&lt;/code&gt;属性的几个关键字成员：&lt;code&gt;fill-available&lt;/code&gt;、&lt;code&gt;max-content&lt;/code&gt;、&lt;code&gt;min-content&lt;/code&gt;、&lt;code&gt;fit-content&lt;/code&gt;。如果有不熟悉基本概念的链接都有了自己点过去看。他的那篇文章偏重于概念介绍，我想介绍一些细节以及应用&lt;/p&gt;

&lt;h2 id=&#34;fill-available:3de20cc74c1f43aee615802a184084e5&#34;&gt;fill-available&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.fill-available{
	width:fill-available;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个关键字使得盒子尽可能填充满剩余空间，听起来很像是&lt;code&gt;width:100%;&lt;/code&gt;。那么直接用&lt;code&gt;width:100%;&lt;/code&gt;行吗,至少没有兼容问题啊？&lt;/p&gt;

&lt;p&gt;其实是分情况的。如果对这个盒子设置了&lt;code&gt;box-sizing:border-box&lt;/code&gt;,那真的无所谓，用什么都行。但是默认的&lt;code&gt;box-sizing&lt;/code&gt;是*content-box*在这种情况下如果有margin padding border的，此时使用&lt;code&gt;width:100%&lt;/code&gt;就会面临超出父盒子的问题，但是&lt;code&gt;width:fill-available&lt;/code&gt;就没有这个问题。&lt;/p&gt;

&lt;p&gt;//像我们这种基于bootstrap改改用的，已经有了&lt;code&gt;*{box-sizing:border-box;}&lt;/code&gt;，所以好像没什么用。&lt;/p&gt;

&lt;h2 id=&#34;max-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;max-content&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;max-content的行为表现可以这么理解，假设我们的容器有足够的宽度，足够的空间，此时，所占据的宽度是就是max-content所表示的尺寸。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说实话至今我没想起来这个能用来干什么。如果内容很长，会出现横向滚动条，对于web横向滚动条并不是什么好的设计。如果内容并不多，它的表现和下面的fit-content是一致的。真·找不到应用场景。&lt;/p&gt;

&lt;h2 id=&#34;min-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;min-content&lt;/h2&gt;

&lt;p&gt;这个就比较有意思了，我们可以用来自适应内部元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;&amp;quot; class=&amp;quot;responsive-wrap&amp;quot;&amp;gt;
	&amp;lt;img src=&amp;quot;http://jiangshanmeta.github.io/demo/myWork/csssecrets/2.jpg&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以往常见的图片展示效果是规定外层div的大小，然后图片大小跟着外层div来。bootstrap里的一个实现是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;img-responsive{
	display: block;
	max-width: 100%;
	height: auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我偏要父元素的宽度跟着子元素走，以往我可能会这么做：给外层div加个&lt;code&gt;display:table;&lt;/code&gt;利用其尺寸收缩的特性。有点hack的味道在这里。而且这么做健壮性不够，如果我想给图片下面加上几行描述，尤其是字数要长长长，这时候&lt;code&gt;display:table;&lt;/code&gt;的效果，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/css3width/table.html&#34;&gt;点开自己看&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果把div的width设为min-content,就能在长描述的存在下，依然做到父元素大小跟着图片大小走。结果请点击上面链接&lt;/p&gt;

&lt;h2 id=&#34;fit-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;fit-content&lt;/h2&gt;

&lt;p&gt;这个属性的性质和上面说的&lt;code&gt;display:table;&lt;/code&gt;最终表现可以说一模一样。我没找到区别。&lt;/p&gt;

&lt;h2 id=&#34;结束语:3de20cc74c1f43aee615802a184084e5&#34;&gt;结束语&lt;/h2&gt;

&lt;p&gt;好像也就min-content用处多点，其他的我还在想能做什么特别而且能用到的事情&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>结构与样式相分离之CSS图形</title>
      <link>http://jiangshanmeta.github.io/post/cssshape/</link>
      <pubDate>Sun, 29 May 2016 18:19:27 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/cssshape/</guid>
      <description>&lt;p&gt;做前端的应该都听说过“结构与样式相分离”这一句话。最简单的理解是HTML负责结构，CSS负责样式。然而，自己在实际项目中并没有很好地应用这句话，经常为了实现某个特殊样式加上一堆div。&lt;/p&gt;

&lt;p&gt;比如说之前实现的一个效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/cssshape1.png&#34; alt=&#34;彩色的边框&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当时实现这个效果的基本思路是用border画出外面的环，由于角度问题，所以还要加上一个transform转45deg，这样边框就画出来了，但是内部的人物头像也随着父元素，所以也要加上一个transform抵消父元素转动的影响。&lt;/p&gt;

&lt;p&gt;这样虽然实现了，但是总感觉不够优雅，加的额外的HTML和CSS略多，而仅仅是为了实现一个环。&lt;/p&gt;

&lt;p&gt;再次安利一下我最近看的书&lt;strong&gt;CSS Secrets&lt;/strong&gt;，这本书还没看完，但是给我不少启发。之前写过一篇&lt;a href=&#34;http://jiangshanmeta.github.io/post/pseudo/&#34;&gt;小的总结&lt;/a&gt;，谈到了伪元素的一些应用。我想，用伪元素做一些装饰性的工作，可以减少冗余的div和CSS，增强重用性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;img-outer-circle&amp;quot;&amp;gt;
	&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.img-outer-circle{
	position:relative;
	width:135px;
	height:135px;
}
.img-outer-circle::before{
	content:&#39;&#39;;
	position:absolute;
	top:-10px;
	left:-10px;
	right:-10px;
	bottom:-10px;
	border-radius:50%;
	border-width:5px;
	border-style:solid;
	border-color:#3d8ceb #3d8ceb #f1cb2f #f1cb2f ;
	-webkit-transform:rotate(-45deg);
	transform:rotate(-45deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，HTML还是以前的，因为像是&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;这样的自闭合标签没有伪元素这一说法，不能直接加在图片上。CSS上实现边框的思路还是和以前一样，但是因为不是对整个div进行transform，所以不用对图片再进行处理了。目前看不出来什么特别的优势。但是试想如果来了需求，说要给图片加个出场动画，如果用animation实现的话，免不了各种transform，transform各种影响，免不了出些奇奇怪怪的bug。//不要问我怎么知道的&lt;/p&gt;

&lt;p&gt;这里提一句，本来是想用&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;的伪元素写一个边框的，但是没能实现，上面的理由说的太简单了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/21296044&#34;&gt;知乎上有个相关问题&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-&amp;lt;img&amp;gt;```也不是完全不能应用伪元素，比如[利用伪元素美化加载失败的图片](http://web.jobbole.com/86079/)&#34;&gt;

伪元素能做的装饰性的东西其实很多，上面是伪元素结合border做了一个彩色的边框，其实还可以做一些三角形、菱形、梯形之类的。三角形和菱形就不说了，简单说一下梯形。

在**CSS Secrets**这本书中，作者采用的方法伪元素+transform3d，伪元素的方案我是赞同的，但是transform3d一方面有些兼容性问题，另一方面3d效果理解起来比较困难，尤其是结合transform-origin的3d效果。于是，我决定用border一条路走到黑。

因为border经常用来实现各种图形，我[结合Vue实现了一个查看border能做什么的demo](http://jiangshanmeta.github.io/demo/myWork/org/vue/v_box.html)，想象力再丰富也比不上直接拖拖拽拽看效果来的快。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.tab{
    position:relative;
    display:inline-block;
    padding-right:8px;
    padding-left:8px;
    margin-right:25px;
    text-align:center;
}&lt;/p&gt;

&lt;p&gt;.tab::before{
    z-index:-1;
    content:&amp;ldquo;;
    position:absolute;
    top:0;
    left:-10px;
    right:-10px;
    bottom:0;
    width:100%;
    height:0;
    border-style:solid;
    border-width:0 10px 18px 10px;
    border-color:transparent transparent yellowgreen transparent;
}
```&lt;/p&gt;

&lt;p&gt;这样也可以实现梯形标签。其实如果浏览器支持嵌套伪元素这个问题就更好解决了。不知道那时候那群玩one div的会搞出什么来。&lt;/p&gt;

&lt;p&gt;先写到这里吧，以后在实践中如果有用到的再补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongoDB的增删查改</title>
      <link>http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/</link>
      <pubDate>Fri, 27 May 2016 20:42:40 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/</guid>
      <description>

&lt;p&gt;mongoDB的增删查改&lt;/p&gt;

&lt;h2 id=&#34;基本概念:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;mongoDB以document的形式存储数据，document类似于编程语言中的键值对的形式。document的集合成为collection，类似于一些数据库中表的概念。&lt;/p&gt;

&lt;p&gt;一下代码中均以users作为表名&lt;/p&gt;

&lt;h2 id=&#34;插入数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;插入数据&lt;/h2&gt;

&lt;h4 id=&#34;插入一条记录:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;插入一条记录&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.insert({name:&#39;jsmeta&#39;,&#39;age&#39;:23})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mongoDB的一个好处是自动生成_id,并且全局唯一。还有一个好处是有些字段可以没有值。&lt;/p&gt;

&lt;p&gt;再插入一条记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.insert({name:&#39;jsmeta2&#39;,gender:&#39;male&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在插入第一条记录时，已经有了 name 和 age两个字段名，如果是在mysql中，再插入一条信息除非设置默认值或者自增长，其他所有字段都要赋值，但是在mongodb中，并不需要都赋值，空着也可以。&lt;/p&gt;

&lt;p&gt;插完这两条记录数据库的结果是这样的：&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/insert0.jpg&#34; alt=&#34;insert&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;插入多条数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;插入多条数据&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.insert([{name:&#39;xiaoming&#39;,age:33,money:12345},{name:&#39;nobida&#39;,tech:[&#39;html&#39;,&#39;css&#39;,&#39;javascript&#39;]}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与插入一条记录很类似，只是将记录用一个数组组合。&lt;/p&gt;

&lt;p&gt;从上面的代码可以看出，mongoDB可以存一个array，这就有点意思了。在mysql中，对于上面的信息，我们可能需要拆除一张表来表明一个人会的技能，但是在mongoDB里直接存一个array就好了，顿时感觉省事多了。&lt;/p&gt;

&lt;h2 id=&#34;查找数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;查找数据&lt;/h2&gt;

&lt;h4 id=&#34;查找全部的记录:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;查找全部的记录&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以简写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而正常情况下是用不到把整张表都拿出来的&lt;/p&gt;

&lt;h4 id=&#34;相等条件:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;相等条件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({name:&#39;jsmeta&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({name:&#39;jsmeta&#39;,age:10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询名称为jsmeta且年龄为10的&lt;/p&gt;

&lt;h4 id=&#34;常见运算符:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;常见运算符&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({age:{$gte:10,$lte:30}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面筛选的是用户年龄大于等于10且小于等于30的&lt;/p&gt;

&lt;p&gt;常见的运算符还有 $gt、$lt、$ne、$in、$nin&lt;/p&gt;

&lt;h4 id=&#34;or:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;or&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({$or:[{age:{$gte:10,$lte:30}},{gender:&#39;male&#39;}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码筛选出年龄大于等于10小于等于30或者性别为男的用户&lt;/p&gt;

&lt;h4 id=&#34;查询数组:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;查询数组&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({tech:&#39;html&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tech字段存的是一个数组，上面的代码筛选出数组中含有&amp;rsquo;html&amp;rsquo;的document&lt;/p&gt;

&lt;p&gt;如果想限制的更严格一点，比如数组中第一个元素为&amp;rsquo;html&amp;rsquo;的，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({&#39;tech.0&#39;:&#39;html&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mongoDB中存的array是一个有序array&lt;/p&gt;

&lt;h2 id=&#34;改数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;改数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.users.update({&#39;name&#39;:&#39;jsmeta&#39;},{$set:{age:55,gender:&#39;female&#39;,tech:[&#39;php&#39;,&#39;mongodb&#39;,&#39;javascript&#39;]}},{multi:true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数是筛选条件，第二个参数是含义是把 age设为55 把gender设为female 把tech设为[&amp;lsquo;php&amp;rsquo;,&amp;lsquo;mongodb&amp;rsquo;,&amp;lsquo;javascript&amp;rsquo;]，最后一个参数的意思是更新多条数据&lt;/p&gt;

&lt;h2 id=&#34;删除数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;删除数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.users.remove({age:33},1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的意思是删除age字段值为33的记录，并且只删一条。第二参数可选，如果不传，则删除全部满足条件的数据&lt;/p&gt;

&lt;h2 id=&#34;limit与skip:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;limit与skip&lt;/h2&gt;

&lt;p&gt;limit和skip最常用于分页&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({}).limit(1).skip(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样跳过一条限制查询结果只有一条，得到的是第二条，对于写代码的明明是第一条&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最近在做什么</title>
      <link>http://jiangshanmeta.github.io/post/blog/blog1/</link>
      <pubDate>Thu, 26 May 2016 21:09:38 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/blog1/</guid>
      <description>&lt;p&gt;最近在忙些什么呢？忙着抄别人的APP。基本需求是做一个导购类型的小东西。&lt;/p&gt;

&lt;p&gt;为什么要做这个东西呢？是为了统计顾客对什么感兴趣然后为店面采购提供依据同时引流，所以虽然是导购性质并不指望从拿到返点之类的。&lt;/p&gt;

&lt;p&gt;明确了想要干什么那就去分解问题逐步实现。&lt;/p&gt;

&lt;p&gt;我们想统计用户对什么商品感兴趣，需要用户看到一些商品然后标记为感兴趣。用户把某件商品标记为感兴趣其实从代码角度不难实现，我甚至觉得这里没什么可说的。那么问题就变成了用户需要看到商品。&lt;/p&gt;

&lt;p&gt;商品信息从哪里来？可以找编辑一个一个输入啊。同时我们也希望用户参与发布推荐商品这一环节，群众的力量是无穷的。对于自己的编辑我们可以让他各种敲键盘输入，然而对于用户呢？并且这个需求最初定位为在微信公众号里推广，在手机上输入大量文字，用户会陪你玩？&lt;/p&gt;

&lt;p&gt;所以我们需要找到让用户在手机上能轻松分享商品的方法。顺便说一句，这里的商品是来自淘宝之类的电商的。我们可以让用户输入url然后后台分析商品信息。后台分析url然后解析出商品的名称价格等信息其实不难实现，最终的实现是借助于&lt;a href=&#34;https://github.com/samacs/simple_html_dom&#34;&gt;一个第三方库&lt;/a&gt;，然而，你确定用户知道url是什么吗？你上大街上随便找100个人问问有几个知道url的。而且在手机上敲url，你真的不觉得这个想法有点疯狂吗？&lt;/p&gt;

&lt;p&gt;降低用户的发布门槛是很重要的，否则用户主动参与的少，编辑工作也很大。最好能提供一个按钮让用户能一点我们我们就获得url，然后处理数据，对用户来说门槛很低了。&lt;/p&gt;

&lt;p&gt;从技术角度上，我们想利用iframe进行跨域拿到某宝的页面，用户在某宝搜索找到想要的商品点个按钮我们获取url，交给后台分析，然后返回分析结果给前台。非常不幸的是由于浏览器安全限制我们是不可能拿到某宝某个具体商品的url的。&lt;/p&gt;

&lt;p&gt;问题分析了这么久，想降低用户门槛的尝试以失败告终，最终要劳驾我们的编辑同学了。不过，编辑同学也不用太累啊，在电脑上把url复制粘贴后台就处理的差不多了啊//大量重复行劳动除外。&lt;/p&gt;

&lt;p&gt;其实还有一个没有很好解决的问题，页面上有些东西是后来用js写上去的，相应的内容是很难分析的。&lt;/p&gt;

&lt;p&gt;还有一块内容想做的是评论系统。感觉是再做一个贴吧。&lt;/p&gt;

&lt;p&gt;好吧，我抄的APP是半糖，然后我已经忍不住买买买了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前端需要知道的WEB知识（1）</title>
      <link>http://jiangshanmeta.github.io/post/browser1/</link>
      <pubDate>Mon, 23 May 2016 21:49:52 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/browser1/</guid>
      <description>&lt;p&gt;之前无意间触发了一个bug，让我开始接触浏览器相关的知识。搞web开发的如果不了解浏览器的基本知识，不了解一个网页是如何形成的，以及如何展示的，基本上也就到天花板了。&lt;/p&gt;

&lt;p&gt;今天并不想从发起一个http请求开始讲起，战线会拉的太长。就从web服务器返回页面开始讲起吧。&lt;/p&gt;

&lt;p&gt;浏览器接收到服务器返回的HTML，开始按顺序进行解析，先是head部分，再是body部分。&lt;/p&gt;

&lt;p&gt;在head部分，可能会遇到&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;,会发起相应的http请求对应的文件，在相应的文件下载之后，渲染才会继续进行，在这一段期间浏览器的状态是一片白。一些常见的web优化就是根据这个原因进行的。比如对CSS文件和JS文件进行压缩，这样可以减少请求文件的体积，从而减少传输时间。又比如CSS文件或者JS文件该合并的进行合并，这样可以减少http请求，而http请求会带来额外的开销。还有是一些js文件从head中移除，放到body中，这样可以先让用户看点东西，不至于一片白然后一怒之下关网页。&lt;/p&gt;

&lt;p&gt;然后就是解析body进行渲染了。这里我想借助一幅图说明&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/browser.png&#34; alt=&#34;浏览器渲染原理&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简单来说就是HTML解析器生成DOM，CSS解析器生成CSSOM，然后层叠，布局绘制，最终展示成为我们所看到的页面。&lt;/p&gt;

&lt;p&gt;再上张图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/browser2.png&#34; alt=&#34;浏览器渲染原理&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中大部分的工作对于web开发者来说都是不可控的，只有控制DOM和并不好用的样式操作对web开发者是可控的，其余的都是只能按照规则来。然而&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20939640&#34;&gt;知乎上有篇文章指出这一现状可能会被改善&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然绘制的过程目前是无法控制只能看浏览器心情，有些基本概念还是要了解的。&lt;/p&gt;

&lt;p&gt;当DOM的变化影响了元素的几何属性，浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会受到影响。浏览器会使渲染树的受到影响的部分失效，并重新构造渲染树。这个过程称为&lt;strong&gt;重排(reflow)&lt;/strong&gt;。完成重排后，浏览器会重新绘制受到影响的部分到屏幕中，这个过程称为&lt;strong&gt;重绘(repaint)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;显然，重排一定会导致重绘，重绘却不一定意味着重排。从前端性能优化的角度来看，我们需要尽可能减少重绘重排这样昂贵的操作。从CSS的角度上来讲，似乎能做的不多，我能想到的是利用&lt;code&gt;outline&lt;/code&gt;或者&lt;code&gt;box-shadow&lt;/code&gt;这样不影响元素几何属性的属性模拟一些几何属性，比如边框，不能减少重绘但是能减少重排。可能说的不太明白，还是上代码吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.box{
	width:300px;
	margin-left:20px;
}
.box:hover{
	border:1px solid #ccc;
	margin-left:19px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将CSS优化成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.box{
	width:300px;
	margin-left:20px;
}
.box:hover{
	outline:1px solid #ccc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js部分减少重绘重排能做的就比较多了。&lt;/p&gt;

&lt;p&gt;1.缓存布局信息，减少对布局信息的请求。可能会有人问了，难道对布局信息请求会强制重绘？我想引用*高性能JavaScript*中的一段话回答&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。然而，你可能会（经常不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.批量处理样式操作。利用cssText属性可以合并一些操作。如果可以通过添加类名改变样式的话尽可能控制类名而不是具体的style。&lt;/p&gt;

&lt;p&gt;3.利用documentFragment优化。这个我现在用的不多。&lt;/p&gt;

&lt;p&gt;4.还有搞前端最喜欢玩的，能用CSS实现的就不要用JS。不细说，自己体会。&lt;/p&gt;

&lt;p&gt;从浏览器的重绘重排扯到了前端性能优化，我觉得还是扯回来吧&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;http://jiangshanmeta.github.io/post/browser/&#34;&gt;上篇文章&lt;/a&gt;中，我提到了线程问题。当时找的资料有点杂，我觉得还是引用一些书籍上的话加深理解吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;大多数浏览器让一个单线程共用于执行javascript和更新用户界面。每个时刻只能执行其中一种操作，这意味着当javascript代码正在执行时用户界面无法相应输入，反之亦然。当javascri代码执行时，用户界面处于“锁定”状态。&lt;/p&gt;

&lt;p&gt;用于执行javascript和更新用户界面的进程通常被称为“浏览器UI线程”。UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提出来并运行。这些任务要么是运行javascript代码，要么是执行UI更新，包括重绘和重排。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>一个bug引发的血案—浏览器基本渲染</title>
      <link>http://jiangshanmeta.github.io/post/browser/</link>
      <pubDate>Sun, 22 May 2016 17:05:41 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/browser/</guid>
      <description>&lt;p&gt;作为全知乎写bug水平第0的人，最近我又写了一个bug。&lt;/p&gt;

&lt;p&gt;当时的需求是这样的：用js和CSS3画一个时钟，能动的那种。很早很早之前，我用&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/canvas/canvasWatch.html&#34;&gt;canvas实现过这个需求&lt;/a&gt;,然而canvas毕竟需要各种写js，而且实现上也需要大量的计算，于是我就想能不能用尽可能少的js结合CSS实现。&lt;/p&gt;

&lt;p&gt;于是开始分解问题，我想实现的时钟和本地时间相对应，无论如何都要把Date对象拿出来然后求出当前的时分秒，然后进行初始偏转，再利用web动画进行转动即可，三个指针虽然在实际生活上有联系，但是把这三个割裂开会降低复杂度。只要求出当时的秒数，然后画出秒针的动画，99%的工作就完成了，时针和分针的效果只需要复制粘贴就能解决。&lt;/p&gt;

&lt;p&gt;HTML是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;clock-wrap&amp;quot; id=&amp;quot;clock-wrap&amp;quot;&amp;gt;
	&amp;lt;div class=&amp;quot;second&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.clock-wrap{
	width:300px;
	height:300px;
	border-radius:50%;
	background-color:#f1f1f1;
	position:relative;
}
.second{
	position:absolute;
	width:4px;
	height:40%;
	top:10%;
	left:calc(50% - 2px);
	transform-origin:bottom center;
	transition:all 60s linear;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就出现了基本的时钟的样子了，剩下的就是写js了。然而，当时着急去洗澡，于是写下了bug。我试着回忆当时的思路，然而我觉得当时自己脑子里已经进了水。当时想的是根据当前时间算出初始偏离角度，写一条样式，然后根据初始偏移角度算出最终角度，写一条过渡后的样式，然后添加类名，利用类名触发过渡。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function cssclock(wrapId){
	var time = new Date();
	var s = time.getSeconds();

	var sDOM = document.getElementById(&amp;quot;second&amp;quot;);
	var wrap = document.getElementById(wrapId);
	var style = document.createElement(&amp;quot;style&amp;quot;);
	var str = &amp;quot;&amp;quot;;
	str += &amp;quot;.second{transform:rotate(&amp;quot;+  6*s +&amp;quot;deg)}&amp;quot;;
	str += &amp;quot;.go .second{ transform:rotate(&amp;quot; + (6*s+360) + &amp;quot;deg)}&amp;quot;;
	style.innerHTML = str;
	document.head.appendChild(style);
	wrap.classList.add(&amp;quot;go&amp;quot;);
}
cssclock(&amp;quot;clockwrap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然是有bug的，按照这个思路实现根本不会有过渡效果，就算有也只是转一圈。转一圈很好理解，这是我脑子里进水了整个思路错了，然而为什么根本没有过渡呢？&lt;/p&gt;

&lt;p&gt;看控制台那里秒针样式秒针的转动的值直接是最终值，于是我便百思不得其解了。后来尝试着把最后一行给表的盒子加上类名去掉，然后在控制台手动给这个盒子加上类名，发现可以触发过渡。&lt;/p&gt;

&lt;p&gt;于是我就脑洞大开了，难道是要在添加样式表完成的回调里执行给盒子添加类名的操作，然而appendChild没有回调啊，那干脆加个定时器过一会再加类名好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setTimeout(function(){
 	document.getElementById(wrapId).classList.add(&amp;quot;go&amp;quot;);
},0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实践证明确实是可行的，然而诡异的事情又来了：当我把定时器的时间设为 &lt;strong&gt;0&lt;/strong&gt; 依然可以触发过渡，于是我就不明觉厉了。&lt;/p&gt;

&lt;p&gt;然后我想起来之前看到的&lt;a href=&#34;https://github.com/gomeplusFED/blog/blob/master/2016-04/do-you-really-understand-how-to-write-a-countdown-by-javascript.md&#34;&gt;关于定时器的文章&lt;/a&gt;,里面谈到了js的线程问题，于是我便顺着这条线索开始找。&lt;/p&gt;

&lt;p&gt;中间的曲折没什么意思，还是说结论吧。&lt;/p&gt;

&lt;p&gt;因为浏览器内部有多个线程，比如负责画页面的线程，比如处理js的线程。画页面的线程 GUI渲染线程大体上是以每秒60次的速度工作的，这就是定时器常见的 16.7ms （1000/60）的由来,然而，渲染线程和js引擎线程是互斥的，这是为什么呢？因为js很有可能对DOM操作，这期间免不了获取一些渲染上的属性，比如width之类的，如果两个一起工作，js获取的就可能不准，所以两者是互斥的。&lt;/p&gt;

&lt;p&gt;我上面的js代码里，将新的样式添加进去，我本来是期望秒针按照&lt;code&gt;.second&lt;/code&gt;类的样式进行渲染，然后给盒子加上&lt;code&gt;.go&lt;/code&gt;这一个类，触发过渡。但是按照上面的分析，直到js结束都没有进行页面的渲染，js结束后整个盒子已经加上了&lt;code&gt;.go&lt;/code&gt;类，渲染开始，因为已经存在&lt;code&gt;.go&lt;/code&gt;类了，渲染按照过渡结束的进行。&lt;/p&gt;

&lt;p&gt;那么我用的定时器是起到什么作用？定时器设定时间为0，并不是立即去做，而是在0ms之后加入到js的todo队列中，也就是说添加完样式表后，js暂时休息，之前本应该干活但因为js干活而休息的GUI渲染开始工作，进行初始偏移，js的队列里出现定时器中要运行的代码，进行添加类名操作，触发过渡。&lt;/p&gt;

&lt;p&gt;那有没什么办法在js里强制渲染一次再进行后续操作呢？有啊，比如说取一个宽度就能强制渲染一次，这是定时器方案的一个替代方案。这也是为什么用js做动画要缓存一些变量的原因，为了减少不必要的重绘重排。以前too young，too simple啊，还需要提高知识水平。&lt;/p&gt;

&lt;p&gt;语文不太好，引用别人的话总结一下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。&lt;/li&gt;
&lt;li&gt;GUI渲染线程负责渲染浏览器界面，当界面需要重绘（repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。&lt;/li&gt;
&lt;li&gt;事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;扯了这么多也没有写到最开始的需求该如何实现，反正实现了，用了些最近学到的技巧，然而这个bug让我学到的更多，毕竟前端不仅仅是写写页面写写js，浏览器的工作原理也要理解一些的。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>居中的常见实现</title>
      <link>http://jiangshanmeta.github.io/post/center/</link>
      <pubDate>Mon, 16 May 2016 21:26:45 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/center/</guid>
      <description>

&lt;p&gt;约定HTML结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div &amp;gt;
	&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-水平居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;1.水平居中&lt;/h2&gt;

&lt;p&gt;实现水平居中其实并不难，而且有多个可靠地方案可以使用。&lt;/p&gt;

&lt;h4 id=&#34;margin方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;margin方案&lt;/h4&gt;

&lt;p&gt;用过bootstrap的人会很熟悉这么一个类名&lt;code&gt;.center-block&lt;/code&gt;，这是实现居中的一个类名，具体实现是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-block{
	display:block;
	margin-left:auto;
	margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这应该是学习页面布局最基本的水平居中方案了，也没什么额外操作&lt;/p&gt;

&lt;h4 id=&#34;绝对定位方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;p&gt;基本实现是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-x-ab{
	position:absolute;
	left:50%;
	transform:translateX(-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是应用了translate如果值为百分比，则参考于自身。如果为了水平居中而这么做就有点折腾了，然而这一方案可以扩展到垂直居中和水平垂直都居中。这样做的缺点是父元素需要处理子元素绝对定位带来的问题。在实践中，制作h5页面慎用这种方法居中，因为h5页面经常有动画，动画离不开transform,两者同时存在会看到很诡异的问题。&lt;/p&gt;

&lt;h4 id=&#34;文本居中方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;文本居中方案&lt;/h4&gt;

&lt;p&gt;需要将要居中元素的父元素设定&lt;code&gt;text-align:center;&lt;/code&gt;需要居中的元素的display要设定为&lt;code&gt;inline-block&lt;/code&gt;,需要处理文本居中带来的影响，这一方案感觉用的不多。&lt;/p&gt;

&lt;h4 id=&#34;flex方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;1.你为什么不用margin方案的方案&lt;/p&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex&lt;/code&gt; 子元素img&lt;code&gt;margin-left:auto;margin-right:auto;&lt;/code&gt;我的评价见小标题&lt;/p&gt;

&lt;p&gt;2.感觉有点大材小用的方案&lt;/p&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex:justify-content:center;&lt;/code&gt;评价如小标题
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/animation/animation_spin.html&#34;&gt;上个例子&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-垂直居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;2.垂直居中&lt;/h2&gt;

&lt;p&gt;相较于水平居中，垂直居中相比较而言就有点难度了&lt;/p&gt;

&lt;h4 id=&#34;单行文字垂直居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;单行文字垂直居中&lt;/h4&gt;

&lt;p&gt;在我刚开始学习写页面的时候，就听说过让&lt;strong&gt;line-height&lt;/strong&gt;和&lt;strong&gt;height&lt;/strong&gt;值相等即可使单行文字垂直居中，最开始只是从使用的角度看这个问题，没有深入思考过，后来&lt;a href=&#34;http://t.imooc.com/learn/403&#34;&gt;张鑫旭大神告诉我们&lt;/a&gt;，这只是伪垂直居中。从工程实践角度这已经够用了，不要在意这些细节&lt;/p&gt;

&lt;h4 id=&#34;绝对定位方案-1:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;p&gt;在水平居中中提到可以使用绝对定位实现水平居中，同样也可以使用绝对定位实现垂直居中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-y-ab{
	position:absolute;
	left:50%;
	transform:translateY(-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然要处理绝对定位带来的后果，考虑到垂直居中方案并不多，这不失为一个好方案。&lt;/p&gt;

&lt;h4 id=&#34;table方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;table方案&lt;/h4&gt;

&lt;p&gt;请参阅&lt;a href=&#34;https://css-tricks.com/centering-in-the-unknown/&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;flex方案-1:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex&lt;/code&gt; 子元素img&lt;code&gt;margin-top:auto;margin-right:bottom;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然你也可以折腾flex的相关属性去，说的就是某些关于对其的属性。&lt;/p&gt;

&lt;h2 id=&#34;3-水平垂直都居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;3.水平垂直都居中&lt;/h2&gt;

&lt;h4 id=&#34;绝对定位方案-2:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-xy-ab{
	position:absolute;
	top:50%;
	left:50%;
	transform:translate(-50%,-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有代码有真相，就是结合水平、垂直居中的绝对定位方案&lt;/p&gt;

&lt;h4 id=&#34;flex方案-2:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;父元素&lt;code&gt;display:flex;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;子元素&lt;code&gt;margin:auto;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也不用去折腾各种对齐的属性&lt;/p&gt;

&lt;h4 id=&#34;水平文本居中-垂直table-的大杂烩:903435e3d66e261bf87738ad6f965a5c&#34;&gt;水平文本居中 + 垂直table 的大杂烩&lt;/h4&gt;

&lt;p&gt;如果真考虑兼容性的话，这似乎是兼容性最好的方案了
然而，需要多写一层标签&lt;/p&gt;

&lt;p&gt;水平垂直居中算是水平居中和垂直居中的综合使用，上个&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/center.html&#34;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-基于视口的居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;4.基于视口的居中&lt;/h2&gt;

&lt;p&gt;常见的各种模态框基本上是相较于视口水平垂直居中的，其实我最早知道模态框的实现的时候它的居中是通过js计算得到的。作为 &lt;em&gt;能用CSS实现的就绝对不用js实现&lt;/em&gt; 神教教徒，这个需求肯定要尝试使用CSS解决。&lt;/p&gt;

&lt;h4 id=&#34;transform方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;transform方案&lt;/h4&gt;

&lt;p&gt;基本上是上边的绝对定位方案的翻版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position:fixed;
top:50%;
left:50%;
transform:translate(-50%,-50%);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相关&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/center/center.css&#34;&gt;CSS下载&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>伪元素的应用总结</title>
      <link>http://jiangshanmeta.github.io/post/pseudo/</link>
      <pubDate>Mon, 16 May 2016 20:00:31 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/pseudo/</guid>
      <description>

&lt;dl&gt;
&lt;dt&gt;CSS中的伪元素CSS中经常能玩出花样的东西，它包括::first-letter、::first-line、::before、::after、::selection,作为强迫症晚期患者我觉得还应该出现::last-letter和::last-line，然而并没有，我很伤心。&lt;/dt&gt;
&lt;/dl&gt;

&lt;p&gt;::first-letter、::first-line、::selection通常是用来对文字进行装饰，比如::first-letter实现首字母下沉效果,::selection实现萌娘百科的黑幕效果，目前我还没发现这三个能玩出太大的花样。这里主要总结::before和::after两个伪元素的花样。一直在纠结如何整理这些东西，最后还是决定按照表现分类，毕竟CSS关系的是样式。&lt;/p&gt;

&lt;h2 id=&#34;clearfix:dc5e44b284002f2c33b84936afab53a1&#34;&gt;clearfix&lt;/h2&gt;

&lt;p&gt;写过几个网页的人就会知道clearfix，毕竟是布局相关的东西，实现起来有不少，经典的是&lt;code&gt;.clearfix::after{content:&#39;&#39;;display:table;clear:both;}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;字体图标:dc5e44b284002f2c33b84936afab53a1&#34;&gt;字体图标&lt;/h2&gt;

&lt;p&gt;网页上的小图标是很常见的设计，通常的实现方案有图片和字体图标两种，作为并不喜欢切图的我显然更倾向于使用字体图标这种方式。目前用过的字体图标有&lt;a href=&#34;http://v3.bootcss.com/components/#glyphicons-glyphs&#34;&gt;bootstrap&lt;/a&gt;里面自带的，还有&lt;a href=&#34;http://fontawesome.dashgame.com/&#34;&gt;font-awesome&lt;/a&gt;两个，基本能满足需求，如果不能满足请说服美术。&lt;/p&gt;

&lt;h2 id=&#34;一条线:dc5e44b284002f2c33b84936afab53a1&#34;&gt;一条线&lt;/h2&gt;

&lt;p&gt;为了一条线写一个标签通常来说是很不划算的，除非你很爱敲键盘。
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/cateList/cateList.html&#34;&gt;我之前写的一个分类列表&lt;/a&gt;这里结合使用了:checked伪类和::after伪元素，实现了无JS的tab切换效果。&lt;/p&gt;

&lt;p&gt;之前也见过在tab切换中，使用::after伪元素画一条线表示当前tab的。&lt;/p&gt;

&lt;p&gt;在bootstrap里的面包屑导航里，也采用了::before伪元素做一条分割线。&lt;/p&gt;

&lt;p&gt;还有见过走马灯效果里，用::after做分割的。然而最近没怎么见过走马灯效果了，这个设计目测已经过气了。&lt;/p&gt;

&lt;h2 id=&#34;背景图形:dc5e44b284002f2c33b84936afab53a1&#34;&gt;背景图形&lt;/h2&gt;

&lt;h4 id=&#34;模拟多背景-实现多重边框:dc5e44b284002f2c33b84936afab53a1&#34;&gt;模拟多背景、实现多重边框&lt;/h4&gt;

&lt;p&gt;在多背景支持性还不够好的时候，就有人试图用&lt;a href=&#34;http://nicolasgallagher.com/multiple-backgrounds-and-borders-with-css2/&#34;&gt;::before和::after来实现多背景&lt;/a&gt;。这项技术其实已经有点老了，然而其中提到的&lt;strong&gt;用伪元素实现多边框&lt;/strong&gt;依然具有实战意义。&lt;/p&gt;

&lt;h4 id=&#34;阴影效果:dc5e44b284002f2c33b84936afab53a1&#34;&gt;阴影效果&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://t.imooc.com/learn/240&#34;&gt;CSS3实现“图片阴影”效果&lt;/a&gt;,给慕课网打个广告吧。如果对阴影效果扩展一下，就可以模拟弹出层的背景。&lt;/p&gt;

&lt;h4 id=&#34;边框内圆角:dc5e44b284002f2c33b84936afab53a1&#34;&gt;边框内圆角&lt;/h4&gt;

&lt;p&gt;这一效果是在*CSS Secrets*一书中看到的，基本原理是border-radius+定位+z-index。&lt;/p&gt;

&lt;h4 id=&#34;各种图形:dc5e44b284002f2c33b84936afab53a1&#34;&gt;各种图形&lt;/h4&gt;

&lt;p&gt;之前的日志中，我利用::before实现了&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;自适应的正方形&lt;/a&gt;,同时这一原理也可以用来实现长宽比一定的矩形。&lt;/p&gt;

&lt;p&gt;伪元素实现三角形早就成为前端的必备技能了，不细说了。&lt;/p&gt;

&lt;p&gt;在三角形的基础上也能实现其他的图形，&lt;em&gt;CSS Secrets&lt;/em&gt; 一书中提到了如何使用伪元素实现平行四边形和菱形，主要利用了transform+绝对定位。&lt;/p&gt;

&lt;p&gt;更多的图形可以参见 &lt;a href=&#34;https://css-tricks.com/examples/ShapesOfCSS/&#34;&gt;css tricks&lt;/a&gt;,然而我觉得很多只是做着玩而不能在生产环境下使用。&lt;/p&gt;

&lt;h2 id=&#34;扩大响应区域:dc5e44b284002f2c33b84936afab53a1&#34;&gt;扩大响应区域&lt;/h2&gt;

&lt;p&gt;其实这也不算是样式了，已经是交互部分了。伪元素结合定位就可以扩展原来元素的相应区域，结合:hover伪类应该能做出一些东西，目前没见过眼前一亮的例子&lt;/p&gt;

&lt;h2 id=&#34;模拟float-center:dc5e44b284002f2c33b84936afab53a1&#34;&gt;模拟float:center&lt;/h2&gt;

&lt;p&gt;浮动其实是没有center这一值的，但是一个居中的文字环绕效果确实挺漂亮。别人的&lt;a href=&#34;https://css-tricks.com/float-center/&#34;&gt;demo&lt;/a&gt;,使用具有一定宽度和高度的伪元素浮动占据位置，再用绝对定位把图片定位到伪元素占据的地方。这个效果我觉得很有创意。&lt;/p&gt;

&lt;p&gt;伪元素能做的东西很多，然而自己接触的还比较少，上面所说的就是我目前所见到的。其实结合:hover伪类，:checked伪类，以及transition和animation，是可以做一些小东西出来的，至少可以取代一些用js才能写出来的效果。以后看到效果试着能否只是用CSS实现。&lt;/p&gt;

&lt;p&gt;update 2016/05/19
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/dopant/cssclock/cssclock.html&#34;&gt;使用伪元素结合CSS3动画做的时钟&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/05/29
&lt;a href=&#34;http://jiangshanmeta.github.io/post/cssshape/&#34;&gt;使用伪元素结合border实现彩色环和梯形&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>你真的会用CSS画写正方形吗？</title>
      <link>http://jiangshanmeta.github.io/post/autosquare/</link>
      <pubDate>Sat, 14 May 2016 11:26:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/autosquare/</guid>
      <description>

&lt;p&gt;用CSS写一个正方形，对于前端工作者来说是一个再常见不过的需求了，通常情况下，你可能会写出这样的代码：&lt;code&gt;width:200px;height:200px;&lt;/code&gt; 这是最简单的实现了，然而，如果我想要一个300px的正方形呢？或许你会写出如下代码：&lt;code&gt;width:300px;height:300px;&lt;/code&gt; 。那么，如果我想要一个400px的正方形呢？你可能会写出以下代码：&lt;code&gt;width:400px;height:400px;&lt;/code&gt; 同时开始准备和产品以及美术来一场大战。&lt;/p&gt;

&lt;p&gt;显然，一个爱敲键盘的程序员不是好程序员，想偷懒就要对上面的需求进行抽象，然后脑洞大开。上面的需求可以抽象为如何写一个自适应的正方形，这一点其实没什么问题。&lt;/p&gt;

&lt;h2 id=&#34;脑洞大开时间:e010fd746b92c0785d41a89ff0373934&#34;&gt;脑洞大开时间&lt;/h2&gt;

&lt;p&gt;CSS经常被一些大神认为不是一种编程语言，然而，我们可以假装CSS是一门编程语言，就像我可以假装自己有女朋友一样。好了，现在CSS是一门编程语言了，那它会有什么？ &lt;strong&gt;this&lt;/strong&gt;，&lt;strong&gt;this&lt;/strong&gt;，&lt;strong&gt;this&lt;/strong&gt;，一门编程语言没有this你还怎么面向对象编程。如果CSS有this的话，这里就可以这么写了&lt;code&gt;height:this.width&lt;/code&gt;,感觉上挺自然的，以后写CSS会不会要求OOP风格？&lt;/p&gt;

&lt;p&gt;然而，CSS并不支持this，所以脑洞时间结束了，回归现实世界吧&lt;/p&gt;

&lt;h2 id=&#34;回归正常前的瞎折腾阶段:e010fd746b92c0785d41a89ff0373934&#34;&gt;回归正常前的瞎折腾阶段&lt;/h2&gt;

&lt;p&gt;在CSS中，有一些相对单位，比如em，rem，vw，vh之类的，能否用这些做点尝试。&lt;/p&gt;

&lt;p&gt;比如，一个div，宽度是50vw，那么高度也是50vw就好了，算是一种自适应的正方形的实现方案吧。然而，宽高都要基于视口，稍微复杂点的场景就解决不了了，比如，这个div的宽度根本就不是根据视口来的你想怎么办。vw和vh的解决方案由于不够健壮而排出，em 、rem的实现也类似，宽度和高度都要写死 是多少rem/em，大家都有同样的问题，所以也排除了。&lt;/p&gt;

&lt;h2 id=&#34;咦-为什么一定要纠结于设定高度呢:e010fd746b92c0785d41a89ff0373934&#34;&gt;咦，为什么一定要纠结于设定高度呢？&lt;/h2&gt;

&lt;p&gt;对啊，需求是写一个自适应的正方形，谁说一定要在height上折腾，比如，可以用padding撑开这个盒子啊。这一要说一点知识性的东西了，padding值如果取值为百分比，则该百分比是相对于父元素的宽度进行计算的，比那个height的百分比不知道高到哪里去了（height的百分比是相较于父元素的高度的），所以以下代码就可以实现一个响应式的正方形&lt;code&gt;width:25%;padding-bottom:25%;&lt;/code&gt;然而还不够优雅，还是要针对不同的场景写不同的padding-bottom。&lt;/p&gt;

&lt;p&gt;给大家安利一本我最近在看的书 &lt;strong&gt;CSS Secrets&lt;/strong&gt;，其中讲到伪元素能做很多事情。那这里伪元素能做什么呢？伪元素如果是块级元素，其宽度就是父元素宽度（不考虑padding和border），那么伪元素的padding如果为百分比，就是参考于我们正在处理的这个盒子，所以我们有了阶段性的成果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.auto-square::before{
	content:&#39;&#39;;
	display:block;
	padding-bottom:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是一个自适应的正方形就这么写出来了&lt;/p&gt;

&lt;p&gt;于是，又有新的需求的，还要填内容啊！！&lt;/p&gt;

&lt;h2 id=&#34;在自适应的正方形里如何填内容呢:e010fd746b92c0785d41a89ff0373934&#34;&gt;在自适应的正方形里如何填内容呢？&lt;/h2&gt;

&lt;p&gt;如果按照正常的流填什么内容都会破坏正方形的结构，所以我的解决方案是对内容进行绝对定位定位到正方形里。相应的，CSS代码也要加点东西&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.auto-square{
	position:relative;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实战:e010fd746b92c0785d41a89ff0373934&#34;&gt;实战&lt;/h2&gt;

&lt;p&gt;朋友圈里经常有人发个九连拍，每张图所在的盒子就是一个正方形。然而，朋友圈的图片是正方形缩略图，在自己的项目中还要拜托后端处理出一张缩略图来。想想自己也要写后端就觉得干脆用原图然后居中显示得了。&lt;/p&gt;

&lt;p&gt;下面是核心代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.auto-square{
	position:relative;
}
.auto-square::before{
	content:&#39;&#39;;
	display:block;
	padding-bottom:100%;
}
.center-ab{
	position:absolute;
	top:50%;
	left:50%;
	-webkit-transform:translate(-50%,-50%);
	-moz-transform:translate(-50%,-50%);
	-ms-transform:translate(-50%,-50%);
	-o-transform:translate(-50%,-50%);
	transform:translate(-50%,-50%);
}
.img-responsive{
	display:block;
	max-width:100%;
	max-height:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及一个&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/auto-square.html&#34;&gt;简单地实例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/5/16
想起来这一方法不仅仅能够实现正方形，也能实现长宽比一定的矩形&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>两列布局常见方法</title>
      <link>http://jiangshanmeta.github.io/post/twocolumn/</link>
      <pubDate>Thu, 12 May 2016 20:10:08 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/twocolumn/</guid>
      <description>

&lt;p&gt;画页面最开始要想好的就是如何进行布局。两列布局既是一种常见的布局方式，又是多列布局的基础。本文就我所熟悉的两列布局方式进行总结和比较。&lt;/p&gt;

&lt;h2 id=&#34;浮动布局:5a257f88feea4060d9c6a1cf42573807&#34;&gt;浮动布局&lt;/h2&gt;

&lt;p&gt;浮动最初是为文字环绕功能而设计的，然而现在成了基本的布局方式。&lt;/p&gt;

&lt;p&gt;熟悉bootstrap的人都知道，其经典的12列网格设计就是基于浮动所实现的。bootstrap的网格主要的知识点就是浮动+ &lt;code&gt;box-sizing:border-box&lt;/code&gt; + 媒体查询&lt;/p&gt;

&lt;p&gt;浮动所带来的问题是盒子的塌陷，bootstrap的网格布局解决方案是采取百分比进行限制。这样实现的是两列自适应布局，然而，要实现一列定宽一列自适应就比较困难了，所幸CSS支持计算，可以利用&lt;code&gt;calc&lt;/code&gt; 实现两列一列定宽一列自适应的两列布局&lt;/p&gt;

&lt;p&gt;bootstrap采用的是两列均左浮动实现两列布局，那么一列左浮动可不可以？当然可以。只要给右侧足够的&lt;code&gt;margin-left&lt;/code&gt;就行了。知乎首页人和问题的两列布局就是采用的这种布局方式。这种布局方式有什么问题呢？一是&lt;code&gt;margin-left&lt;/code&gt;值是要写死在代码里的，这一点其实还好，因为基本上大的布局不会变，所以基本上不会改。二是如果右侧有清除浮动的元素，会影响布局。当然对于知乎来说不存在这个问题，毕竟只是文字和图片。&lt;/p&gt;

&lt;p&gt;有什么方法解决上面说的第二个问题呢？对第二个列加上一行&lt;code&gt;overflow:hidden;&lt;/code&gt;就好了。原理是形成BFC然后自己就玩自己的去了。&lt;/p&gt;

&lt;h2 id=&#34;column:5a257f88feea4060d9c6a1cf42573807&#34;&gt;column&lt;/h2&gt;

&lt;p&gt;coolumn的出现是为了模仿报纸的排版的，如果想要实现文字的两列或者多列布局，应用column布局很轻松，然而，不幸的是，如果想要使用column布局的话，我建议还是放弃这个想法吧，一方面各大浏览器对其支持还不够，需要加私有前缀，另一方面其显示有些问题，具体可见&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/pic/waterfall/waterfall_CSS.html&#34;&gt;column实现的瀑布流效果&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;table:5a257f88feea4060d9c6a1cf42573807&#34;&gt;table&lt;/h2&gt;

&lt;p&gt;这里的table指的可不是HTML中的table，而是&lt;code&gt;display:table;&lt;/code&gt;利用table布局很容易实现两列布局，而且还能顺便实现等高布局。关于table的各种坑，我以后后做一个总结&lt;/p&gt;

&lt;h2 id=&#34;flex:5a257f88feea4060d9c6a1cf42573807&#34;&gt;flex&lt;/h2&gt;

&lt;p&gt;flex确实是布局神器，然而在生产环境下还是注意一下的好，移动端的情况稍微好点，然而在pc端IE10才支持，至少在pc端有替代方案的就用替代方案吧&lt;/p&gt;

&lt;h2 id=&#34;inline-block:5a257f88feea4060d9c6a1cf42573807&#34;&gt;inline-block&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;display:inline-block;&lt;/code&gt;确实是可以实现两列布局，如果两列宽度加起来不够父元素的宽度，那还好说，如果你想两个元素宽度均为50%,你很有可能会发现并没有实现。原因是两列之间有空格，两个50%加上一个空格显然超过100%。解决方案可以是通过那双灵巧的手，写HTML的时候注意空格，然而对于这种缩进会被不经意间手抖改掉，所以你还要写三遍注释告诉别人和自己不要手抖。这么干的人实在是太无聊了。靠谱点的解决方案是设定父元素&lt;code&gt;font-size:0;&lt;/code&gt;，然后两列字体大小该多少是多少，是个靠谱的解决方案。&lt;/p&gt;

&lt;p&gt;总结起来我个人倾向于各种基于浮动的方案。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>