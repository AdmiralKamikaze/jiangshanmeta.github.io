<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jsmeta</title>
    <link>http://jiangshanmeta.github.io/</link>
    <description>Recent content on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 05 Nov 2016 19:39:38 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>21天并不能精通CI</title>
      <link>http://jiangshanmeta.github.io/post/php/ci/</link>
      <pubDate>Sat, 05 Nov 2016 19:39:38 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/ci/</guid>
      <description>

&lt;p&gt;CI是一个MVC的php框架，平时使用的多了所以开始阅读其源码，在这里做个记录。&lt;/p&gt;

&lt;h2 id=&#34;整体流程:4148907b28e52bc7301c1249655cea8c&#34;&gt;整体流程&lt;/h2&gt;

&lt;p&gt;要了解一个框架，首先要做的就了解程序的流程。&lt;/p&gt;

&lt;p&gt;一般而言，我们请求的是index.php文件，在这个文件中主要定义了三个文件目录：CI系统文件目录、应用程序文件目录、界面层文件目录，然后加载了CodeIgniter.php这一文件，该文件规定了程序的主要逻辑。&lt;/p&gt;

&lt;p&gt;在CodeIgniter.php中，首先加载了一些定义好的工具全局函数和变量，然后是基准测试类、钩子类、Config类，到这里都是一些辅助性的东西，接下来的加载URI类和路由类，前者对请求的url进行各种处理得到各段参数，后者对URI类的处理结果根据路由规则进行处理，到这里我们拿到了controller名、method名以及参数。根据路由类的处理结果，我们拿到controller实例，并调用相应的方法（大部分工作就是实现controller里的各种方法），如果需要输出页面的话一般是通过Output类进行。&lt;/p&gt;

&lt;p&gt;基本流程就是这样，下面具体展开来看。&lt;/p&gt;

&lt;h2 id=&#34;index-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;index.php&lt;/h2&gt;

&lt;p&gt;这个文件是入口文件，虽然看起来有一堆代码，但是真正做的事情并不多。首先是定义当前环境，并且根据环境决定报错等级，然后定义了三个文件目录，分别是系统文件目录(&lt;code&gt;basepath&lt;/code&gt;)、应用代码文件目录(&lt;code&gt;APPPATH&lt;/code&gt;)和view层目录(&lt;code&gt;VIEWPATH&lt;/code&gt;)，大量操作都是用来校验目录合法性的，最后就是加载CodeIgniter.php这一文件。&lt;/p&gt;

&lt;h2 id=&#34;common-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Common.php&lt;/h2&gt;

&lt;p&gt;这个文件包含一些CI封装好的全局函数，先说一部分吧。&lt;/p&gt;

&lt;p&gt;1.&lt;code&gt;is_php&lt;/code&gt;是用来判断当前php版本的，其实就是对&lt;code&gt;version_compare&lt;/code&gt;这一系统函数的封装，不过在函数内部有一个静态局部变量&lt;code&gt;_is_php&lt;/code&gt;用来缓存判断的结果(js就只能默默地靠闭包实现这一功能)。&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;get_config&lt;/code&gt;主要是用来获取应用项目中的config文件并保存在静态局部变量&lt;code&gt;config&lt;/code&gt;中，还可以根据传入的值对&lt;code&gt;$config&lt;/code&gt;进行补充。&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;config_item&lt;/code&gt;是用来获取某个具体的配置的，在实现上首先有一个局部静态变量&lt;code&gt;_config&lt;/code&gt;，然后&lt;code&gt;$_config[0] =&amp;amp; get_config();&lt;/code&gt;，这样局部静态变量&lt;code&gt;_config&lt;/code&gt;保存了对config的引用，这里之所以用一个数组注释里说的很清楚：静态变量无法保存引用，所以用了数组。&lt;/p&gt;

&lt;p&gt;4.&lt;code&gt;load_class&lt;/code&gt;这个很重要，用来加载并且实例化一些系统类，由于CI扩展性强的特点，这里会判断有没有我们自行扩展的子类然后再实例化，实例化的类会缓存在一个静态局部变量中，用来实现单例。&lt;/p&gt;

&lt;p&gt;5.&lt;code&gt;is_loaded&lt;/code&gt;是和上面的&lt;code&gt;load_class&lt;/code&gt;函数配合使用的，用来追踪那些实例化的系统类的，这个函数一个是在&lt;code&gt;load_class&lt;/code&gt;中用到，还有是在controller的基类的构造函数使用，用来把实例化的系统类挂到controller上。&lt;/p&gt;

&lt;h2 id=&#34;benchmark-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Benchmark.php&lt;/h2&gt;

&lt;p&gt;Benchmark类是用来测试执行时间和使用内存的。&lt;/p&gt;

&lt;p&gt;对于内存的使用的测试Benckmark类仅仅是返回了一个特殊的字符串，然后在Output类中这个字符串被替换为真正的内存消耗。&lt;/p&gt;

&lt;p&gt;对于执行时间的测试原理其实很简单就是打时间戳。在CodeIgniter.php有几个默认的打时间戳的位置，比如Benchmark实例化成功后、controller的方法被调用后，对应打时间戳的方法是&lt;code&gt;mark&lt;/code&gt;，还有一个和测试时间有关的方法是&lt;code&gt;elapsed_time&lt;/code&gt;，它的作用是返回两点间的时间。既然是两个点，如果终点不传就返回起点到当前的时间，如果起点不传返回特殊字符串，经Output类处理最终是从开始运行CI到输出到浏览器的总时间。&lt;/p&gt;

&lt;h2 id=&#34;hooks-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Hooks.php&lt;/h2&gt;

&lt;p&gt;钩子为我们提供了在不改变核心代码的同时扩展核心代码的可能。对于Hooks类CI默认是禁用的，我们可以修改配置文件启用Hooks类。当启用时，会加载应用代码中的钩子函数。调用钩子函数时是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$EXT-&amp;gt;call_hook(&#39;pre_system&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还是看一下源代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function call_hook($which = &#39;&#39;)
{
  if ( ! $this-&amp;gt;enabled OR ! isset($this-&amp;gt;hooks[$which])){
	return FALSE;
  }

  if (is_array($this-&amp;gt;hooks[$which]) &amp;amp;&amp;amp; ! isset($this-&amp;gt;hooks[$which][&#39;function&#39;])){
	foreach ($this-&amp;gt;hooks[$which] as $val){
		$this-&amp;gt;_run_hook($val);
	}
  }else{
		$this-&amp;gt;_run_hook($this-&amp;gt;hooks[$which]);
  }

  return TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是判断有没有启用钩子、有没有在调用钩子函数的地方挂钩子，该退出的就退出。然后判断这个挂钩子的地方是挂了一个脚本还是多个脚本（一维数组还是二维数组），最终执行每一个脚本的是受保护的&lt;code&gt;_run_hook&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;这个&lt;code&gt;_run_hook&lt;/code&gt;方法支持的还是挺多的，支持匿名函数、支持调用已有实例的方法、支持面向过程的函数、也支持自行实例化一个类然后调用相应的方法（还实现了对这个实例的缓存）。&lt;/p&gt;

&lt;h2 id=&#34;config-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Config.php&lt;/h2&gt;

&lt;h2 id=&#34;controller-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Controller.php&lt;/h2&gt;

&lt;p&gt;虽然想按照执行顺序写但是还是先写Controller吧，毕竟controller是日常写的比较多的部分。controller的基类并不复杂：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CI_Controller {
	private static $instance;
	public function __construct()
	{
		self::$instance =&amp;amp; $this;
		foreach (is_loaded() as $var =&amp;gt; $class)
		{
			$this-&amp;gt;$var =&amp;amp; load_class($class);
		}

		$this-&amp;gt;load =&amp;amp; load_class(&#39;Loader&#39;, &#39;core&#39;);
		$this-&amp;gt;load-&amp;gt;initialize();
		log_message(&#39;info&#39;, &#39;Controller Class Initialized&#39;);
	}

	public static function &amp;amp;get_instance()
	{
		return self::$instance;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个静态私有变量&lt;code&gt;$instance&lt;/code&gt;用来存放实例化的controller，静态方法&lt;code&gt;get_instance&lt;/code&gt;是用来获取这个实例化的controller，在构造函数中，首先&lt;code&gt;self::$instance =&amp;amp; $this;&lt;/code&gt;把形成的实例存储在静态私有变量&lt;code&gt;$instance&lt;/code&gt;中，然后把通过&lt;code&gt;load_class&lt;/code&gt;这一函数实例化的类挂到controller上面，这样我们就可以在controller内通过&lt;code&gt;$this&lt;/code&gt;访问这些类了。&lt;/p&gt;

&lt;p&gt;在CodeIgniter.php文件中一个有关的函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_instance()
{
	return CI_Controller::get_instance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;model-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Model.php&lt;/h2&gt;

&lt;p&gt;Model也是业务逻辑经常要实现的，我们看一下model的基类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CI_Model {

	public function __construct()
	{
		log_message(&#39;info&#39;, &#39;Model Class Initialized&#39;);
	}

	public function __get($key)
	{
		return get_instance()-&amp;gt;$key;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CI_Model就这么简短，比较有意思的是对于魔术方法&lt;code&gt;__get&lt;/code&gt;的使用，这里利用了get_instance这一函数，当model层没有所查询的变量时就从超级对象CI那里获取。&lt;/p&gt;

&lt;h2 id=&#34;uri-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;URI.php&lt;/h2&gt;

&lt;h2 id=&#34;router-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Router.php&lt;/h2&gt;

&lt;h2 id=&#34;loader-php:4148907b28e52bc7301c1249655cea8c&#34;&gt;Loader.php&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>mongodb的复杂查询和聚合</title>
      <link>http://jiangshanmeta.github.io/post/mongodb/aggregate/</link>
      <pubDate>Sun, 23 Oct 2016 20:20:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/mongodb/aggregate/</guid>
      <description>

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/&#34;&gt;总结过mongodb常用的增删查改&lt;/a&gt;，随着使用的深入自己的工作不在局限在简单地增删查改上，还处理一部分的统计性工作。统计所需要的查询条件就比较复杂了，而mongodb的聚合又是mongodb的一个很大的话题了。这里算是对工作中遇到的一些情况进行总结吧。因为平时都是通过php操作数据库，所以下面的代码都是php，不过并不影响我想表达的。&lt;/p&gt;

&lt;h2 id=&#34;1-限制数组长度查询:233b6dd901ca06898e3895bff0f956d4&#34;&gt;1.限制数组长度查询&lt;/h2&gt;

&lt;p&gt;mongodb可以存储数组，我遇到的一个需求是筛选出数组长度大于某个值的。首先想到的是使用&lt;code&gt;$size&lt;/code&gt;，但是&lt;code&gt;$size&lt;/code&gt;不支持&lt;code&gt;$gt&lt;/code&gt;这样的操作，仅支持等于某个长度。&lt;/p&gt;

&lt;p&gt;最终的解决方案是查询数组中第N个元素是否存在，比如限制field字段数组中至少有一个元素，则where条件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;fiele.0&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-addtoset在聚合中的使用:233b6dd901ca06898e3895bff0f956d4&#34;&gt;2.$addToSet在聚合中的使用&lt;/h2&gt;

&lt;p&gt;需求场景是这样的：在流水表里有一些数据是进货记录，每条这样的数据都包含店铺id和供应商id，现在需要拿出每家供应商所供货的店铺。暴力的做法是拿出数据来在php处理（写起来并不复杂），然而用聚合实现更简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
	&#39;$match&#39;=&amp;gt;[
		&#39;typ&#39;=&amp;gt;1
	]
];
$group = [
	&#39;$group&#39;=&amp;gt;[
		&#39;_id&#39;=&amp;gt;&#39;$supplier&#39;,
		&#39;orgs&#39;=&amp;gt;[&#39;$addToSet&#39;=&amp;gt;&#39;$orgId&#39;]
	]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bPeijianFlow&#39;,[$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是实现代码，首先在&lt;code&gt;bPeijianFlow&lt;/code&gt;这张表中只有typ为1的才是进货记录，据此筛选，然后我们要根据供应商id进行聚合，所以聚合中的&lt;code&gt;_id&lt;/code&gt;是&lt;code&gt;$supplier&lt;/code&gt;，因为一个供应商对一家店可能多次供货，但我们仅需保留一次门店id，所以采用&lt;code&gt;$addToSet&lt;/code&gt;而不是&lt;code&gt;$push&lt;/code&gt;，把每家供应商供货的店铺id保存到&lt;code&gt;orgs&lt;/code&gt;这个数组中。&lt;/p&gt;

&lt;h2 id=&#34;3-根据多个字段进行聚合:233b6dd901ca06898e3895bff0f956d4&#34;&gt;3.根据多个字段进行聚合&lt;/h2&gt;

&lt;p&gt;上面的聚合仅仅是根据供应商一个字段进行，我遇到的场景是这样的：有一张用户考试的表，存储着用户id，考试类型，需要根据用户和考试类型进行聚合，拿到每个用户每个考试类型通过（通过是在筛选处理的）的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$match = array(
    &#39;$match&#39;=&amp;gt;[
        &#39;status&#39;=&amp;gt;2,
    ],
);
$group = array(
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;array(&#39;adminuserId&#39;=&amp;gt;&#39;$adminuserId&#39;,&#39;typ&#39;=&amp;gt;&#39;$typ&#39;),
        &#39;count&#39;=&amp;gt;array(&#39;$sum&#39;=&amp;gt;1),
        &#39;name&#39;=&amp;gt;array(&#39;$first&#39;=&amp;gt;&#39;$uName&#39;),
        &#39;orgId&#39;=&amp;gt;array(&#39;$first&#39;=&amp;gt;&#39;$orgId&#39;),
    ]

);

$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;aExam&#39;,[$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是筛选通过的考试，用status为2表示，然后是进行聚合，聚合是根据&lt;code&gt;adminuserId&lt;/code&gt;和&lt;code&gt;typ&lt;/code&gt;两个字段来的，所以&lt;code&gt;_id&lt;/code&gt;是一个array，而不是上面那个聚合的string，&lt;code&gt;&#39;count&#39;=&amp;gt;array(&#39;$sum&#39;=&amp;gt;1),&lt;/code&gt;是用来统计数量的，剩下的两行是用来做展示数据用的。&lt;/p&gt;

&lt;h2 id=&#34;4-聚合中的管线化操作:233b6dd901ca06898e3895bff0f956d4&#34;&gt;4.聚合中的管线化操作&lt;/h2&gt;

&lt;p&gt;目前遇到的大部分业务场景下的聚合都是两步：先筛选，再聚合。上面两个例子都是这个模式。mongodb的聚合其实是有一个管线化操作，即上一步的输出作为下一步的输入，在上面例子中是match的输出作为group的输入。
复杂场景所需要的管线化操作就比较多了，先举两个实际场景&lt;/p&gt;

&lt;p&gt;第一个场景是这样的，有一张订单表，一个用户可以有多个订单，现在需要统计用户订单数量分布，即我需要统计一张订单的用户有多少、两张订单的用户有多少&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;crmId&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true],
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;50],
    ]
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$crmId&#39;,
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$group2 = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$count&#39;,
        &#39;sum&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$sort = [
    &#39;$sort&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;-1,
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bBook&#39;, [$match,$group,$group2,$sort]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是实现代码，match条件不说了，第一个group是根据用户(crmId)进行聚合，得到每个用户拥有的订单数量，然后再一次聚合以订单数量为&lt;code&gt;_id&lt;/code&gt;进行聚合，得到订单数量分布。&lt;/p&gt;

&lt;p&gt;第二个场景也是处理订单表，需要统计有两张及以上订单的用户的数量，下面是代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;crmId&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true],
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;50],
        &#39;$or&#39;=&amp;gt;[
            [&#39;totalPrice&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]],
            [&#39;totalJiesuan&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]],
        ],
    ],
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$crmId&#39;,
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$match2 = [
    &#39;$match&#39;=&amp;gt;[
        &#39;count&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;2],
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bBook&#39;,[$match,$group,$match2]);
$data[&#39;daodianTwiceUserCount&#39;] = count($rst[&#39;result&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次聚合也是根据用户id(crmId)进行聚合，得到每个用户订单数量，到这里和第一个场景的操作一样，然后再向下操作不是聚合而是进行筛选，我们要筛选出订单数量大于等于2的。&lt;/p&gt;

&lt;h2 id=&#34;5-project的使用:233b6dd901ca06898e3895bff0f956d4&#34;&gt;5. $.project的使用&lt;/h2&gt;

&lt;p&gt;在同事的聚合代码里发现了这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$match = array(
    &#39;$match&#39;=&amp;gt; [
        &#39;storeId&#39;=&amp;gt;$this-&amp;gt;store,
        &#39;counter&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]
    ]
);
$project = array(
    &#39;$project&#39;=&amp;gt;[
        &#39;typ&#39;=&amp;gt;1,
        &#39;counter&#39;=&amp;gt;1 ,
        &#39;total&#39;=&amp;gt;[&#39;$multiply&#39;=&amp;gt;[&#39;$counter&#39;,&#39;$chengben&#39;]]
    ]
);
$group = array(
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$typ&#39;, 
        &amp;quot;counter&amp;quot;=&amp;gt;[&#39;$sum&#39;=&amp;gt; &#39;$counter&#39;],
        &amp;quot;totalPrice&amp;quot;=&amp;gt;[&#39;$sum&#39;=&amp;gt; &#39;$total&#39;]
    ]
);
$sort = [&#39;$sort&#39;=&amp;gt;[&#39;_id&#39;=&amp;gt;1]];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;sPeijianinstore&#39;,[$match,$project,$group,$sort]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用聚合也有一段时间了match和group很熟悉，但是那个project是个啥？查了一下&lt;a href=&#34;https://docs.mongodb.com/manual/reference/operator/aggregation/project/&#34;&gt;官方文档&lt;/a&gt;发现这里的&lt;code&gt;$project&lt;/code&gt;很接近mysql的&lt;code&gt;select&lt;/code&gt;，选择需要返回的字段，并能对字段进行运算作为新字段返回。
那解释一下上面project代码的含义：返回typ字段和counter字段（_id字段是默认返回的），然后创建并返回一个新的字段total，这个新字段是由counter字段和chengben字段相乘得到的。&lt;/p&gt;

&lt;p&gt;那个&lt;code&gt;$multiply&lt;/code&gt;就是相乘的意思，&lt;a href=&#34;https://docs.mongodb.com/manual/reference/operator/aggregation-arithmetic/&#34;&gt;mongodb支持多种常见的运算&lt;/a&gt;，四则运算、指数对数运算、幂运算、取整都支持。&lt;/p&gt;

&lt;h2 id=&#34;6-比较两个字段:233b6dd901ca06898e3895bff0f956d4&#34;&gt;6.比较两个字段&lt;/h2&gt;

&lt;p&gt;需求场景是这样的：有x、y两个字段，需要x&amp;gt;y的数据。如果在mysql里这个需求实现起来其实很简单，但是mongodb&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;以前对于这样的需求都是在php里进行筛选而不是在数据库里进行筛选，有了上面的&lt;code&gt;$project&lt;/code&gt;这个实现起来终于有点希望了&lt;/p&gt;

&lt;p&gt;下面一段代码是在&lt;a href=&#34;https://segmentfault.com/q/1010000003034113&#34;&gt;segmentfault&lt;/a&gt;上找的，是mongo shell的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.collection.aggregate(
    [  
      {
        $project : {
           _id: &#39;$name&#39;,
           val: { $subtract : [ &amp;quot;$x&amp;quot;, &amp;quot;$y&amp;quot; ] }，
           x: &#39;$x&#39;,
           y: &#39;$y&#39;
        }
      },
      {$match: {val: {$gt: 0}}},
      {$sort: { val: -1 }}
   ]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际使用的时候为了性能优化可以先match一遍做个初筛，然后进行project判断字段间的关系进行筛选，然后执行聚合之类的操作。&lt;/p&gt;

&lt;h2 id=&#34;7-没有-id的聚合:233b6dd901ca06898e3895bff0f956d4&#34;&gt;7.没有_id的聚合&lt;/h2&gt;

&lt;p&gt;group的时候通常会有&lt;code&gt;_id&lt;/code&gt;表示按照什么聚合，可以按照一个字段，也可以按照多个字段，上面都有例子，但是有的时候我们并不需要这个聚合的字段，比如如下场景：在订单表中快照出本月的营业额。显然我们只需要筛选出来本月的订单，然后把金额字段加起来就结束了，不需要根据哪个字段聚合。但是group的时候&lt;code&gt;_id&lt;/code&gt;不填还不行，还好mongodb支持填&lt;code&gt;null&lt;/code&gt;。一下是代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;20],
        &#39;userpayTS&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;$startTS,&#39;$lt&#39;=&amp;gt;$endTS],
    ],
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;null,
        &#39;sum&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;&#39;$totalprice&#39;],
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bJingpinbook&#39;, [$match,$group]);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>观察者模式的一次实践</title>
      <link>http://jiangshanmeta.github.io/post/js/observer/</link>
      <pubDate>Mon, 10 Oct 2016 20:05:11 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/js/observer/</guid>
      <description>&lt;p&gt;观察者模式是用来解除对象间的耦合同时保证对象间数据通信的一种设计模式，要实现对象间通信数据首先要订阅某个主题，然后监听某个主题发布信息。听起来云里雾里但是前端都见过其中的一个典型例子，就是事件，首先通过&lt;code&gt;addEventListener&lt;/code&gt;订阅事件，然后等待用户触发事件或者脚本触发事件，这时就发布了主题，此时各个对象执行相应的回调。&lt;/p&gt;

&lt;p&gt;我也实现了一个简单的观察者模式( &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/jsdesignpattern/observer.js&#34;&gt;点击下载源码&lt;/a&gt; )：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Observer = (function(){
	var _message = {};
	return {
		register:function(typ,fn){
			if(!_message[typ]){
				_message[typ] = [];
			}
			_message[typ].push(fn);
			return this;
		},
		publish:function(typ,data){
			if(_message[typ]){
				for(var i=0,len=_message[typ].length;i&amp;lt;len;i++){
					_message[typ][i](data);
				}
			}
			return this;
		},
		remove:function(typ,fn){
			if(_message[typ]){
				for(var i=0,len=_message[typ].length;i&amp;lt;len;i++){
					_message[typ][i] ==fn &amp;amp;&amp;amp; _message[typ].splice(i,1);
				}
			}

			return this;
		}
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现是希望将对象之间的通信通过这一个对象进行，这个实现说实话只适用于小型的项目。&lt;/p&gt;

&lt;p&gt;我应用它的场景是这样的：多个对象都有选择地址这么一个操作，在选择地址中有一项是添加地址，然而添加地址这一操作对应一个新的对象，在添加地址对象完成添加后，需要通知其他选择地址对象新的地址array。最开始的实现是判断那几个选择地址的对象存不存在，如果存在就把数据传过去，每多一次引用就要多一个判断。然后我就使用观察者模式改写，更新地址array的时候发布一个更新地址主题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>http://jiangshanmeta.github.io/post/php/single/</link>
      <pubDate>Sun, 18 Sep 2016 15:42:17 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/single/</guid>
      <description>&lt;p&gt;重新学习最好的编程语言的时候看到了&lt;code&gt;static&lt;/code&gt;关键字，于是就想到了可以用这个做单例模式。单例模式的作用是保证一个类最多只有一个实例对象。这里不仅讲php中如何实现单例模式，还顺便说一下在js中如何实现单例模式。&lt;/p&gt;

&lt;p&gt;首先讲一下在php中如何实现单例模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person{
	private static $instance = null;
	private function __construct($name){
		$this-&amp;gt;name = $name;
	}

	public function gen_name(){
		var_dump($this-&amp;gt;name);
	}

	public static function get_instance($name){
		if(!(self::$instance instanceof self)){
			self::$instance = new self($name);
		}
		return self::$instance;
	}

}

$a = Person::get_instance(&#39;a&#39;);
$b = Person::get_instance(&#39;b&#39;);
$a-&amp;gt;gen_name();  // a
$b-&amp;gt;gen_name();	 // a

var_dump($a===$b); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们把构造函数&lt;code&gt;__construct()&lt;/code&gt;加上修饰词&lt;code&gt;private&lt;/code&gt;，这样在外部使用&lt;code&gt;new&lt;/code&gt;关键字实例化一个对象就会报错。然后我们添加一个私有的静态变量&lt;code&gt;$instance&lt;/code&gt;，用来缓存实例化的对象。静态方法&lt;code&gt;get_instance&lt;/code&gt;用来提供单例实例对象。首先判断&lt;code&gt;$instance&lt;/code&gt;有没有缓存的实例，如果有就返回这个缓存的实例对象，如果没有就手动new一个实例对象然后缓存返回该对象。单例模式在php中的实现并不复杂。&lt;/p&gt;

&lt;p&gt;对于js实现上稍微有点复杂，因为js没有&lt;code&gt;static&lt;/code&gt;关键词，但是我们可以模拟它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = (function(){
	var instance = null;

	return function(name){
		// 安全模式，保证是使用new关键字
		if(! (this instanceof Person)){
			return new Person(name);
		}

		// 还没有创建实例对象，需要创建并缓存
		if(!(instance instanceof Person)){
			this.name = name;

			instance = this;
		}
		return instance
	}
})();

var a = Person(&#39;a&#39;);
var b = new Person(&#39;b&#39;);
console.log(a.name); // a
console.log(b.name); // b
console.log(a===b);  // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js中实现单例模式的原理类似，只是使用闭包存了一个变量&lt;code&gt;instance&lt;/code&gt;用来缓存实例对象。顺便说一句在这里被js的操作符优先级给坑了一下，默默加括号。&lt;/p&gt;

&lt;p&gt;其实单例模式的核心是保证最多只有一个实例对象，对于灵活的js其实还有一种更简单粗暴的方法，就是直接暴露一个对象，根本不给你new的机会。&lt;/p&gt;

&lt;p&gt;比如在我们的项目中有这样的一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var AlertPlug = {
	alert:function(){},
	close:function(){},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是使用单例模式的一个例子。&lt;/p&gt;

&lt;p&gt;update 2016/09/21&lt;/p&gt;

&lt;p&gt;上面的js虽然实现了但是模式，但是有一个很严重的问题，就是如果我们想在Person原型上添加一些方法，这些方法由于作用域的原因是无法获取到闭包内的静态私有变量，对于以后的扩展是很不利的。我们可以这样修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window){
	var instance = null;
	var otherStaticPrivateVar = null;

	function Person(name){
		// 安全模式，保证是使用new关键字
		if(! (this instanceof Person)){
			return new Person(name);
		}

		// 还没有创建实例对象，需要创建并缓存
		if(!(instance instanceof Person)){
			this.name = name;

			instance = this;
		}
		return instance
	}

	Person.prototype.logOtherStaticPrivateVar=function(){
		console.log(otherStaticPrivateVar);
	}
	window.Person = Person;
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的结果依然是向全局暴露一个构造函数。&lt;/p&gt;

&lt;p&gt;update 2016/09/21&lt;/p&gt;

&lt;p&gt;后来想了想，prototype是为了不同实例之间共享一些属性和方法才存在的，既然我要做的是单例，那又何必把方法加在prototype上。&lt;/p&gt;

&lt;p&gt;不过，上面的补充其实可以作为在js中模拟静态私有变量的通用写法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript中的继承</title>
      <link>http://jiangshanmeta.github.io/post/js/extend/</link>
      <pubDate>Sun, 04 Sep 2016 20:29:27 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/js/extend/</guid>
      <description>&lt;p&gt;发现自己空中楼阁折腾得太多，一些基础反而没打牢，这里重新学习一下js的面向对象。其实js的面向对象算是一种很奇特的实现，以前只会写js，觉得其他编程语言也差不多，接触了其他的语言才发现js才是那个特例啊。这里就对比着php和js说明。为了便于说明先上两段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Person{
	public function __construct($name=&#39;&#39;){
		$this-&amp;gt;name = $name;
	}

	public function genName(){
		return $this-&amp;gt;name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;php中的类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
}

Person.prototype.genName = function(){
	returrn this.name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js中的构造函数及prototype&lt;/p&gt;

&lt;p&gt;在使用new关键字的时候，两端代码其实功能是一致的，都会生成一个实例，实例具有&lt;code&gt;name&lt;/code&gt;这一属性和&lt;code&gt;genName&lt;/code&gt;这一方法。在javascript中没有类的概念，所以用构造函数结合prototype模拟类。在第二段代码中，因为&lt;code&gt;genName&lt;/code&gt;这一方法是每个实例所共享的，不需要再每个实例上都实现一遍，所以放在了构造函数的prototype上。其实js的构造函数，确实是只起到了php中的构造函数&lt;code&gt;__construct(){}&lt;/code&gt;的作用，而php类中的其他方法，则对应js的prototype的方法。&lt;/p&gt;

&lt;p&gt;在php中的继承是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Kid extends Person{
	public function __construct($name=&#39;&#39;,$age=1){
		parent::construct($name);
		$this-&amp;gt;age = $age;
	}

	public function genAge(){
		returrn $this-&amp;gt;age;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在javascript中要模拟php中的继承，需要模拟在构造函数和prototype两个地方分别模拟（毕竟这两者结合起来才像个类）。&lt;/p&gt;

&lt;p&gt;首先我们要实现构造函数的模拟：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Kid(name,age){
	Person.call(this,name);
	this.age = age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们要实现对于基类中的方法的继承，这一点是通过原型链实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kid.prototype = Object.create(Person.prototype);
Kid.prototype.constructor = Kid;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们要实现的是对于子类方法的扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kid.prototype.genAge = function(){
	return this.age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对于js的&lt;code&gt;Kid&lt;/code&gt;，我们使用new操作得到的实例，含有&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;两个属性，含有&lt;code&gt;genName&lt;/code&gt;和&lt;code&gt;genAge&lt;/code&gt;两个方法，与php的Kid类通过new生成的实例一样。&lt;/p&gt;

&lt;p&gt;到现在，我们模拟了php的继承，在javascript中实现了继承。&lt;/p&gt;

&lt;p&gt;以前看&lt;strong&gt;javascript高级程序设计&lt;/strong&gt;对于继承的讲解，总觉得云里雾里，现在和其它编程语言的继承相比较，才逐渐明白js的继承为什么要这么折腾。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重新学习最好的编程语言</title>
      <link>http://jiangshanmeta.github.io/post/php/relearnphp/</link>
      <pubDate>Thu, 25 Aug 2016 21:07:38 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/relearnphp/</guid>
      <description>

&lt;p&gt;从前端入的行，现在前端和后端php一起写，虽然日常的业务逻辑对我来说很轻松，但是感觉自己被框架宠坏了。业务中用的框架是封装过的CI，想着从一个空的CI（3.1.0）开始做起，至少要脱离现在高度封装过的框架。跟着教程看起，发现了自己对于php很多地方理解不足，这里一条条记录下来。&lt;/p&gt;

&lt;h2 id=&#34;1-构造函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;1.构造函数&lt;/h2&gt;

&lt;p&gt;CI框架默认的&lt;code&gt;controller&lt;/code&gt;是welcome，不过业界习惯还是index，我就照着welcome这个&lt;code&gt;controller&lt;/code&gt;写了一个index的&lt;code&gt;controller&lt;/code&gt;,然后就报错了。我说我这种动不动就建个&lt;code&gt;controller&lt;/code&gt;写个几百行的咋建个&lt;code&gt;controller&lt;/code&gt;就报错啊。然后百度了一下有人在博客里说是因为这是CI的保留名称所以会报错，可是项目中明明就有controller名为index的啊。后来我发现根本不是这么回事。&lt;/p&gt;

&lt;p&gt;问题出在&lt;strong&gt;构造函数&lt;/strong&gt;上。在php4的时代，构造函数是和类名同名的函数，但是在php5引入了&lt;code&gt;__construct&lt;/code&gt;的概念作为构造函数，同时为了保证向下兼容所以如果没有找到&lt;code&gt;__construct&lt;/code&gt;就把同名函数作为构造函数。在这里，我的controller名称是index，方法名称也是index，并且没有&lt;code&gt;__construct&lt;/code&gt;所以会把index方法当成构造函数。解决方案也就很明了了：写上构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __construct(){
	parent::__construct();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为继承的基类&lt;code&gt;CI_Controller&lt;/code&gt;里有构造函数，显然不作死的方案是调用基类的构造函数。看了一眼项目里的代码，我们是一个类继承了&lt;code&gt;CI_Controller&lt;/code&gt;，调用了&lt;code&gt;CI_Controller&lt;/code&gt;的构造函数，然后做了一些其他的操作。&lt;/p&gt;

&lt;h2 id=&#34;2-view-template:960e085aadb29182f9448019a6b3c8f1&#34;&gt;2.view &amp;amp;&amp;amp; template&lt;/h2&gt;

&lt;p&gt;CI是一个MVC框架，最开始我只会画画页面写写js，所以最一开始做的是view层。关于CI的view层&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/views.html&#34;&gt;官方文档里已经给出了很好的说明&lt;/a&gt;，仅仅从用的角度来说已经足够了。然而如果不对其进行封装很容易做一些重复性的操作，比如说声明对header的加载，声明对footer的加载，而真正业务逻辑对应的页面加载只需要一行，对此我们引入了一个新的类&lt;code&gt;template&lt;/code&gt;，把那些header、footer之类的全都放在模板里，在模板里输出真的业务逻辑界面。&lt;/p&gt;

&lt;p&gt;下面代码是从项目代码里按照自己的书写习惯稍微改造的，如果不明白其中一些CI的东西可以看上面链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Template{
	public function __construct(){
		$this-&amp;gt;templateData = [];
		$this-&amp;gt;CI = &amp;amp;get_instance();
	}

	public function set($name,$value){
		$this-&amp;gt;templateData[$name] = $value;
	}

	public function load($template,$view,$view_data = array(),$return = FALSE){
		$this-&amp;gt;set(&#39;contents&#39;,$this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($view,$view_data,TRUE));
		return $this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($template,$this-&amp;gt;templateData,$return);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把这个类放在&lt;code&gt;application/libraries&lt;/code&gt;目录下&lt;code&gt;template.php&lt;/code&gt;文件中，并在autoload中的libraries数组中添加&lt;code&gt;template&lt;/code&gt;,这样我们就可以愉快的使用&lt;code&gt;template&lt;/code&gt;类了，例如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;template-&amp;gt;load(&amp;quot;default_page&amp;quot;,&amp;quot;index/index&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-my-controller:960e085aadb29182f9448019a6b3c8f1&#34;&gt;3.MY_Controller&lt;/h2&gt;

&lt;p&gt;面向对象一大特征是继承，对于controller里的类也适用。CI官方文档里所讲的controller所继承的都是&lt;code&gt;CI_Controller&lt;/code&gt;，如果需求简单确实足够了，想要封装一层的话可以让这个子类继承自&lt;code&gt;CI_Controller&lt;/code&gt;，在这个类里面进行所需要的封装，controller里的类再继承自这个子类。&lt;/p&gt;

&lt;p&gt;如果熟悉面向对象的话上面所说的实现起来并不复杂，唯一的问题是目录。其实CI已经考虑过这个问题了。把自己封装好的类放到&lt;code&gt;application/core&lt;/code&gt;目录下，文件名称为xxController，然后在&lt;code&gt;application/config/config.php&lt;/code&gt;中找到&lt;code&gt;$config[&#39;subclass_prefix&#39;]&lt;/code&gt;，将其值赋为刚才文件名中的xx，然后你就会发现这个文件会自动被加载（至于具体的子类名称，对于我这种命名困难户显然是选文件名啦）。话说回来，真不嫌麻烦还可以每个controller里手动加载这个文件（何必呢）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/core_classes.html&#34;&gt;扩展核心系统类&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-uri类:960e085aadb29182f9448019a6b3c8f1&#34;&gt;4.URI类&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://codeigniter.org.cn/user_guide/libraries/uri.html&#34;&gt;URI类&lt;/a&gt;可以帮助从URI字符串中获得一些基本的信息，结合项目中所用到的说一下。&lt;/p&gt;

&lt;p&gt;根据CI的路由规则，第一个参数是控制器的名称，第二个参数是方法名，有的时候会用到这两个名称，最开始的时候我是在controller的构造函数手动声明控制器名称是啥，在具体方法里手动声明方法名是啥。看了文档个人觉得可以封装到上面提到的subclass的构造函数中，毕竟用到的还是比较多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;controller_name = $this-&amp;gt;uri-&amp;gt;segment(1)==null?&#39;index&#39;:$this-&amp;gt;uri-&amp;gt;segment(1);
$this-&amp;gt;method_name = $this-&amp;gt;uri-&amp;gt;segment(2)==null?&#39;index&#39;:$this-&amp;gt;uri-&amp;gt;segment(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外还用到比较多的是&lt;code&gt;$this-&amp;gt;uri-&amp;gt;uri_string()&lt;/code&gt;，这个主要是用在重定向上（因为样式问题以及兼容性、推广等问题对于手机和PC做了两个子站）。&lt;/p&gt;

&lt;h2 id=&#34;5-mongodb-cimongo:960e085aadb29182f9448019a6b3c8f1&#34;&gt;5.mongoDB &amp;amp;&amp;amp; cimongo&lt;/h2&gt;

&lt;p&gt;WEB开发离不开数据库，没记错的话新手是首推mysql，然后我就点错科技树学了mongoDB。开始连接数据库吧。&lt;/p&gt;

&lt;p&gt;先说个mongoDB的可视化工具&lt;a href=&#34;https://robomongo.org/&#34;&gt;robomongo&lt;/a&gt;，从一开始写后端程序就在用，毕竟图形界面大法好。&lt;/p&gt;

&lt;p&gt;然后说一下用的库&lt;a href=&#34;https://github.com/vesparny/cimongo-codeigniter-mongodb-library&#34;&gt;cimongo-codeigniter-mongodb-library&lt;/a&gt;，目测作者弃坑了。这个库为我们封装了许多操作数据库的方法。我们需要把config目录下的cimongo.php移动到ci项目 application/config目录下，然后把libraries目录下的cimongo文件夹移动到我们的ci项目中application/libraries目录下。迁移过来之后需要进行一些配置操作，打开cimongo.php配置host、port和db，然后和上面的template类一样作为autoload的libraries，这样我们就可以通过&lt;code&gt;$this-&amp;gt;cimongo&lt;/code&gt;操作数据库了。在实际项目中目测是因为觉得这样写比较长在subclass中做了这个操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db = $this-&amp;gt;cimongo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话我们就可以进行数据库操作了，现在可以随手插入两条数据看看了，然而这样操作数据库是比较危险的操作，随后我们需要进行的是在model层对数据操作进行封装。&lt;/p&gt;

&lt;h2 id=&#34;6-创建类库:960e085aadb29182f9448019a6b3c8f1&#34;&gt;6.创建类库&lt;/h2&gt;

&lt;p&gt;今天遇到一个需求是根据权重产生随机结果，实现起来其实并不复杂，我只是想借着这个引出话题 &lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/creating_libraries.html&#34;&gt;在CI中创建类库&lt;/a&gt;。之前的template类就是这个主题的一个体现，不过那个类我是配置成了自动加载，那现在我有一个&lt;code&gt;Utility&lt;/code&gt;类，我想在需要的时候加载，我应该怎么办&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;load-&amp;gt;library(&#39;Utility&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后这个类就挂在了$CI上面。稍微有点开发经验的人应该对utility这个词不陌生，从此可以收集各种小函数啦（我不生产代码，我只是代码的搬运工）。&lt;/p&gt;

&lt;h2 id=&#34;7-field:960e085aadb29182f9448019a6b3c8f1&#34;&gt;7.field&lt;/h2&gt;

&lt;p&gt;对于从数据库里拿出来的数据，CI并没有做什么别的操作，我们项目中采用了一系列field类，用于对字段进行处理。&lt;/p&gt;

&lt;p&gt;首先我们实现了对CI的load的扩展，类似于上面说的MY_Controller,在同一目录下我们可以建立我们的Loader，其命名规则和自己建的controller一致，都是根据&lt;code&gt;application/config/config.php&lt;/code&gt;中的&lt;code&gt;$config[&#39;subclass_prefix&#39;]&lt;/code&gt;。这样我们就可以通过&lt;code&gt;$this-&amp;gt;load-&amp;gt;field($show_name,$name,$is_must_input=false)&lt;/code&gt;加载field对象了。&lt;/p&gt;

&lt;p&gt;然后我们需要做的是根据我们对不同字段类型的设定，加载不同的field，进行初始化操作，然后我们就可以在各种field上封装各种方法对数据进行处理啦。&lt;/p&gt;

&lt;h2 id=&#34;8-链式调用:960e085aadb29182f9448019a6b3c8f1&#34;&gt;8.链式调用&lt;/h2&gt;

&lt;p&gt;最早接触链式调用是在使用jQuery的时候，其实我觉得使用链式调用能使代码看起来更紧凑一点，除此之外看不出来有什么好处。&lt;/p&gt;

&lt;p&gt;要实现链式调用技术上也并不复杂，最核心的就是&lt;code&gt;return $this;&lt;/code&gt;这一句话。&lt;/p&gt;

&lt;p&gt;很不幸的是在工作项目中除了引用的第三方库中实现过链式调用，我们的后端代码中真心没有自行实现过链式调用，都是使用别人提供的链式调用。&lt;/p&gt;

&lt;p&gt;目前也就发现在model层实现链式调用有点用处，这也提醒我以后一些操作封装在model层，而不是仅仅在controller层实现功能就完了。公司代码里有的没有返回值直接添加 &lt;code&gt;return $this;&lt;/code&gt;就好了，但是有的。。想改就要改一大堆东西，有的甚至都挂在&lt;code&gt;$this&lt;/code&gt;上了还要手动返回一次。历史包袱这种东西真心纠结。&lt;/p&gt;

&lt;p&gt;因为有的代码从controller层迁移到了model层，一些controller里的return在model层就要转化为exit，这个&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/exit/&#34;&gt;已经有了一些经验&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;9-protected:960e085aadb29182f9448019a6b3c8f1&#34;&gt;9.protected&lt;/h2&gt;

&lt;p&gt;javascript没有类的概念，因而也没有private、protected、public的概念，但是在php中有啊，在平时的开发中public和private用的比较多，但是真的没找到&lt;code&gt;protected&lt;/code&gt;的使用痕迹（第三封库的不算），但其实我觉得这个概念很好用啊。&lt;/p&gt;

&lt;p&gt;在controller层，写多了就会发现有一些业务上的通用小函数，最开始可能就只在一个controller里面用，显然封装成private就已经足够了，随着业务逻辑的复杂，这样的小函数可能会复制粘贴多次，显然应该向基类里进行封装，最合适的关键词就是&lt;code&gt;protected&lt;/code&gt;。封装到上面提到的&lt;strong&gt;MY_Controller&lt;/strong&gt;里面其实也不是很合适，个人认为那里适合放一些对CI框架的封装及操作，属于框架扩展层面的，而不应该存放业务逻辑。因此我个人认为应该写个专门的类继承&lt;strong&gt;MY_Controller&lt;/strong&gt;，里面放这些业务逻辑通用代码，都是protected的，然后具体的业务类都继承这个类。&lt;/p&gt;

&lt;p&gt;在model层，本身就有一些变量只应该内部使用，比如表名之类的，开发工作中的model层这些变量基本没有被限制过，都是暴露出去的，只有一些私有方法。sign&lt;/p&gt;

&lt;h2 id=&#34;10-get:960e085aadb29182f9448019a6b3c8f1&#34;&gt;10.__get()&lt;/h2&gt;

&lt;p&gt;为啥我会提到这个，这是个悲伤的故事。&lt;/p&gt;

&lt;p&gt;上面说到利用&lt;code&gt;protected&lt;/code&gt;的概念改写了一些公司对CI封装的代码，在controller层其实没什么问题，在model层有些问题，因为有些情况下还是会需要访问极个别被保护起来的变量，为了实现这个需求一个方案是在业务model类里面重新设定这些变量的修饰词，但这样就可以修改这些变量了，另一个方案是仅仅给这些变量读的权限，于是我就想到了魔术方法&lt;code&gt;__get()&lt;/code&gt;，然后我就在model层基类写下了以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __get($name){
	if(in_array($name,[&#39;tableName&#39;])) {
		return $this-&amp;gt;$name;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里逻辑上没什么问题，然后我就去测试了，然后就报错了。直接说原因：我封装的model层基类继承自&lt;code&gt;CI_Model&lt;/code&gt;，在这个类里面有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __get($key){
	return get_instance()-&amp;gt;$key;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看代码就差不多明白了吧，同时通过这段代码，CI实现了在model层调用&lt;code&gt;CodeIgniter&lt;/code&gt;的属性和方法。所以修改后的代码是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __get($name){
	if(in_array($name, [&#39;is_inited&#39;])){
		return $this-&amp;gt;$name;
	}else{
		return parent::__get($name);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-final:960e085aadb29182f9448019a6b3c8f1&#34;&gt;11.final&lt;/h2&gt;

&lt;p&gt;之所以会提及这个关键词也是很偶然的，今天老板吐槽一个同事经常重载诸如&lt;code&gt;insert_db&lt;/code&gt;之类的基础函数，然后就谈到了稍微大型的项目就不会让每个人都接触整个项目代码了，很有可能一个人只负责几个controller或者model，基类整体就是只暴露可以调用的方法，内部实现根本看不到，那问题就是如何防止重载基础函数，老板说跑脚本检测之类的，但是最简单的实现就是在想要防止重载的方法加上&lt;code&gt;final&lt;/code&gt;修饰词，能用语言本身解决的问题还需要跑脚本之类的折腾吗。&lt;/p&gt;

&lt;p&gt;之所以要重载是因为想做些额外的事情，那在使用final关键词的情况下解决如何做这些额外的事情？答案是使用&lt;strong&gt;钩子函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;12-model:960e085aadb29182f9448019a6b3c8f1&#34;&gt;12.model&lt;/h2&gt;

&lt;p&gt;根据CI的文档，model层是用来负责和数据库打交道的，在我们的项目中，把model分成了两类，一类是record_model,负责处理一条数据，另一类是list_model，负责处理多条数据，record_model是list_model的基础。这两个类都是继承自CI_model，作为对CI的进一步封装，这两个类上封装了一系列方法，用于对数据进行加载和处理，同时作为业务类的基础。由于一些历史原因，里面有许多方法封装的并不是很合适以至于，所以我要各种修修补补。&lt;/p&gt;

&lt;h2 id=&#34;13-改变应用路径:960e085aadb29182f9448019a6b3c8f1&#34;&gt;13.改变应用路径&lt;/h2&gt;

&lt;p&gt;在CI中原始的项目代码是放在&lt;code&gt;application&lt;/code&gt;目录下，而&lt;code&gt;index.php&lt;/code&gt;和该目录同级，出于安全及复杂应用的考虑，我们可以考虑改变入口文件&lt;code&gt;index.php&lt;/code&gt;的位置及项目代码目录的名称。
比如说我们把原来的application目录修改为app_user，在和该目录同级建立一个www_user目录，把入口文件放到该目录下，
为此，我们需要再index.php中进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$application_folder = getcwd().&#39;/../app_user&#39;;
$system_path = &#39;../system&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;14-辅助函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;14.辅助函数&lt;/h2&gt;

&lt;p&gt;CI提供了一些使用面向过程写的辅助函数，我扩展的是url_helper，毕竟web开发离不开url的处理。首先是对这个文件的自动加载，在autoload文件中的&lt;code&gt;autoload[&#39;helper&#39;]&lt;/code&gt;数组中添加一项&lt;code&gt;url&lt;/code&gt;这样就能自动加载了。&lt;/p&gt;

&lt;p&gt;然后是添加我的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;static_url&#39;))
{
	function static_url($uri = &#39;&#39;)
	{
		$CI =&amp;amp; get_instance();
		return $CI-&amp;gt;config-&amp;gt;static_url($uri);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数的目标是处理对本地文件的引用路径（比如js、css还有图片）。&lt;/p&gt;

&lt;p&gt;具体实现是在&lt;strong&gt;system/core/config.php&lt;/strong&gt;中。&lt;/p&gt;

&lt;h2 id=&#34;15-static:960e085aadb29182f9448019a6b3c8f1&#34;&gt;15.static&lt;/h2&gt;

&lt;p&gt;在使用CI的时候，经常会调用&lt;code&gt;get_instance&lt;/code&gt;这个函数，看一下具体实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_instance()
{
	return CI_Controller::get_instance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来在CI_Controller上有一个静态方法&lt;code&gt;get_instance&lt;/code&gt;，我们再去找CI_Controller的相关代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function &amp;amp;get_instance()
{
	return self::$instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来CI_Controller里面有一个受保护的的静态成员&lt;code&gt;$instance&lt;/code&gt;,再去找它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static $instance;
public function __construct()
{
	self::$instance =&amp;amp; $this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那结果很显然，这个静态私有变量保存着对controller实例的引用。&lt;/p&gt;

&lt;h2 id=&#34;16-spl-autoload-register:960e085aadb29182f9448019a6b3c8f1&#34;&gt;16.spl_autoload_register&lt;/h2&gt;

&lt;p&gt;这个函数其实不是CI中使用的，而是项目中对CI进行扩展的时候使用的，其作用相当于是对于&lt;code&gt;__autoload&lt;/code&gt;的加强版。其实稍微大点的项目用得到，小项目用&lt;code&gt;__autoload&lt;/code&gt;就行了。&lt;/p&gt;

&lt;p&gt;我们用它做了什么？在CI中，如果要加载并实例化某个类并挂到CI上，我们需要使用load方法，但是有的时候我们只想使用这个类的实例，并不想挂到CI指针上，比如说在一个model中加载另一个model，我们该怎么办？一个方法是需要的时候手动include或者require，当然这样比较累，另一种方法就是__autoload啦。最终的结果是我们可以使用new关键字实例化一个model而不需要手动加载文件。&lt;/p&gt;

&lt;h2 id=&#34;17-date:960e085aadb29182f9448019a6b3c8f1&#34;&gt;17.date&lt;/h2&gt;

&lt;p&gt;之所以说它是因为出了一个小bug，我想要处理时间戳显示时间，然后第一个参数填了&lt;code&gt;&#39;Y-m-d h:i&#39;&lt;/code&gt;,然后就出bug了，因为这里的h是指12小时制。这个函数常用的其实就那么几个参数。&lt;a href=&#34;http://php.net/manual/zh/function.date.php&#34;&gt;手册&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;18-json-decode:960e085aadb29182f9448019a6b3c8f1&#34;&gt;18.json_decode&lt;/h2&gt;

&lt;p&gt;一般来说&lt;code&gt;json_decode&lt;/code&gt;用到的很少，主要用到的是&lt;code&gt;json_encode&lt;/code&gt;。以前不知道前端如何向后端传递复杂数据类型，然后就前端转成json然后给后端，后端decode，然后当时也不知道还有第二个参数所以后端以对象的语法访问。后来看其他人的代码，知道在jquery中可以传递数组和对象然后jquery格式化。    今天在看jquery如何实现序列化，突然想到了这个话题。&lt;/p&gt;

&lt;h2 id=&#34;19-json-encode-转义:960e085aadb29182f9448019a6b3c8f1&#34;&gt;19.json_encode 转义&lt;/h2&gt;

&lt;p&gt;在写&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/lottery/index.html&#34;&gt;抽奖效果&lt;/a&gt;的时候遇到一个需求，对于奖项进行换行显示，因为canvas本身不支持文字换行，所以我们最开始约定使用\n作为分隔符，人工进行换行处理。然而最开始并不能正常进行分割，一开始以为是中文的问题，然后查了查&lt;a href=&#34;http://php.net/manual/zh/function.json-encode.php&#34;&gt;发现&lt;code&gt;json_encode&lt;/code&gt;有第二个参数（通过json_encode传递奖项array）&lt;/a&gt;，对中文不转义之后发现依然无法正常显示，然后就猜是转义的问题。确实有转义的问题但不仅仅是转义的问题，因为在单引号下，json_encode的结果无法正常分割但是直接php输出这一子项的结果可以正常分割，双引号下json_encode的结果可以分割但是直接输出的结果直接报错。总之，为啥当初用\n这种符号分割呢。&lt;/p&gt;

&lt;h2 id=&#34;20-变量作用域:960e085aadb29182f9448019a6b3c8f1&#34;&gt;20.变量作用域&lt;/h2&gt;

&lt;p&gt;之所以会提及这个问题是因为看CI源码时遇到了这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_config(Array $replace = array())
{
	static $config;
	if (empty($config))
	{
		$file_path = APPPATH.&#39;config/config.php&#39;;
		$found = FALSE;
		if (file_exists($file_path))
		{
			$found = TRUE;
			require($file_path);
		}
	}
	return $config;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数首先声明了一个静态局部变量&lt;code&gt;$config&lt;/code&gt;，然后如果这个变量为空就去加载对应文件，文件中有一个名为&lt;code&gt;$config&lt;/code&gt;的变量。觉得这里写的比较巧妙，如果直接加在这个文件，就会设立一个全局变量&lt;code&gt;$config&lt;/code&gt;，容易被修改或者覆盖，这里将其转化为局部静态变量，从而起到了保护的作用，类似于js的闭包。&lt;/p&gt;

&lt;p&gt;说起作用域，js和php还是有点差异的，比如js局部变量没有会沿着作用域链向上查找，而在php中在局部想要访问全局变量需要手动添加&lt;code&gt;global&lt;/code&gt;关键字。php中的静态变量和js中闭包中的变量很类似。写php面向对象惯了反而对作用域关注的少了。&lt;/p&gt;

&lt;h2 id=&#34;21-server:960e085aadb29182f9448019a6b3c8f1&#34;&gt;21.$_SERVER&lt;/h2&gt;

&lt;p&gt;以前一直不明白CI是如何根据url确定需要初始化的controller是哪个、调用的方法是哪个、以及参数。看CI源码就明白了，在超全局变量&lt;code&gt;$_SERVER&lt;/code&gt;保存着请求的url，通过&lt;code&gt;CI_Router&lt;/code&gt;和&lt;code&gt;CI_URI&lt;/code&gt;两个类进行字符串处理就可以得到controller、method以及参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>上网的不科学指南</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/summarize/</link>
      <pubDate>Tue, 16 Aug 2016 20:03:58 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/summarize/</guid>
      <description>&lt;p&gt;看计算机网络已经有一段时间了，对于应用层、传输层、网络层、链路层也有了基本的了解。但是感觉自己学的比较零碎，缺乏一个整体的概念，所以想写一篇总结，把这些东西串起来。&lt;/p&gt;

&lt;p&gt;想要上网的话，首先要通过&lt;strong&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;&lt;/strong&gt;获得一个IP地址。&lt;/p&gt;

&lt;p&gt;客户端这里首先生成一个DHCP发现报文，然后把这个报文交给传输层传输层的&lt;code&gt;UDP&lt;/code&gt;，DHCP有固定的源端口号和目的端口号。&lt;code&gt;UDP&lt;/code&gt;封装好之后，交给网络层去处理，网络层的IP报文需要填写目的IP地址和源IP地址，然而目前自身的IP待分配、目的IP地址也未知，这里就需要两个特殊的IP地址了，源IP地址为&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，目的IP地址为&lt;code&gt;255.255.255.255&lt;/code&gt;表示广播地址。网络层处理完交给数据链路层处理，需要源MAC地址和目的MAC地址，现在连DHCP服务器是谁都不知道怎么确定MAC地址？答案和刚提到的广播IP地址类似，目的MAC地址填上广播MAC地址&lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;局域网内部的每一台主机都能收到这个报文，但是只有DHCP服务器才会做出响应。对于DHCP服务器，数据自下传递到上层，然后把分配的IP地址、DNS服务器地址、默认网关地址、子网掩码 作为DHCP ACK报文，然后向下逐层封装。形成IP报文的时候目的地址依然为广播地址。在这里说一句无论是DHCP发现报文还是DHCP ACK报文，中间都经过&lt;code&gt;链路层交换机&lt;/code&gt;，链路层交换机会根据源MAC地址和输入链路的接口在交换机表中记录一条记录，作为转发的基础。&lt;/p&gt;

&lt;p&gt;现在我们这台主机获得了自己的IP地址，顺便还有默认DNS服务器地址、默认网关地址、子网掩码。当我们在地址栏中输入一个url的时候，比如 &lt;a href=&#34;http://jiangshanmeta.github.io&#34;&gt;http://jiangshanmeta.github.io&lt;/a&gt; ，就需要通过&lt;code&gt;DNS&lt;/code&gt;服务（至少对于chrome调用DNS不见得一定在输入url然后确认之后，我们没有必要关心这个调用的时机）。DNS服务器地址是在DHCP返回的，有可能和我们的主机在一个子网内，也可能不在一个子网内，这需要结合两者的IP地址和&lt;strong&gt;子网掩码&lt;/strong&gt;判断，通常不要指望在一个子网内。要和子网外部进行通信需要通过网关，我们已经有了默认网关地址（一个IP地址），但是数据链路层需要MAC地址，因而我们需要&lt;code&gt;ARP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;ARP是根据IP地址返回MAC地址，它也是利用广播，子网内每台主机都会收到ARP报文，但是只有IP地址对应的才会返回MAC地址。通过ARP获得默认网关MAC地址，这样在主机那里各层发送DNS报文所需要的基本信息就有了，DNS交给UDP、UDP交给IP然后交给链路层封装成帧，所形成的数据帧传递到路由器，路由器这里根据由&lt;code&gt;路由协议&lt;/code&gt;（这么复杂的协议我说这么一句话真的好吗）决定的转发表决定转发的输出链路，根据转发表提供的下一跳IP地址利用ARP获得新的目的MAC地址重写数据链路层（在路由器网络层首部和数据链路层都会有一些首部字段被修改，目的MAC地址是每经过一次路由器就修改，但是目的IP地址相一般不会修改，除非是经过了&lt;code&gt;NAT&lt;/code&gt;）。本地DNS服务器获得请求之后，可能&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;经过一系列请求&lt;/a&gt;，也可能直接根据缓存返回要查询的IP地址。这样我们的主机获得了请求域名的IP地址，对网页的请求的准备工作基本完成了。&lt;/p&gt;

&lt;p&gt;现在需要发起HTTP请求了，以我上面提到的网址为例就是发送一个GET请求，应用层把http报文交给TCP，TCP相比较上面提到的传输层协议UDP，提供可靠传输功能。它需要首先建立连接，然后才能传递上层传来的数据。再往下层的东西上面已经提及了，通过网关出子网，然后经过各种路由转发最终到达目标服务器，目标服务器根据请求的url提供文件，然后又是一层层封装路由转发解封装到达应用层，这样我们得到了请求的文件，比如html，剩下的就是浏览器如何解析返回的数据了，这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;这样我基本上把所学到的计算机网络知识串了起来，包括&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;DNS&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/&#34;&gt;http&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;传输层&lt;/a&gt;的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/&#34;&gt;TCP&lt;/a&gt;和UDP、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;、网络层的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/ip/&#34;&gt;网际协议&lt;/a&gt;和路由协议、NAT、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/mac/&#34;&gt;链路层MAC地址、ARP协议（这是个跨层的协议）、链路层交换机&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;每一层都有了一定的了解，下面的任务是转入http协议的学习和设计模式的学习了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初识链路层</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/mac/</link>
      <pubDate>Mon, 15 Aug 2016 20:48:45 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/mac/</guid>
      <description>

&lt;p&gt;数据链路层是五层协议栈的第二层，其实对于一般的web开发已经离得有点远了（至少在目前的我看来是这样的），而且个人学习起来这一层感觉东西略杂，尽可能抽出一点主线来吧，并且尽可能对比其它层的协议，这样能加深理解。首先要介绍的是MAC地址的概念。&lt;/p&gt;

&lt;h2 id=&#34;mac地址:7be74c584635419861677fc2502187c9&#34;&gt;MAC地址&lt;/h2&gt;

&lt;p&gt;其实MAC地址这个概念还是比较大众的，它的作用和网络层中的IP地址类似，是对链路层的唯一标示。你可能会问通过IP地址就已经能标示到唯一的主机（网络层接口了），何苦再加一层呢？原因比较复杂，这里就说一个我比较认同的理由，是为了分层，出于分层的考虑网络层的寻址和数据链路层的寻址就应该独立的，而且网络层也不仅仅是IP协议啊。&lt;/p&gt;

&lt;p&gt;介绍完MAC地址的作用，接下来要介绍的是MAC地址到底长什么样了。MAC地址是一个48位的二进制数（而IP地址仅有32位），一个网卡对应的MAC地址不是由什么协议动态分配的，而是出厂就设定好了的，换句话说MAC地址是物理层面一块网卡的唯一标示，类似于人的身份证号（对比IP地址，IP地址需要利用DHCP从DHCP获取）。&lt;/p&gt;

&lt;p&gt;有了之前传输层（源端口号、目的端口号）、网络层（源IP地址、目的IP地址）的经验，很自然我们会想到数据链路层的报文中会含有源MAC地址和目的MAC地址。源MAC地址很好获得，毕竟是网卡一出生就带有的，那目的MAC地址是如何获得的呢？这就需要请出ARP来了。&lt;/p&gt;

&lt;h2 id=&#34;arp:7be74c584635419861677fc2502187c9&#34;&gt;ARP&lt;/h2&gt;

&lt;p&gt;ARP协议的作用类似于DNS，根据IP地址返回对应的MAC地址。发送方构建ARP报文，包含源和目的IP、MAC地址。你可能会说，目的IP可以通过DNS、DHCP获得，这个目的MAC地址不是我们要查找的吗，怎么会在发送报文里出现（类似的问题在DHCP中也遇到过）。既然在DHCP中也遇到过，在那里我们提到了一个广播IP地址（255.255.255.255）的概念，我们很容易猜想到也应该有个广播MAC地址的概念，显然确实是有，对应为 &lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;，48位全为1，这样同一个局域网内的主机都会收到ARP报文，但是只有IP地址和目的地址一致的才会作出相应，返回MAC地址。&lt;/p&gt;

&lt;p&gt;源主机得到这条IP地址到MAC地址的映射关系之后，不会只用这么一次然后以后用到的时候再去查询一遍，而是维护一个ARP表表示这种映射关系。（类似结构的表已经见过不少次了，比如DNS、NAT、路由转发表）。&lt;/p&gt;

&lt;p&gt;上面介绍的时候我加了一个限制词：&lt;strong&gt;在同一个局域网内&lt;/strong&gt;，那要出了局域网怎么办？根据目的主机IP地址找对应的MAC地址？答案是不行的。要想出这个子网需要通过网关（通过DHCP可以获得默认网关IP地址，再通过ARP获得默认网关的的MAC地址），网关那里查询路由转发表，根据下一跳IP地址同样通过ARP获得相应的MAC地址，也就是说每经过一次路由器链路层的目的MAC地址都会被改写。&lt;/p&gt;

&lt;h2 id=&#34;以太网:7be74c584635419861677fc2502187c9&#34;&gt;以太网&lt;/h2&gt;

&lt;p&gt;局域网可以大体分为有线局域网和无线局域网，以太网几乎占领了有线局域网。&lt;/p&gt;

&lt;p&gt;仅仅从以太网帧的角度来看这并不复杂，以太网帧包含上层数据、源MAC地址、目的MAC地址、类型（类似于IP报文中的上层协议、TCP/UDP报文中的端口号）、CRC（功能上类似于各层的校验和字段，但是实现上不太一致）、前同步码。&lt;/p&gt;

&lt;p&gt;以太网比较复杂的一个问题是如何让多个节点共享一个广播链路，即多路访问问题。解决这个问题有许多方案，每个方案也有许多变种，目前的我认为没有必要去关心如何实现的，我们仅需知道能够解决碰撞带来的问题即可。&lt;/p&gt;

&lt;h2 id=&#34;链路层交换机:7be74c584635419861677fc2502187c9&#34;&gt;链路层交换机&lt;/h2&gt;

&lt;p&gt;让我们把目光集中到一个子网内，看一下子网内的主机是如何互联起来的。既然是子网内，就没有路由器什么事了，设备只有链路层交换机。每台主机与链路层交换机相连，链路层交换机既可以与主机相连，也可以与其他链路层交换机相连。对于主机而言，链路层交换机是透明的，在一个子网内传递报文，只需要目的主机的MAC地址与IP地址即可，不需要这个链路层交换机的MAC地址（链路层交换机本身不具有MAC地址这个概念）。数据到达链路层交换机，那链路层交换机根据什么决定到哪条出链路上的呢？这个问题形式上看起来很熟悉，路由器的转发功能和这个简直是如出一辙，路由器转发是根据路由转发表，路由转发表由路由协议进行维护更新，数据链路层也有一个类似的交换机表，但这个表中的数据不是由什么协议维护的，而是交换机自学习得到的。&lt;/p&gt;

&lt;p&gt;下面解释一下这个自学习是怎么回事。当一条数据通过接口A经过交换机的时候，交换机可以读取到报文中的源MAC地址B，这样在转发表中就记录一条 如果目的MAC地址是B，则通过A接口转发。这条记录也有一个类似TTL的概念，用于更新交换机表。&lt;/p&gt;

&lt;p&gt;当数据通过交换机时，如果在交换机表中有一条记录，那显然转发到响应接口上，根据上面说的自学习这点不难理解。如果没有相应记录，交换机就在所有链路上广播该报文，让主机自行决定是否是目的主机 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>终于bootstrap满足不了我了——用flex实现一个栅格系统</title>
      <link>http://jiangshanmeta.github.io/post/css/flex/</link>
      <pubDate>Sat, 13 Aug 2016 14:16:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/flex/</guid>
      <description>&lt;p&gt;bootstrap样式方面我觉得最重要的就是栅格系统了，然而在实际项目中觉得有些情况它所能提供的满足不了我的需求了。最近感受比较深的就是列表展示页面，每一个列表项对应的图片文字大小所需空间不一致，我的一个解决方案是利用CSS文字强制只显示一行或多行（不知道如何实现的自行百度），然后图片&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;放在一个正方形的盒子里展示&lt;/a&gt;，确实是一个解决问题的方法但我觉得不够优雅。其实根本问题出现在bootstrap的栅格系统是基于浮动的，每一个列高度不一致导致布局错乱显然是不可避免的。bootstrap也考虑到了这个问题，他们的解决方案是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;建议联合使用 .clearfix 和 响应式工具类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说的没错，只要在每行之间加上一个&lt;code&gt;.clearfix&lt;/code&gt;确实能解决问题。但是我显然是动态输出页面的啊，我还要手动写个计数器然后输出这个清除浮动的标签，总觉得略折腾。&lt;/p&gt;

&lt;p&gt;那既然问题是不等高造成的做个等高布局怎么样？ 说的就和等高布局好做似的。padding撑出去+margin缩回来方案hack意味太浓，table的同行单元格等高这一属性可以利用但是我还要输出表示行的标签，折腾程度差不多，响应式处理起来更折腾，那似乎就剩下flex了。但是对于flex float又直接失效。&lt;/p&gt;

&lt;p&gt;于是我想着干脆用flex模拟一个bootstrap的栅格系统，对于熟悉flex布局和bootstrap的同学这并不难。&lt;/p&gt;

&lt;p&gt;首先是container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
	box-sizing:border-box;
}
.flex-container {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
@media (min-width: 768px) {
  .flex-container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .flex-container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .flex-container {
    width: 1170px;
  }
}
.flex-container-fluid {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是每一列的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-12 {
	flex:0 0 100%;
}
.flex-col-xs-11 {
	flex:0 0 91.66666667%;
}
.flex-col-xs-10 {
	flex:0 0 83.33333333%;
}
.flex-col-xs-9 {
	flex:0 0 75%;
}
.flex-col-xs-8 {
	flex:0 0 66.66666667%;
}
.flex-col-xs-7 {
	flex:0 0 58.33333333%;
}
.flex-col-xs-6 {
	flex:0 0 50%;
}
.flex-col-xs-5 {
	flex:0 0 41.66666667%;
}
.flex-col-xs-4 {
	flex:0 0 33.33333333%;
}
.flex-col-xs-3 {
	flex:0 0 25%;
}
.flex-col-xs-2 {
	flex:0 0 16.66666667%;
}
.flex-col-xs-1 {
	flex:0 0 8.33333333%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是列的响应式处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media (min-width: 768px) {
	.flex-col-sm-12 {
		flex:0 0 100%;
	}
	.flex-col-sm-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-sm-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-sm-9 {
		flex:0 0 75%;
	}
	.flex-col-sm-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-sm-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-sm-6 {
		flex:0 0 50%;
	}
	.flex-col-sm-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-sm-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-sm-3 {
		flex:0 0 25%;
	}
	.flex-col-sm-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-sm-1 {
		flex:0 0 8.33333333%;
	}
}


@media (min-width: 992px) {
	.flex-col-md-12 {
		flex:0 0 100%;
	}
	.flex-col-md-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-md-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-md-9 {
		flex:0 0 75%;
	}
	.flex-col-md-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-md-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-md-6 {
		flex:0 0 50%;
	}
	.flex-col-md-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-md-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-md-3 {
		flex:0 0 25%;
	}
	.flex-col-md-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-md-1 {
		flex:0 0 8.33333333%;
	}

}

@media (min-width: 1200px) {
	.flex-col-lg-12 {
		flex:0 0 100%;
	}
	.flex-col-lg-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-lg-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-lg-9 {
		flex:0 0 75%;
	}
	.flex-col-lg-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-lg-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-lg-6 {
		flex:0 0 50%;
	}
	.flex-col-lg-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-lg-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-lg-3 {
		flex:0 0 25%;
	}
	.flex-col-lg-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-lg-1 {
		flex:0 0 8.33333333%;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列偏移部分，只列出了xs部分，没写响应式部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-offset-12 {
  margin-left: 100%;
}
.flex-col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.flex-col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.flex-col-xs-offset-9 {
  margin-left: 75%;
}
.flex-col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.flex-col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.flex-col-xs-offset-6 {
  margin-left: 50%;
}
.flex-col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.flex-col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.flex-col-xs-offset-3 {
  margin-left: 25%;
}
.flex-col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.flex-col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.flex-col-xs-offset-0 {
  margin-left: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列排序，和bootstrap一样，基于&lt;code&gt;position:relative&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-1,
.flex-col-xs-2,
.flex-col-xs-3,
.flex-col-xs-4,
.flex-col-xs-5,
.flex-col-xs-6,
.flex-col-xs-7,
.flex-col-xs-8,
.flex-col-xs-9,
.flex-col-xs-10,
.flex-col-xs-11,
.flex-col-xs-12{
	position:relative;
}

.flex-col-xs-pull-12 {
  right: 100%;
}
.flex-col-xs-pull-11 {
  right: 91.66666667%;
}
.flex-col-xs-pull-10 {
  right: 83.33333333%;
}
.flex-col-xs-pull-9 {
  right: 75%;
}
.flex-col-xs-pull-8 {
  right: 66.66666667%;
}
.flex-col-xs-pull-7 {
  right: 58.33333333%;
}
.flex-col-xs-pull-6 {
  right: 50%;
}
.flex-col-xs-pull-5 {
  right: 41.66666667%;
}
.flex-col-xs-pull-4 {
  right: 33.33333333%;
}
.flex-col-xs-pull-3 {
  right: 25%;
}
.flex-col-xs-pull-2 {
  right: 16.66666667%;
}
.flex-col-xs-pull-1 {
  right: 8.33333333%;
}
.flex-col-xs-pull-0 {
  right: auto;
}
.flex-col-xs-push-12 {
  left: 100%;
}
.flex-col-xs-push-11 {
  left: 91.66666667%;
}
.flex-col-xs-push-10 {
  left: 83.33333333%;
}
.flex-col-xs-push-9 {
  left: 75%;
}
.flex-col-xs-push-8 {
  left: 66.66666667%;
}
.flex-col-xs-push-7 {
  left: 58.33333333%;
}
.flex-col-xs-push-6 {
  left: 50%;
}
.flex-col-xs-push-5 {
  left: 41.66666667%;
}
.flex-col-xs-push-4 {
  left: 33.33333333%;
}
.flex-col-xs-push-3 {
  left: 25%;
}
.flex-col-xs-push-2 {
  left: 16.66666667%;
}
.flex-col-xs-push-1 {
  left: 8.33333333%;
}
.flex-col-xs-push-0 {
  left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个基于flex的栅格系统就差不多了，包含响应式布局、列偏移、列排序，其实还可以列嵌套，我其实还可以宣称自己基于移动优先的理念之类的。和bootstrap的栅格系统相比，还差点兼容性以及gutter的概念，这个没什么难的，就这样吧。&lt;/p&gt;

&lt;p&gt;还有，女神叫我出去浪，我却在这写博客，终于明白为什么我会孤独一生了。&lt;/p&gt;

&lt;p&gt;update 2016/08/17&lt;/p&gt;

&lt;p&gt;还是把&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.less&#34;&gt;less文件&lt;/a&gt;  和 &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.css&#34;&gt;编译出来的CSS文件放到这里吧&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>网际协议</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/ip/</link>
      <pubDate>Tue, 02 Aug 2016 23:26:56 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/ip/</guid>
      <description>

&lt;p&gt;IPv4协议&lt;/p&gt;

&lt;p&gt;计算机网络的网络层主要功能是&lt;strong&gt;转发&lt;/strong&gt;和&lt;strong&gt;路由&lt;/strong&gt;，转发是将分组从一个输入链路接口转移到合适的输出链路接口的路由器本地动作，路由是指网络范围内的过程，以决定分组从源到目的地所采取的端到端路径。&lt;/p&gt;

&lt;p&gt;合适的输出路径是如何确定的？输出链路是通过查询转发表根据&lt;strong&gt;最长前缀匹配规则&lt;/strong&gt;进行确定的。转发表是根据路由选择协议设定的，并且是动态更新的，换句话说，源和目的地址相同的两个IP报文，可能走不同的路线，因而不能保证先后顺序。&lt;/p&gt;

&lt;p&gt;那这个&lt;strong&gt;最长前缀匹配规则&lt;/strong&gt;又是什么？为了讲清楚这个，首先需要对IP地址有一定的基础了解。&lt;/p&gt;

&lt;h2 id=&#34;ipv4地址:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;IPv4地址&lt;/h2&gt;

&lt;p&gt;之前我&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;描述了计算机如何获取IP地址&lt;/a&gt;，在那里对IP地址做了最基本的描述。&lt;/p&gt;

&lt;p&gt;IPv4地址是一个32位的二进制数字，为了便于人类阅读，通常我们按照&lt;strong&gt;点分十进制记法&lt;/strong&gt;表示IP地址。一台主机的IP地址不是完全自由分配的，而是要根据其所在的子网进行分配。那么如何表示这个子网？如何表示子网大小？解决方案是将IP地址分为两部分，前面表示网络号，后面的表示主机号，表现为&lt;code&gt;a.b.c.d/x&lt;/code&gt;的形式。比如&lt;code&gt;233.233.233.0/24&lt;/code&gt;，这表示这个这个子网前24位是网络号，后面的8位才能分配给主机（有些特殊的号码不能分配，这个另说）。在window下查看当前所属子网前缀是多少位，可在cmd下输入&lt;code&gt;ipconfig&lt;/code&gt;，可以看到如下内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/ipconfig.jpg&#34; alt=&#34;ipconfig&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这显示我所在的子网前24位（子网掩码转换成二进制就是前24位都是1），图中所示的IP地址是&lt;code&gt;192.168.1.12&lt;/code&gt;，这是一个私有地址，全球现在应该有N个这么一个地址，这一点我稍后再说。&lt;/p&gt;

&lt;p&gt;在上古时期，还有A类网址、B类网址、C类网址的说法，从现在的角度来看就是上面说的几个特例而已，A类网址的子网掩码为&lt;code&gt;255.0.0.0&lt;/code&gt;，也就是说前八位为网络号，后24位为主机号，A类网址每个子网很大但是数量上比较少。B类网址子网掩码为&lt;code&gt;255.255.0.0&lt;/code&gt;，前16位为网络号，后16位为主机号，C类网址子网掩码为&lt;code&gt;255.255.255.0&lt;/code&gt;，我当前所属的就是个C网，前24位为网络号，后8位为主机号。C网数量很多但是每个子网的规模较小。其实对于A类网址、B类网址、C类网址，还有IP地址范围的限制，分别对应&lt;code&gt;0.0.0.0&lt;/code&gt;——&lt;code&gt;127.255.255.255&lt;/code&gt;、&lt;code&gt;128.0.0.0&lt;/code&gt;——&lt;code&gt;191.255.255.255&lt;/code&gt;、&lt;code&gt;192.0.0.0&lt;/code&gt;——&lt;code&gt;223.255.255.255&lt;/code&gt;。看到这你可能会问，应该还有空缺的位置啊，其实还有D类网址、E类网址，但是都不能作为公网地址。&lt;/p&gt;

&lt;p&gt;IP地址中还有一些特殊值，先以表格的形式归纳在这里&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;网络号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;主机号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;做源&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;做目标&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在本网内部表示本机&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;本网内广播地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;特定值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;网络地址，表示一个网络&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;特定值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;直接广播地址，对特定网络进行广播&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;127&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;非全0或非全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;本地环回地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于前两个，在学习&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;&lt;strong&gt;DHCP&lt;/strong&gt;&lt;/a&gt;中已经遇到过了，&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，只能做源，&lt;code&gt;255.255.255.255&lt;/code&gt;表示本子网内的广播地址。后两个其实可以和前两个类比看，主机号全0表示当前网络，全1表示对这个网络进行广播，从另一个层面上看，不是所有合法数字都可以分配作为主机号，对于我这个C类网络，有8位主机号，并不意味着可以容纳2^8=256个ip，而是2^8-2=254个。最后一个对于搞web开发的人其实很熟悉，大家经常会看到&lt;code&gt;127.0.0.1&lt;/code&gt;就是一个环回地址。&lt;/p&gt;

&lt;p&gt;除了上面说的限制，还有私有地址的概念，上面截图中所示我的ip地址就处于一个私有网络中，对于A类网址、B类网址、C类网址，每一个均有一块作为私有地址，不能作为公网地址使用，C网的对应 &lt;strong&gt;192.168.0&lt;/strong&gt;——&lt;strong&gt;192.168.255&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然谈到私有地址的话题的，那我问个问题，为了实现主机到主机的逻辑通信，需要ip标示唯一主机，但是一个私有地址可以对应多台主机，那该怎么办？我们需要把私有地址映射到公有地址上去，这就需要下面要介绍的&lt;strong&gt;NAT&lt;/strong&gt;了。&lt;/p&gt;

&lt;h2 id=&#34;nat:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;NAT&lt;/h2&gt;

&lt;p&gt;NAT全称是网络地址转换，它的作用可以这么理解：NAT相当于是对整个子网进行了封装，在外界看来这个子网就像是一台主机，而不是多台设备。&lt;/p&gt;

&lt;p&gt;互联网的通信最终是应用进程和应用进程的通信，我们需要ip地址和端口号标示唯一的一个主机上的特定应用进程。使用了NAT，网络层报文的ip地址在路由器上被改写成路由器在公网上的地址，解决了私有地址不能在公网出现的问题，目标主机会把这台路由器当成是源主机看待，但是路由器上并不存在端口号对应的应用进程，我们需要把目标主机的返回报文传给真正的源主机，那又如何找到源主机呢？&lt;/p&gt;

&lt;p&gt;其实在报文进入公网的时候，不仅仅是ip地址被重写了，端口号也被重写了，新端口号和源主机ip及端口号的映射关系保存在&lt;strong&gt;NAT&lt;/strong&gt;转换表中。通过查询这张表即可找到源主机ip及源端口号。&lt;/p&gt;

&lt;p&gt;这么说可能比较晦涩，举个例子，我使用的这台主机的ip &lt;code&gt;192.168.1.12&lt;/code&gt;，在端口号2333发送一个报文到公网某个主机某个端口，这个地址是私有地址，通过了&lt;strong&gt;NAT路由器&lt;/strong&gt;之后网络层报文 源ip地址字段被修改成了路由器的公网ip，比如&lt;code&gt;233.233.233.233&lt;/code&gt;，然后根据源主机ip&lt;code&gt;192.168.1.12&lt;/code&gt;和源端口号2333生成一个新的端口号 5678，并在路由器中保存类似&lt;code&gt;5678=&amp;gt;[&#39;ip&#39;=&amp;gt;&#39;192.168.1.12&#39;,&#39;port&#39;=&amp;gt;2333]&lt;/code&gt;这样的一条记录，对于目的主机，它认为与自己通信的主机ip是&lt;code&gt;233.233.233.233&lt;/code&gt;，端口号是5678。到了&lt;strong&gt;NAT路由器&lt;/strong&gt;这里，发现端口号是5678，从&lt;strong&gt;NAT转换表&lt;/strong&gt;中找到真实源主机ip&lt;code&gt;192.168.1.12&lt;/code&gt;和真实端口号2333，然后修改报文把信息传给相应的进程。&lt;/p&gt;

&lt;p&gt;关于NAT其实有很多争议，作为强迫症晚期患者我最不能忍的是路由器这里竟然修改了传输层首部字段中的源端口号，说好的只到网络层呢。&lt;/p&gt;

&lt;h2 id=&#34;ipv4报文:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;IPv4报文&lt;/h2&gt;

&lt;p&gt;IPv4报文和传输层报文结构上很类似，都是上层传过来的数据加上一堆自己的首部。前面已经提到了IPv4报文中含有源主机IP地址，下面具体讲一下IPv4报文的首部字段。&lt;/p&gt;

&lt;p&gt;首先源主机IP地址和目的主机IP地址，这个就类似于传输层报文中的端口号，用于标示通信的主机。&lt;/p&gt;

&lt;p&gt;传输层用端口号标示要把报文向上传递到哪里，对于IPv4报文，起到类似作用的是一个上层协议字段，网络层通过这个字段知道把报文传到TCP还是UDP还是其他。&lt;/p&gt;

&lt;p&gt;类似于TCP报文，IPv4报文也包含一些选项（虽然基本用不上），所以需要首部长度字段表明首部的长度信息，一般的IPv4报文具有20字节的首部，即不包含任何的选项。这里我们可以比较一下UDP报文、TCP报文和IPv4报文：TCP报文和IPv4报文都具有可选的首部，所以需要首部长度字段来反应可选字段的使用情况跟，而UDP报文首部字段的数量是一定的，因而不需要这个字段。UDP报文和IPv4报文都有一个报文长度字段，但是TCP却没有，这又是为什么？因为TCP提供面向连接的可靠地数据传输，它有确认字段表明哪些字段被成功接收到了，而UDP和IPv4没有连接什么事，你不告诉对方你发了多少数据对方怎么知道要接收多少、处理多少。&lt;/p&gt;

&lt;p&gt;update 2016/08/11 稍微看了一下数据链路层的知识，这里补充一下，对于以太网的数据报文，其对所包含的数据有最小长度限度，如果长度不足会补齐，但这些填充的数据也会被提交给网络层的IP，因而需要长度字段找出哪些是真正的数据，哪些是填充。&lt;/p&gt;

&lt;p&gt;而TCP、UDP、IPv4报文都含有校验和字段检测比特错误，不过IPv4和UDP都不具有差错恢复机制，IPv4会通过下面要说的&lt;strong&gt;ICMP&lt;/strong&gt;进行报错。&lt;/p&gt;

&lt;p&gt;下面介绍的几个字段就比较复杂了，他们是 标识、标志、片偏移。之所以出现三个字段是因为网络层的下层数据链路层，因为数据链路层对于数据包的大小有不同的要求，可能出现这样的情况：输入链路的能容得下数据包，但是输出链路容不下，那怎么办，总不能把数据包就这么丢了是吧。于是路由器会把IPv4报文进行进一步分割成片，使输出链路能容得下，在最终的端系统中对分出来的片进行组装。标识字段相当于是IPv4报文的一个id，表明那些片是属于同一个IP报文里的，标志字段有两个作用，一个是表明允不允许进行分片操作，如果不允许容不下的情况下只能丢掉了，另一个作用是表明是否是最后一个分片。片偏移字段表示的是在原数据报中的位置。通过上面三个字段，我们就能把数据从片还原成原来的IP报文。&lt;/p&gt;

&lt;p&gt;在上面我一直在写IPv4报文，但是大家熟悉的不是IP吗，为啥我要强调v4，这牵扯到版本字段了，其实IPv6这个概念应该也不陌生，到这里就说出关键点了，有两种版本的IP报文格式，所以需要版本字段表明按哪种格式去解读报文。&lt;/p&gt;

&lt;p&gt;最后要介绍的是寿命字段，每经过一台路由器时，这个字段就要减1，当减到零的时候该数据报就要被丢弃。&lt;/p&gt;

&lt;h2 id=&#34;icmp:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;ICMP&lt;/h2&gt;

&lt;p&gt;ICMP通常被认为是IP的一部分，但是从体系结构上讲它应该和TCP、UDP并列，话句话说，ICMP报文是作为IP报文的有效载荷的，ICMP的主要功能是进行差错报告。&lt;/p&gt;

&lt;h2 id=&#34;从传输层角度看网络层:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;从传输层角度看网络层&lt;/h2&gt;

&lt;p&gt;网络层通过网际协议实现了转发功能，通过路由选择协议实现路由功能，然而路由选择的东西真的看起来比较虐心，我们先就只关心网际协议吧。&lt;/p&gt;

&lt;p&gt;对于传输层，把需要传输的东西交给网络层，然后坐等网络层把数据交给自己，但是网络层有时候并不能把一些数据传送给传输层，这里就根据我个人的理解，说一下网络层不能把数据传送给传输层的原因。&lt;/p&gt;

&lt;p&gt;第一个原因是在路由器因为排队原因发生的丢包。毕竟路由器处理能力是有限的。&lt;/p&gt;

&lt;p&gt;第二个原因是数据错误，丢弃数据包，主要是利用校验和字段。&lt;/p&gt;

&lt;p&gt;第三个原因是分片无法被组装。&lt;/p&gt;

&lt;p&gt;第四个原因是因为寿命字段被减为零，路由器丢弃数据包，出现这个现象的原因可能是转发表错误进入了网络中的无限循环。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DHCP</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/dhcp/</link>
      <pubDate>Mon, 01 Aug 2016 19:40:53 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/dhcp/</guid>
      <description>&lt;p&gt;在学习传输层的基本知识的时候，知道了传输层实现不同主机应用进程之间的逻辑通信，当时还与网络层比较，网络层实现的是不同主机间的逻辑通信，标记应用进程用端口号，标记主机用IP。严格来说IP标记的接口（主机与物理链路的边界），而不是主机与路由器（换句话说一台主机或者路由器可能有多个接口，对应多个IP），我这里并不严格区分。&lt;/p&gt;

&lt;p&gt;IP地址其实是IP（网际协议）的一部分，对于IP地址，即使是不搞计算机相关领域的人也应该听说过，我们一般写作形如 233.233.233.233 的形式，但这本质上是一个32位的二进制数，只是我们每8位看成一个整体，转换成十进制数字，才有了上面的形式。那一台主机刚接入计算机网络的时候，是如何获得IP地址的呢？&lt;/p&gt;

&lt;p&gt;一个方法是手动设置，在window下可以在如下界面进行设置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/manualip.jpg&#34; alt=&#34;手动设置ip&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过对于广大人民群众（包括我）还是利用 &lt;strong&gt;DHCP&lt;/strong&gt; 动态获取IP地址的。下面的内容是描述如何通过 &lt;strong&gt;DHCP&lt;/strong&gt; 获取一个IP地址。&lt;/p&gt;

&lt;p&gt;首先，DHCP服务器发现。动态获得IP是通过&lt;strong&gt;DHCP服务器&lt;/strong&gt;分配的，对于一台新接入的计算机，显然要先找到这台服务器，那么问题来了，我怎么知道&lt;strong&gt;DHCP服务器&lt;/strong&gt;的IP（毕竟无论如何需要建立主机之间的逻辑通信）？答案是不知道，那就拿个大喇叭广播，我们使用 &lt;code&gt;255.255.255.255&lt;/code&gt; 作为目的地址，这样报文就会交付给同一个子网所有主机，并且此时这台主机没有IP地址，所以源地址是 &lt;code&gt;0.0.0.0&lt;/code&gt;。这时发送的报文称为 &lt;strong&gt;DHCP发现报文&lt;/strong&gt;，顺便说一句DHCP是基于UDP的。&lt;/p&gt;

&lt;p&gt;然后，DHCP服务器提供。广播的 &lt;strong&gt;DHCP发现报文&lt;/strong&gt; 子网内所有主机都会收到，但是只有 &lt;strong&gt;DHCP服务器&lt;/strong&gt; 会去做出响应。响应的报文称为 &lt;strong&gt;DHCP提供报文&lt;/strong&gt;，在这个报文中，源地址是这台服务器的地址，这点毫无疑问，目标地址是 &lt;code&gt;255.255.255.255&lt;/code&gt;，因为请求的主机此时还没有IP地址。那么问题来了，要接入网的主机通过什么知道这条信息是给自己的而不是给其它接入网的主机？通过 &lt;code&gt;transaction id&lt;/code&gt;，在&lt;strong&gt;DHCP发现报文&lt;/strong&gt; 里就包含这一信息，然后在 &lt;strong&gt;DHCP提供报文&lt;/strong&gt; 原样返回&lt;code&gt;transaction id&lt;/code&gt;。&lt;strong&gt;DHCP提供报文&lt;/strong&gt;里还会包含着一个分配到新客户的ip地址。&lt;/p&gt;

&lt;p&gt;随后，DHCP请求。由于一个子网可能会有多个&lt;strong&gt;DHCP服务器&lt;/strong&gt;，所以一条&lt;strong&gt;DHCP发现报文&lt;/strong&gt;可能会对应多条&lt;strong&gt;DHCP提供报文&lt;/strong&gt;，也就可能对应多个推荐ip地址。客户端需要选择一个最终的ip，发送&lt;strong&gt;DHCP请求报文&lt;/strong&gt;，因为可能有多个&lt;strong&gt;DHCP服务器&lt;/strong&gt;，所以采用的目的ip仍然是&lt;code&gt;255.255.255.255&lt;/code&gt;，通知最终结果，便于其他&lt;strong&gt;DHCP服务器&lt;/strong&gt;及时回收发出去的冗余ip地址。&lt;/p&gt;

&lt;p&gt;最后，DHCP服务器用 &lt;strong&gt;DHCP ACK报文&lt;/strong&gt;响应，进行最终确认。这样这台新接入的主机就获得了一个ip地址，同时获得的还有本地DNS服务器地址、网关地址。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS中一些“奇技淫巧”</title>
      <link>http://jiangshanmeta.github.io/post/css/csstricks/</link>
      <pubDate>Sun, 31 Jul 2016 20:28:36 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/csstricks/</guid>
      <description>

&lt;p&gt;声明一下，这里的奇技淫巧是指自己用得少觉得新奇而且有实际应用场景的CSS属性，而不是诸如用CSS画个IE8不支持的IE8图标之类的纯粹为了炫技然而实际没什么用途的黑魔法。&lt;/p&gt;

&lt;h4 id=&#34;1-currentcolor:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;1.currentColor&lt;/h4&gt;

&lt;p&gt;这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/&#34;&gt;张鑫旭大神已经给了几个&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-user-select:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;2.user-select&lt;/h4&gt;

&lt;p&gt;知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用&lt;code&gt;user-select:none;&lt;/code&gt;，这样对于普通用户连选择都做不到。&lt;/p&gt;

&lt;p&gt;不过这个属性兼容性有点差，在&lt;a href=&#34;http://caniuse.com/#search=user-select%3A&#34;&gt;can I use&lt;/a&gt;上查到的信息是目前还是乖乖加上私有前缀吧。&lt;/p&gt;

&lt;h4 id=&#34;3-selection:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;3.::selection&lt;/h4&gt;

&lt;p&gt;在CSS中伪元素常用的只有&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;,&lt;code&gt;::selection&lt;/code&gt;就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。&lt;/p&gt;

&lt;p&gt;本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。&lt;/p&gt;

&lt;h4 id=&#34;4-pointer-events-none:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;4.pointer-events:none&lt;/h4&gt;

&lt;p&gt;这个CSS让js和CSS的边界越来越模糊。想象这么一个场景：要做一个活动页，需要全屏的canvas绘制一些东西，这个canvas相当于一个遮罩层，但是我又想遮罩层下面的元素响应各种事件，尤其是点击事件。想通过js完成这件事目测要写一堆，但是对这个遮罩层使用&lt;code&gt;pointer-events:none&lt;/code&gt;即可让这个遮罩层不响应点击事件。&lt;/p&gt;

&lt;h4 id=&#34;5-content的attr:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;5.content的attr&lt;/h4&gt;

&lt;p&gt;伪元素大家应该不陌生了，但是伪元素的content属性我一般用的不多，后来发现一篇文章&lt;a href=&#34;http://web.jobbole.com/86079/&#34;&gt;美化加载失败的图片&lt;/a&gt;发现了content属性的一些玩法。我们可以通过attr属性引入一些属性的内容，比如&lt;code&gt;img::after{content:&#39;[&#39;attr(src)&#39;]&#39;}&lt;/code&gt;，这样就能在图片加载不出来的时候把原始图片地址显示出来（虽然我怀疑用户能否理解）。类似的思路，我们可以显示a标签的href属性&lt;code&gt;a::after{content:attr(href)}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;今天发现了一个&lt;a href=&#34;http://codepen.io/airen/pen/jrNBKp&#34;&gt;attr结合data的一个demo&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-direction:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;6.direction&lt;/h4&gt;

&lt;p&gt;这个属性有用的只有两个值：&lt;code&gt;ltr&lt;/code&gt;、&lt;code&gt;rtl&lt;/code&gt;，含义分别是从左向右和从右向左。猜也能猜出来默认值是&lt;code&gt;ltr&lt;/code&gt;。或许你会认为应用&lt;code&gt;rtl&lt;/code&gt;后会改变文字排版变成从右向左排布，然而那是&lt;code&gt;writing-mode&lt;/code&gt;的工作（顺便说一句，目前文字排版的常规模式是从左到右从上到下，除了搞两句古诗词的文艺小清新我觉得没人会闲的改变这种模式）。那么这个&lt;code&gt;direction&lt;/code&gt;改变的是什么的方向？ 改变的是&lt;strong&gt;内联元素块&lt;/strong&gt;的左右顺序，而内联元素块内部的元素是当做一个整体看待。换句话说，&lt;code&gt;direction&lt;/code&gt;属性可以在不改变DOM前后顺序的前提下改变内联元素块的前后顺序，听着好像低配版的flex布局的&lt;code&gt;order&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;干什么用呢？&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/03/css-direction-introduction-apply/&#34;&gt;张鑫旭大神提供了例子&lt;/a&gt;，在不改变DOM的情况下添加类名改变弹框组件的按钮顺序。&lt;/p&gt;

&lt;h4 id=&#34;7-padding:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;7.padding&lt;/h4&gt;

&lt;p&gt;关于padding作为前端应该都不陌生，但是padding本身也是具有奇技淫巧的。&lt;/p&gt;

&lt;p&gt;之前我利用padding实现了&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;自适应的正方形和长宽比一定的长方形&lt;/a&gt;，今天学了一手新的，结合&lt;code&gt;padding&lt;/code&gt;以及&lt;code&gt;background-clip&lt;/code&gt;绘制图形。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/csstricks/padding.html&#34;&gt;在线demo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;在bootstrap导航条组件中，有一个三道杠的图标，他们的实现是使用三个span元素做的，根据张鑫旭大神的思路，这里使用一个div就完成了。对于这个需求，其实也可以通过伪元素来实现。&lt;/p&gt;

&lt;p&gt;另外还有一些视频进度条的圆环，我结合伪元素、圆角、padding、background-clip也实现了。对于这一需求，也可以通过&lt;code&gt;box-shadow&lt;/code&gt;来实现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php中exit()的一个用法——记一次无聊的封装</title>
      <link>http://jiangshanmeta.github.io/post/php/exit/</link>
      <pubDate>Thu, 28 Jul 2016 19:00:23 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/exit/</guid>
      <description>&lt;p&gt;熟悉最好的编程语言php（手动滑稽）的人应该对于&lt;code&gt;exit()&lt;/code&gt;或者&lt;code&gt;die()&lt;/code&gt;函数不陌生，根据&lt;a href=&#34;http://php.net/manual/zh/function.die.php&#34;&gt;手册的说法&lt;/a&gt;这两个函数其实是别名关系，功能上是一样的。一般这两个函数是在调试的时候用的比较多，我的一个同事就比较习惯用&lt;code&gt;die()&lt;/code&gt;，然而作为前端入行的我显然是更习惯使用&lt;code&gt;return&lt;/code&gt;的方式进行调试。其实我对php的最主要调试方法是写两行然后用&lt;code&gt;var_dump()&lt;/code&gt;调试，一小步一小步往前推进。对于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数，有的人认为出错了用前者，提前退出用后者，我觉得没有太大的必要去区分这一点。&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数的用法，我觉得这一句话说得很好&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在设计工具类和工具函数时，die()/exit() 应该严令禁止，因为它们无权决定整个程序的生死。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这句话其实也反映了这两个函数与&lt;code&gt;return&lt;/code&gt;的区别，前者是程序级别的，后者仅仅是函数级别的。&lt;/p&gt;

&lt;p&gt;在我们的项目中后端是一个MVC框架(就是CI)，model层会根据前端传过来的各种信息进行初始化，为了容错，controller里经常会有这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!$this-&amp;gt;dataInfo-&amp;gt;is_inited){
	$jsonRst = -1;
	$jsonData = array();
	$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
	echo $this-&amp;gt;exportData($jsonData,$jsonRst);
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码是ajax请求时常用的代码，然而，一个controller里的action里面可能会加载多个model，这样上面的代码就会重复N遍，以至于可能真正的业务部分真的没有几行大部分都是在容错，虽说每次都是复制粘贴，但复制粘贴多了就想着封装这个功能。&lt;/p&gt;

&lt;p&gt;需求就有了，我希望能在model层里面封装一个小方法，专门用来检查初始化是否成功，如果初始化失败返回数据错误，controller里的其他代码就不运行了。为什么要单独写一个函数而不是封装在初始化函数中呢？一是因为初始化是初始化、查错是查错，二是因为上面的的代码只适用于ajax返回错误。那&lt;code&gt;return false;&lt;/code&gt;能不能满足我的需求？答案是不能，这只是终止这个小方法的运行，controller还会继续，除非手动写ifelse判断，然而这样和没封装似乎也差不了几行。我的解决方案是使用&lt;code&gt;exit()&lt;/code&gt;,这样如果初始化失败controller里的代码也不会往下走了。最终封装在model基类里的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function check_inited_for_ajax{
	$CI =&amp;amp; get_instance();
	if(!$this-&amp;gt;is_inited){
		$jsonRst = -1;
		$jsonData = array();
		$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
		echo $CI-&amp;gt;exportData($jsonData,$jsonRst);
		exit();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，对于非ajax请求，可以封装一个类似的函数，导入到404页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function check_inited_for_href(){
    $CI =&amp;amp; get_instance();
    if(!$this-&amp;gt;is_inited){
        $CI-&amp;gt;topTyp = &amp;quot;gobacktop&amp;quot;;
        $CI-&amp;gt;top_title = &amp;quot;出错啦&amp;quot;;
        echo $CI-&amp;gt;load-&amp;gt;view(&#39;default_page&#39; ,[&#39;contents&#39;=&amp;gt;$CI-&amp;gt;load-&amp;gt;view(&#39;common/notFound&#39;,[],true)], true);
        exit();
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的项目中有一个Template类，是对CI的load-&amp;gt;view进行的封装，通常想要加载一个页面是这样写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;template-&amp;gt;load(&#39;default_page&#39;, &#39;activity/showLottery&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最开始想在加载404页面的时候使用这个类，但一直无法输出页面，当时对于CI的理解还很浅，所以上面的&lt;code&gt;check_inited_for_href&lt;/code&gt;方法输出页面那一行写的很难读，现在明白默认条件下是在output类进行输出页面的，输出页面这个动作在controller执行完成后，但是如果初始化失败就在controller里退出脚本了，显然不会输出页面。&lt;/p&gt;

&lt;p&gt;修改后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function check_inited_for_href(){
    $CI =&amp;amp; get_instance();
    if(!$this-&amp;gt;is_inited){
        $CI-&amp;gt;topTyp = &amp;quot;gobacktop&amp;quot;;
        $CI-&amp;gt;top_title = &amp;quot;出错啦&amp;quot;;
        echo $CI-&amp;gt;template-&amp;gt;load(&#39;default_page&#39;, &#39;common/404&#39;,&#39;&#39;,TRUE);
        exit();
    }
    return $this;       
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>http连接控制</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/</link>
      <pubDate>Tue, 26 Jul 2016 20:57:58 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/</guid>
      <description>

&lt;p&gt;http是一个应用层协议，http所依赖的传输层协议是TCP，对于http，只需要把需要传递的信息通过套接字socket传递给传输层的TCP，然后就可以坐等TCP可靠的把数据传到目标主机的目标进程了，至于TCP是如何处理数据如何传输的，从应用层角度并不需要关心，&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;我之前也对TCP如何实现功能给出了最简单的描述&lt;/a&gt;。然而http事务的性能很大程度上依赖TCP的性能，毕竟现在这个年代在端系统上处理数据一般很快，慢的是传输数据。那我们先看一下TCP哪些动作会引起时延，然后看提高http连接性能的技术。&lt;/p&gt;

&lt;h2 id=&#34;tcp引起时延的动作:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;TCP引起时延的动作&lt;/h2&gt;

&lt;h4 id=&#34;建立tcp连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;建立TCP连接&lt;/h4&gt;

&lt;p&gt;TCP是面向连接的，TCP在正式发送应用层信息之前需要与服务器端建立连接，建立连接的过程通常称为&lt;strong&gt;三次握手&lt;/strong&gt;，首先客户端发送一个&lt;strong&gt;SYN报文&lt;/strong&gt;请求建立连接、并携带一些初始化数据，服务器同意建立连接发送一个&lt;strong&gt;SYNACK报文&lt;/strong&gt;，上面说的两个报文都没有传递应用层的信息，只是为了建立连接交换一些必要的数据，直到第三次握手才传输应用层信息。&lt;/p&gt;

&lt;h4 id=&#34;延迟确认:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;延迟确认&lt;/h4&gt;

&lt;p&gt;为了实现可靠传输，TCP采取了累积确认机制，但是确认功能和传递应用层信息是两个不同的功能，仅仅为确认报文正确到达就发送一个TCP报文是不合算的，所以会等待要发送的应用层信息，尝试捎带确认信息。这一机制成为&lt;strong&gt;延迟确认&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;慢启动:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;慢启动&lt;/h4&gt;

&lt;p&gt;慢启动其实是TCP拥塞控制的一部分，在TCP连接的一开始传输速率其实是比较低的，随着通信的进行在一定速率范围内传输速率呈指数增长。&lt;/p&gt;

&lt;h2 id=&#34;提高http连接性能的技术:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;提高http连接性能的技术&lt;/h2&gt;

&lt;p&gt;上面提到的建立TCP连接的时间是不可避免的，但是我们可以通过一个TCP连接传递多条http报文的方式，使得每一个http报文所分摊的建立连接时间缩短。慢启动也不可避免，也可以通过和上面一样的方式重复利用同一个连接，减少慢启动带来的消耗。下面介绍三种提高http连接性能的方法。&lt;/p&gt;

&lt;h4 id=&#34;并行连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;并行连接&lt;/h4&gt;

&lt;p&gt;单个TCP连接的传输速率有限，但是如果是多个TCP连接一起运行速率就有可能提升。同时多个TCP连接比较消耗内存，所以浏览器在使用并行连接的同时，限制并行TCP连接的数量。&lt;/p&gt;

&lt;h4 id=&#34;持久连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;持久连接&lt;/h4&gt;

&lt;p&gt;一个TCP连接首先要通过三次握手，然后要经过慢启动才能以一个适合的速率传递报文，如果传递完一份应用层信息就关闭连接，岂不是太浪费了，所以就有了持久连接的技术，传递完一份应用层报文后并不立即关闭TCP连接。&lt;/p&gt;

&lt;p&gt;在http/1.1中，在现在这个年代已经不需要考虑http/1.0了，默认采用了持久连接的技术，你可能会在http请求头或者响应头中看到这样的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在http/1.1中，客户端假定收到响应后，除非响应中包含&lt;code&gt;Connection: close&lt;/code&gt;，不然http/1.1连接仍维持打开状态。但是，客户端和服务器仍然可以随时关闭TCP连接，也就是说，&lt;code&gt;Connection: keep-alive&lt;/code&gt;是一个不可靠的保证。&lt;/p&gt;

&lt;h4 id=&#34;管道化连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;管道化连接&lt;/h4&gt;

&lt;p&gt;管道化连接是在持久连接的基础上的一项技术，在一条报文发出之后，在等待响应之前可以继续发送其他报文，提高连接的利用效率。&lt;/p&gt;

&lt;p&gt;管线化操作产生了顺序问题，TCP采用了&lt;strong&gt;回退N步&lt;/strong&gt;和&lt;strong&gt;选择重传&lt;/strong&gt;杂合的方式最终实现管道化连接。&lt;/p&gt;

&lt;p&gt;这篇文章没有从功能角度来描述TCP，而是从性能角度，讨论了影响TCP传输性能的几个因素，并给出了一些成熟提高传输性能的方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初识传输层</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/transportlayer/</link>
      <pubDate>Sun, 24 Jul 2016 20:36:07 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/transportlayer/</guid>
      <description>

&lt;p&gt;传输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。作为WEB开发者虽然并不直接接触传输层，但是了解一下基本原理对于理解应用层还是有帮助的。&lt;/p&gt;

&lt;h2 id=&#34;传输层的功能:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;传输层的功能&lt;/h2&gt;

&lt;p&gt;传输层的功能是为不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;。注意这里是逻辑通信，而不是物理通信，传输层是在端系统中实现的而不是在路由器中实现的。在发送端，传输层将从应用进程收到的报文转换成传输层报文段，添加传输层首部。在接收端，网络层从数据报中提取传输层报文，并将其交给传输层。传输层处理收到的报文段，为应用层提供数据。&lt;/p&gt;

&lt;p&gt;常见的传输层协议有UDP和TCP。UDP为应用层提供了不可靠、无连接的服务，而TCP提供了可靠、面向连接的服务。&lt;/p&gt;

&lt;h2 id=&#34;多路复用-多路分解:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;多路复用/多路分解&lt;/h2&gt;

&lt;p&gt;应用层和传输层之间不是直接交换数据，而是通过套接字socket。每一个套接字都有唯一标识符。&lt;/p&gt;

&lt;p&gt;为了在不同主机之间标示套接字，需要在传输层报文中有几个字段。在接收端，传输层检查这些字段，标识出接收套接字，进而将报文段定向到套接字。将传输层报文中的数据交付到正确的套接字的工作称为&lt;strong&gt;多路分解&lt;/strong&gt;。从源主机中不同套接字中收集数据块，为其封装首部信息，然后将报文段传给网络层，这些工作称为&lt;strong&gt;多路复用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在UDP中一个套接字是通过 目的IP和目的端口号标示的。在TCP中一个套接字是通过 源IP地址、源端口号、目的IP地址、目的端口号标示的。&lt;/p&gt;

&lt;h2 id=&#34;udp协议:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;UDP协议&lt;/h2&gt;

&lt;p&gt;UDP协议为应用层提供了不可靠、无连接的服务。UDP是应用层协议比较简单的实现，能提供的功能仅有多路复用/多路分用和差错检验。&lt;/p&gt;

&lt;p&gt;先说一下UDP报文的结构。传输层报文是在应用层报文基础上添加了首部信息，即传输层报文 = 传输层首部 + 应用信息。我们的关注点显然是首部字段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/udp.jpg&#34; alt=&#34;UDP报文结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;UDP有四个首部，分别是：源端口号、目的端口号、长度、校验和。源端口号和目的端口号是多路复用/多路分用的基础，长度字段指明了UDP报文的字节数（首部+数据）。校验和是为了差错检验功能。然而不幸的是UDP协议仅仅能够发现错误，但无法从错误中恢复出来，所以UDP协议无法提供可靠地数据传输。&lt;/p&gt;

&lt;p&gt;应用UDP协议的应用，一般是对数据可靠性要求没那么高的，比如DNS查询、网络电话、在线直播之类的。&lt;/p&gt;

&lt;h2 id=&#34;可靠数据传输原理:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;可靠数据传输原理&lt;/h2&gt;

&lt;p&gt;这个问题说实话有点大了，其实写一个系列丛书讨论这个问题都不为过。我这里就说点总结性的。&lt;/p&gt;

&lt;p&gt;为了检验数据是否有差错，采用了校验和。&lt;/p&gt;

&lt;p&gt;为了返回检查结果和接受信息，采用了反馈机制。&lt;/p&gt;

&lt;p&gt;为了处理丢包，采用了超时机制。&lt;/p&gt;

&lt;p&gt;为了处理数据错误和丢包，采用了重传机制（重传大法好）。&lt;/p&gt;

&lt;p&gt;为了标识每一个分组、处理冗余分组、检测丢包，采取了序号。&lt;/p&gt;

&lt;p&gt;为了解决管线化操作中的差错恢复，出现了回退N步和选择重传。&lt;/p&gt;

&lt;h2 id=&#34;tcp报文与tcp连接:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP报文与TCP连接&lt;/h2&gt;

&lt;p&gt;TCP相较于UDP，具有面向连接、可靠传输、流量控制、拥塞控制的功能，显然其所添加的首部字段更加复杂。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/tcppost.png&#34; alt=&#34;TCP报文结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;源端口号和目的端口号是多路复用/多路分用的基础，显然TCP报文也会具有这两个字段。与UDP报文类似，TCP报文也具有检验和字段，用于检验比特错误。TCP具有序号和确认号两个字段，用于实现可靠的数据传输。接收窗口字段，用于流量控制。SYN、FIN字段用于建立连接和结束连接。ACK字段用于指示确认字段中的值是有效的。&lt;/p&gt;

&lt;p&gt;TCP是面向连接的，我们首先要看的是如何建立TCP连接。&lt;/p&gt;

&lt;p&gt;首先客户端TCP向服务器TCP发送一个特殊的TCP报文，该报文段不包含任何应用层传来的数据，但是在报文首部SYN字段标为1，因此这个特殊的报文被称为&lt;strong&gt;SYN报文段&lt;/strong&gt;。在序号字段中，会填入客户端随机产生的初始序号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/tcpestablish.jpg&#34; alt=&#34;三次握手&#34; /&gt;&lt;/p&gt;

&lt;p&gt;服务器端接收到这个建立连接的请求后会发送一个同意建立连接的响应报文。这个响应报文也不包含应用层信息，但是SYN字段标为1，确认字段为客户端传来的初始序号+1，ACK字段标为1表示确认字段有效，服务器会根据源IP、源端口号、目的主机、目的端口号以及其他信息利用散列函数生成一个服务器的初始序号，放到响应报文的序号字段中。因为SYN和ACK两个字段都被标为1，因此这个返回报文也被称为&lt;strong&gt;SYNACK报文段&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端收到服务器发回来的响应报文，明白了服务器同意建立连接，发送第三个报文，该报文中SYN字段被标为0，并且可以传递应用层信息了。这个报文的序列号是第一步中的序列号+1，确认号是服务器发回来的初始序号+1，因为确认字段有效所以ACK字段标为1。&lt;/p&gt;

&lt;p&gt;以上三步一般会统称为&lt;strong&gt;三次握手&lt;/strong&gt;，有一些程序员冷笑话就是根据这个来的。言归正传，你说为什么非要三次呢？两次不就解决了，还有为什么服务器初始序号的产生那么复杂？这两个问题的答案是有交叉的。服务器根据客户端的信息利用散列函数生成服务器初始序号，但此时服务器并不保存这个序号，也不为这个连接分配资源，仅仅是同意了建立连接。服务器的响应报文发出去之后，可能用户接收不到，需要第三次握手表示客户端已经收到服务器同意接受请求。同时通过第三次握手的确认字段表明曾经发起过连接请求。&lt;/p&gt;

&lt;p&gt;TCP建立连接之后，就可以进行可靠传输了。为了提高传输效率采用了管线化（也有翻译成流水线的）技术。可靠传输基本的原理上面已经提过了，TCP综合利用了检验和、累积确认、定时器、重传、序号、确认号。在传输过程中，通过报文中的接收窗口字段表明还可以接受多少内容，从而实现了流量控制，防止接收端数据溢出。这里还需要说的一句是确认信息正确到达和传递应用层信息是两个不同的功能，只是会倾向于将两个一起发送减少不必要的数据传输，这样就产生了&lt;strong&gt;延迟确认&lt;/strong&gt;的问题。&lt;/p&gt;

&lt;p&gt;在完成传输任务后，这个TCP连接可以保持一段时间后再拆除，也可以立即拆除。拆除连接时首先客户端向服务器端发送一个TCP报文，其中FIN字段被设为1。服务器接收到该报文段后，发送一个确认报文段。然后服务器连接关闭，发送它自己的终止报文段，FIN字段被置为1。最后，客户端对这个来自于服务器的终止报文确认，发送确认报文，进入TIME_WAIT状态，经过等待后释放相关资源，连接完全关闭。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/tcpfinish.jpg&#34; alt=&#34;拆除连接&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;tcp拥塞控制:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;拥塞是TCP发送报文速率相较于路由器接受能力过大，使得出现丢包、延迟的现象。TCP可以进行拥塞控制，那么，首先，TCP是如何感受拥塞的呢？TCP发送方定义了一个丢包事件：要么定时器超时、要么收到三个冗余ACK。然后TCP是如何进行拥塞控制、限制传输速率的？和流量控制中的接收窗口类似，TCP发送端也有一个拥塞窗口的概念，调节这个拥塞窗口即可改变传输速率。&lt;/p&gt;

&lt;p&gt;最后一个问题，TCP具体的拥塞控制实现是怎样的？总结起来是这么几句话：&lt;strong&gt;慢启动、加性增、乘性减&lt;/strong&gt;
。初始拥塞窗口比较小，随着发送拥塞窗口指数增长，称为慢启动（虽然感觉名字怪怪的）。到达一定传输速率后线性增加传输速率，丢包事件后快速减速，这一过程称为加性增，乘性减。这里的“一定传输速率”说起来就复杂了，目前我认为自己只需要知道有个“一定传输速率”的动态分界线即可。&lt;/p&gt;

&lt;p&gt;说到这里流量控制和拥塞控制这两者也应该能区分开了，流量控制解决的是接收端缓存不足的问题，拥塞控制为了解决路由缓存不足的问题。两者差的不是一点半点，虽然有些最终表现上是一致的。&lt;/p&gt;

&lt;h2 id=&#34;最后的总结:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;最后的总结&lt;/h2&gt;

&lt;p&gt;这里这篇文章并没有深入去描述传输层，只是简单地描述了传输层的功能、多路复用/多路分用的概念、UDP报文及应用、可靠传输需要的辅助字段、TCP连接过程/拆除过程、TCP可靠传输、TCP流量控制以及TCP拥塞控制。&lt;/p&gt;

&lt;p&gt;因为目前是以WEB开发的角度看待传输层，这些基本的描述性的东西对于我也应该足够了，或许以后会遇到socket编程吧，当然这是后话了。既然是从WEB开发的角度，我所熟悉的是应用层，传输层更像是一个API，最近我会写一篇文章，从应用层角度看待传输层。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>