<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jsmeta</title>
    <link>http://jiangshanmeta.github.io/</link>
    <description>Recent content on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Aug 2016 23:26:56 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>网际协议</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/ip/</link>
      <pubDate>Tue, 02 Aug 2016 23:26:56 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/ip/</guid>
      <description>

&lt;p&gt;IPv4协议&lt;/p&gt;

&lt;p&gt;计算机网络的网络层主要功能是&lt;strong&gt;转发&lt;/strong&gt;和&lt;strong&gt;路由&lt;/strong&gt;，转发是将分组从一个输入链路接口转移到合适的输出链路接口的路由器本地动作，路由是指网络范围内的过程，以决定分组从源到目的地所采取的端到端路径。&lt;/p&gt;

&lt;p&gt;合适的输出路径是如何确定的？输出链路是通过查询转发表根据&lt;strong&gt;最长前缀匹配规则&lt;/strong&gt;进行确定的。转发表是根据路由选择协议设定的，并且是动态更新的，换句话说，源和目的地址相同的两个IP报文，可能走不同的路线，因而不能保证先后顺序。&lt;/p&gt;

&lt;p&gt;那这个&lt;strong&gt;最长前缀匹配规则&lt;/strong&gt;又是什么？为了讲清楚这个，首先需要对IP地址有一定的基础了解。&lt;/p&gt;

&lt;h2 id=&#34;ipv4地址:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;IPv4地址&lt;/h2&gt;

&lt;p&gt;之前我&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;描述了计算机如何获取IP地址&lt;/a&gt;，在那里对IP地址做了最基本的描述。&lt;/p&gt;

&lt;p&gt;IPv4地址是一个32位的二进制数字，为了便于人类阅读，通常我们按照&lt;strong&gt;点分十进制记法&lt;/strong&gt;表示IP地址。一台主机的IP地址不是完全自由分配的，而是要根据其所在的子网进行分配。那么如何表示这个子网？如何表示子网大小？解决方案是将IP地址分为两部分，前面表示网络号，后面的表示主机号，表现为&lt;code&gt;a.b.c.d/x&lt;/code&gt;的形式。比如&lt;code&gt;233.233.233.0/24&lt;/code&gt;，这表示这个这个子网前24位是网络号，后面的8位才能分配给主机（有些特殊的号码不能分配，这个另说）。在window下查看当前所属子网前缀是多少位，可在cmd下输入&lt;code&gt;ipconfig&lt;/code&gt;，可以看到如下内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/ipconfig.jpg&#34; alt=&#34;ipconfig&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这显示我所在的子网前24位（子网掩码转换成二进制就是前24位都是1），图中所示的IP地址是&lt;code&gt;192.168.1.12&lt;/code&gt;，这是一个私有地址，全球现在应该有N个这么一个地址，这一点我稍后再说。&lt;/p&gt;

&lt;p&gt;在上古时期，还有A类网址、B类网址、C类网址的说法，从现在的角度来看就是上面说的几个特例而已，A类网址的子网掩码为&lt;code&gt;255.0.0.0&lt;/code&gt;，也就是说前八位为网络号，后24位为主机号，A类网址每个子网很大但是数量上比较少。B类网址子网掩码为&lt;code&gt;255.255.0.0&lt;/code&gt;，前16位为网络号，后16位为主机号，C类网址子网掩码为&lt;code&gt;255.255.255.0&lt;/code&gt;，我当前所属的就是个C网，前24位为网络号，后8位为主机号。C网数量很多但是每个子网的规模较小。其实对于A类网址、B类网址、C类网址，还有IP地址范围的限制，分别对应&lt;code&gt;0.0.0.0&lt;/code&gt;——&lt;code&gt;127.255.255.255&lt;/code&gt;、&lt;code&gt;128.0.0.0&lt;/code&gt;——&lt;code&gt;191.255.255.255&lt;/code&gt;、&lt;code&gt;192.0.0.0&lt;/code&gt;——&lt;code&gt;223.255.255.255&lt;/code&gt;。看到这你可能会问，应该还有空缺的位置啊，其实还有D类网址、E类网址，但是都不能作为公网地址。&lt;/p&gt;

&lt;p&gt;IP地址中还有一些特殊值，先以表格的形式归纳在这里&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;网络号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;主机号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;做源&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;做目标&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在本网内部表示本机&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;本网内广播地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;特定值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;网络地址，表示一个网络&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;特定值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;×&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;直接广播地址，对特定网络进行广播&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;127&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;非全0或非全1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;本地环回地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于前两个，在学习&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;&lt;strong&gt;DHCP&lt;/strong&gt;&lt;/a&gt;中已经遇到过了，&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，只能做源，&lt;code&gt;255.255.255.255&lt;/code&gt;表示本子网内的广播地址。后两个其实可以和前两个类比看，主机号全0表示当前网络，全1表示对这个网络进行广播，从另一个层面上看，不是所有合法数字都可以分配作为主机号，对于我这个C类网络，有8位主机号，并不意味着可以容纳2^8=256个ip，而是2^8-2=254个。最后一个对于搞web开发的人其实很熟悉，大家经常会看到&lt;code&gt;127.0.0.1&lt;/code&gt;就是一个环回地址。&lt;/p&gt;

&lt;p&gt;除了上面说的限制，还有私有地址的概念，上面截图中所示我的ip地址就处于一个私有网络中，对于A类网址、B类网址、C类网址，每一个均有一块作为私有地址，不能作为公网地址使用，C网的对应 &lt;strong&gt;192.168.0&lt;/strong&gt;——&lt;strong&gt;192.168.255&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然谈到私有地址的话题的，那我问个问题，为了实现主机到主机的逻辑通信，需要ip标示唯一主机，但是一个私有地址可以对应多台主机，那该怎么办？我们需要把私有地址映射到公有地址上去，这就需要下面要介绍的&lt;strong&gt;NAT&lt;/strong&gt;了。&lt;/p&gt;

&lt;h2 id=&#34;nat:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;NAT&lt;/h2&gt;

&lt;p&gt;NAT全称是网络地址转换，它的作用可以这么理解：NAT相当于是对整个子网进行了封装，在外界看来这个子网就像是一台主机，而不是多台设备。&lt;/p&gt;

&lt;p&gt;互联网的通信最终是应用进程和应用进程的通信，我们需要ip地址和端口号标示唯一的一个主机上的特定应用进程。使用了NAT，网络层报文的ip地址在路由器上被改写成路由器在公网上的地址，解决了私有地址不能在公网出现的问题，目标主机会把这台路由器当成是源主机看待，但是路由器上并不存在端口号对应的应用进程，我们需要把目标主机的返回报文传给真正的源主机，那又如何找到源主机呢？&lt;/p&gt;

&lt;p&gt;其实在报文进入公网的时候，不仅仅是ip地址被重写了，端口号也被重写了，新端口号和源主机ip及端口号的映射关系保存在&lt;strong&gt;NAT&lt;/strong&gt;转换表中。通过查询这张表即可找到源主机ip及源端口号。&lt;/p&gt;

&lt;p&gt;这么说可能比较晦涩，举个例子，我使用的这台主机的ip &lt;code&gt;192.168.1.12&lt;/code&gt;，在端口号2333发送一个报文到公网某个主机某个端口，这个地址是私有地址，通过了&lt;strong&gt;NAT路由器&lt;/strong&gt;之后网络层报文 源ip地址字段被修改成了路由器的公网ip，比如&lt;code&gt;233.233.233.233&lt;/code&gt;，然后根据源主机ip&lt;code&gt;192.168.1.12&lt;/code&gt;和源端口号2333生成一个新的端口号 5678，并在路由器中保存类似&lt;code&gt;5678=&amp;gt;[&#39;ip&#39;=&amp;gt;&#39;192.168.1.12&#39;,&#39;port&#39;=&amp;gt;2333]&lt;/code&gt;这样的一条记录，对于目的主机，它认为与自己通信的主机ip是&lt;code&gt;233.233.233.233&lt;/code&gt;，端口号是5678。到了&lt;strong&gt;NAT路由器&lt;/strong&gt;这里，发现端口号是5678，从&lt;strong&gt;NAT转换表&lt;/strong&gt;中找到真实源主机ip&lt;code&gt;192.168.1.12&lt;/code&gt;和真实端口号2333，然后修改报文把信息传给相应的进程。&lt;/p&gt;

&lt;p&gt;关于NAT其实有很多争议，作为强迫症晚期患者我最不能忍的是路由器这里竟然修改了传输层首部字段中的源端口号，说好的只到网络层呢。&lt;/p&gt;

&lt;h2 id=&#34;ipv4报文:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;IPv4报文&lt;/h2&gt;

&lt;p&gt;IPv4报文和传输层报文结构上很类似，都是上层传过来的数据加上一堆自己的首部。前面已经提到了IPv4报文中含有源主机IP地址，下面具体讲一下IPv4报文的首部字段。&lt;/p&gt;

&lt;p&gt;首先源主机IP地址和目的主机IP地址，这个就类似于传输层报文中的端口号，用于标示通信的主机。&lt;/p&gt;

&lt;p&gt;传输层用端口号标示要把报文向上传递到哪里，对于IPv4报文，起到类似作用的是一个上层协议字段，网络层通过这个字段知道把报文传到TCP还是UDP还是其他。&lt;/p&gt;

&lt;p&gt;类似于TCP报文，IPv4报文也包含一些选项（虽然基本用不上），所以需要首部长度字段表明首部的长度信息，一般的IPv4报文具有20字节的首部，即不包含任何的选项。这里我们可以比较一下UDP报文、TCP报文和IPv4报文：TCP报文和IPv4报文都具有可选的首部，所以需要首部长度字段来反应可选字段的使用情况跟，而UDP报文首部字段的数量是一定的，因而不需要这个字段。UDP报文和IPv4报文都有一个报文长度字段，但是TCP却没有，这又是为什么？因为TCP提供面向连接的可靠地数据传输，它有确认字段表明哪些字段被成功接收到了，而UDP和IPv4没有连接什么事，你不告诉对方你发了多少数据对方怎么知道要接收多少、处理多少。&lt;/p&gt;

&lt;p&gt;update 2016/08/11 稍微看了一下数据链路层的知识，这里补充一下，对于以太网的数据报文，其对所包含的数据有最小长度限度，如果长度不足会补齐，但这些填充的数据也会被提交给网络层的IP，因而需要长度字段找出哪些是真正的数据，哪些是填充。&lt;/p&gt;

&lt;p&gt;而TCP、UDP、IPv4报文都含有校验和字段检测比特错误，不过IPv4和UDP都不具有差错恢复机制，IPv4会通过下面要说的&lt;strong&gt;ICMP&lt;/strong&gt;进行报错。&lt;/p&gt;

&lt;p&gt;下面介绍的几个字段就比较复杂了，他们是 标识、标志、片偏移。之所以出现三个字段是因为网络层的下层数据链路层，因为数据链路层对于数据包的大小有不同的要求，可能出现这样的情况：输入链路的能容得下数据包，但是输出链路容不下，那怎么办，总不能把数据包就这么丢了是吧。于是路由器会把IPv4报文进行进一步分割成片，使输出链路能容得下，在最终的端系统中对分出来的片进行组装。标识字段相当于是IPv4报文的一个id，表明那些片是属于同一个IP报文里的，标志字段有两个作用，一个是表明允不允许进行分片操作，如果不允许容不下的情况下只能丢掉了，另一个作用是表明是否是最后一个分片。片偏移字段表示的是在原数据报中的位置。通过上面三个字段，我们就能把数据从片还原成原来的IP报文。&lt;/p&gt;

&lt;p&gt;在上面我一直在写IPv4报文，但是大家熟悉的不是IP吗，为啥我要强调v4，这牵扯到版本字段了，其实IPv6这个概念应该也不陌生，到这里就说出关键点了，有两种版本的IP报文格式，所以需要版本字段表明按哪种格式去解读报文。&lt;/p&gt;

&lt;p&gt;最后要介绍的是寿命字段，每经过一台路由器时，这个字段就要减1，当减到零的时候该数据报就要被丢弃。&lt;/p&gt;

&lt;h2 id=&#34;icmp:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;ICMP&lt;/h2&gt;

&lt;p&gt;ICMP通常被认为是IP的一部分，但是从体系结构上讲它应该和TCP、UDP并列，话句话说，ICMP报文是作为IP报文的有效载荷的，ICMP的主要功能是进行差错报告。&lt;/p&gt;

&lt;h2 id=&#34;从传输层角度看网络层:0e7497b6083b31ad5d27a662a672d7d3&#34;&gt;从传输层角度看网络层&lt;/h2&gt;

&lt;p&gt;网络层通过网际协议实现了转发功能，通过路由选择协议实现路由功能，然而路由选择的东西真的看起来比较虐心，我们先就只关心网际协议吧。&lt;/p&gt;

&lt;p&gt;对于传输层，把需要传输的东西交给网络层，然后坐等网络层把数据交给自己，但是网络层有时候并不能把一些数据传送给传输层，这里就根据我个人的理解，说一下网络层不能把数据传送给传输层的原因。&lt;/p&gt;

&lt;p&gt;第一个原因是在路由器因为排队原因发生的丢包。毕竟路由器处理能力是有限的。&lt;/p&gt;

&lt;p&gt;第二个原因是数据错误，丢弃数据包，主要是利用校验和字段。&lt;/p&gt;

&lt;p&gt;第三个原因是分片无法被组装。&lt;/p&gt;

&lt;p&gt;第四个原因是因为寿命字段被减为零，路由器丢弃数据包，出现这个现象的原因可能是转发表错误进入了网络中的无限循环。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DHCP</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/dhcp/</link>
      <pubDate>Mon, 01 Aug 2016 19:40:53 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/dhcp/</guid>
      <description>&lt;p&gt;在学习传输层的基本知识的时候，知道了传输层实现不同主机应用进程之间的逻辑通信，当时还与网络层比较，网络层实现的是不同主机间的逻辑通信，标记应用进程用端口号，标记主机用IP。严格来说IP标记的接口（主机与物理链路的边界），而不是主机与路由器（换句话说一台主机或者路由器可能有多个接口，对应多个IP），我这里并不严格区分。&lt;/p&gt;

&lt;p&gt;IP地址其实是IP（网际协议）的一部分，对于IP地址，即使是不搞计算机相关领域的人也应该听说过，我们一般写作形如 233.233.233.233 的形式，但这本质上是一个32位的二进制数，只是我们每8位看成一个整体，转换成十进制数字，才有了上面的形式。那一台主机刚接入计算机网络的时候，是如何获得IP地址的呢？&lt;/p&gt;

&lt;p&gt;一个方法是手动设置，在window下可以在如下界面进行设置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/manualip.jpg&#34; alt=&#34;手动设置ip&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不过对于广大人民群众（包括我）还是利用 &lt;strong&gt;DHCP&lt;/strong&gt; 动态获取IP地址的。下面的内容是描述如何通过 &lt;strong&gt;DHCP&lt;/strong&gt; 获取一个IP地址。&lt;/p&gt;

&lt;p&gt;首先，DHCP服务器发现。动态获得IP是通过&lt;strong&gt;DHCP服务器&lt;/strong&gt;分配的，对于一台新接入的计算机，显然要先找到这台服务器，那么问题来了，我怎么知道&lt;strong&gt;DHCP服务器&lt;/strong&gt;的IP（毕竟无论如何需要建立主机之间的逻辑通信）？答案是不知道，那就拿个大喇叭广播，我们使用 &lt;code&gt;255.255.255.255&lt;/code&gt; 作为目的地址，这样报文就会交付给同一个子网所有主机，并且此时这台主机没有IP地址，所以源地址是 &lt;code&gt;0.0.0.0&lt;/code&gt;。这时发送的报文称为 &lt;strong&gt;DHCP发现报文&lt;/strong&gt;，顺便说一句DHCP是基于UDP的。&lt;/p&gt;

&lt;p&gt;然后，DHCP服务器提供。广播的 &lt;strong&gt;DHCP发现报文&lt;/strong&gt; 子网内所有主机都会收到，但是只有 &lt;strong&gt;DHCP服务器&lt;/strong&gt; 会去做出响应。响应的报文称为 &lt;strong&gt;DHCP提供报文&lt;/strong&gt;，在这个报文中，源地址是这台服务器的地址，这点毫无疑问，目标地址是 &lt;code&gt;255.255.255.255&lt;/code&gt;，因为请求的主机此时还没有IP地址。那么问题来了，要接入网的主机通过什么知道这条信息是给自己的而不是给其它接入网的主机？通过 &lt;code&gt;transaction id&lt;/code&gt;，在&lt;strong&gt;DHCP发现报文&lt;/strong&gt; 里就包含这一信息，然后在 &lt;strong&gt;DHCP提供报文&lt;/strong&gt; 原样返回&lt;code&gt;transaction id&lt;/code&gt;。&lt;strong&gt;DHCP提供报文&lt;/strong&gt;里还会包含着一个分配到新客户的ip地址。&lt;/p&gt;

&lt;p&gt;随后，DHCP请求。由于一个子网可能会有多个&lt;strong&gt;DHCP服务器&lt;/strong&gt;，所以一条&lt;strong&gt;DHCP发现报文&lt;/strong&gt;可能会对应多条&lt;strong&gt;DHCP提供报文&lt;/strong&gt;，也就可能对应多个推荐ip地址。客户端需要选择一个最终的ip，发送&lt;strong&gt;DHCP请求报文&lt;/strong&gt;，因为可能有多个&lt;strong&gt;DHCP服务器&lt;/strong&gt;，所以采用的目的ip仍然是&lt;code&gt;255.255.255.255&lt;/code&gt;，通知最终结果，便于其他&lt;strong&gt;DHCP服务器&lt;/strong&gt;及时回收发出去的冗余ip地址。&lt;/p&gt;

&lt;p&gt;最后，DHCP服务器用 &lt;strong&gt;DHCP ACK报文&lt;/strong&gt;响应，进行最终确认。这样这台新接入的主机就获得了一个ip地址，同时获得的还有本地DNS服务器地址、网关地址。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS中一些“奇技淫巧”</title>
      <link>http://jiangshanmeta.github.io/post/css/csstricks/</link>
      <pubDate>Sun, 31 Jul 2016 20:28:36 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/csstricks/</guid>
      <description>

&lt;p&gt;声明一下，这里的奇技淫巧是指自己用得少觉得新奇而且有实际应用场景的CSS属性，而不是诸如用CSS画个IE8不支持的IE8图标之类的纯粹为了炫技然而实际没什么用途的黑魔法。&lt;/p&gt;

&lt;h4 id=&#34;currentcolor:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;currentColor&lt;/h4&gt;

&lt;p&gt;这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/&#34;&gt;张鑫旭大神已经给了几个&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;user-select:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;user-select&lt;/h4&gt;

&lt;p&gt;知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用&lt;code&gt;user-select:none;&lt;/code&gt;，这样对于普通用户连选择都做不到。&lt;/p&gt;

&lt;p&gt;不过这个属性兼容性有点差，在&lt;a href=&#34;http://caniuse.com/#search=user-select%3A&#34;&gt;can I use&lt;/a&gt;上查到的信息是目前还是乖乖加上私有前缀吧。&lt;/p&gt;

&lt;h4 id=&#34;selection:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;::selection&lt;/h4&gt;

&lt;p&gt;在CSS中伪元素常用的只有&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;,&lt;code&gt;::selection&lt;/code&gt;就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。&lt;/p&gt;

&lt;p&gt;本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。&lt;/p&gt;

&lt;h4 id=&#34;pointer-events-none:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;pointer-events:none&lt;/h4&gt;

&lt;p&gt;这个CSS让js和CSS的边界越来越模糊。想象这么一个场景：要做一个活动页，需要全屏的canvas绘制一些东西，这个canvas相当于一个遮罩层，但是我又想遮罩层下面的元素响应各种事件，尤其是点击事件。想通过js完成这件事目测要写一堆，但是对这个遮罩层使用&lt;code&gt;pointer-events:none&lt;/code&gt;即可让这个遮罩层不响应点击事件。&lt;/p&gt;

&lt;h4 id=&#34;content的attr:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;content的attr&lt;/h4&gt;

&lt;p&gt;伪元素大家应该不陌生了，但是伪元素的content属性我一般用的不多，后来发现一篇文章&lt;a href=&#34;http://web.jobbole.com/86079/&#34;&gt;美化加载失败的图片&lt;/a&gt;发现了content属性的一些玩法。我们可以通过attr属性引入一些属性的内容，比如&lt;code&gt;img::after{content:&#39;[&#39;attr(src)&#39;]&#39;}&lt;/code&gt;，这样就能在图片加载不出来的时候把原始图片地址显示出来（虽然我怀疑用户能否理解）。类似的思路，我们可以显示a标签的href属性&lt;code&gt;a::after{content:attr(href)}&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;direction:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;direction&lt;/h4&gt;

&lt;p&gt;这个属性有用的只有两个值：&lt;code&gt;ltr&lt;/code&gt;、&lt;code&gt;rtl&lt;/code&gt;，含义分别是从左向右和从右向左。猜也能猜出来默认值是&lt;code&gt;ltr&lt;/code&gt;。或许你会认为应用&lt;code&gt;rtl&lt;/code&gt;后会改变文字排版变成从右向左排布，然而那是&lt;code&gt;writing-mode&lt;/code&gt;的工作（顺便说一句，目前文字排版的常规模式是从左到右从上到下，除了搞两句古诗词的文艺小清新我觉得没人会闲的改变这种模式）。那么这个&lt;code&gt;direction&lt;/code&gt;改变的是什么的方向？ 改变的是&lt;strong&gt;内联元素块&lt;/strong&gt;的左右顺序，而内联元素块内部的元素是当做一个整体看待。换句话说，&lt;code&gt;direction&lt;/code&gt;属性可以在不改变DOM前后顺序的前提下改变内联元素块的前后顺序，听着好像低配版的flex布局的&lt;code&gt;order&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;干什么用呢？&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/03/css-direction-introduction-apply/&#34;&gt;张鑫旭大神提供了例子&lt;/a&gt;，在不改变DOM的情况下添加类名改变弹框组件的按钮顺序。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php中exit()的一个用法——记一次无聊的封装</title>
      <link>http://jiangshanmeta.github.io/post/php/exit/</link>
      <pubDate>Thu, 28 Jul 2016 19:00:23 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/exit/</guid>
      <description>&lt;p&gt;熟悉最好的编程语言php（手动滑稽）的人应该对于&lt;code&gt;exit()&lt;/code&gt;或者&lt;code&gt;die()&lt;/code&gt;函数不陌生，根据&lt;a href=&#34;http://php.net/manual/zh/function.die.php&#34;&gt;手册的说法&lt;/a&gt;这两个函数其实是别名关系，功能上是一样的。一般这两个函数是在调试的时候用的比较多，我的一个同事就比较习惯用&lt;code&gt;die()&lt;/code&gt;，然而作为前端入行的我显然是更习惯使用&lt;code&gt;return&lt;/code&gt;的方式进行调试。其实我对php的最主要调试方法是写两行然后用&lt;code&gt;var_dump()&lt;/code&gt;调试，一小步一小步往前推进。对于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数，有的人认为出错了用前者，提前退出用后者，我觉得没有太大的必要去区分这一点。&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数的用法，我觉得这一句话说得很好&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在设计工具类和工具函数时，die()/exit() 应该严令禁止，因为它们无权决定整个程序的生死。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这句话其实也反映了这两个函数与&lt;code&gt;return&lt;/code&gt;的区别，前者是程序级别的，后者仅仅是函数级别的。&lt;/p&gt;

&lt;p&gt;在我们的项目中后端是一个MVC框架(就是CI)，model层会根据前端传过来的各种信息进行初始化，为了容错，controller里经常会有这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!$this-&amp;gt;dataInfo-&amp;gt;is_inited){
	$jsonRst = -1;
	$jsonData = array();
	$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
	echo $this-&amp;gt;exportData($jsonData,$jsonRst);
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码是ajax请求时常用的代码，然而，一个controller里的action里面可能会加载多个model，这样上面的代码就会重复N遍，以至于可能真正的业务部分真的没有几行大部分都是在容错，虽说每次都是复制粘贴，但复制粘贴多了就想着封装这个功能。&lt;/p&gt;

&lt;p&gt;需求就有了，我希望能在model层里面封装一个小方法，专门用来检查初始化是否成功，如果初始化失败返回数据错误，controller里的其他代码就不运行了。为什么要单独写一个函数而不是封装在初始化函数中呢？一是因为初始化是初始化、查错是查错，二是因为上面的的代码只适用于ajax返回错误。那&lt;code&gt;return false;&lt;/code&gt;能不能满足我的需求？答案是不能，这只是终止这个小方法的运行，controller还会继续，除非手动写ifelse判断，然而这样和没封装似乎也差不了几行。我的解决方案是使用&lt;code&gt;exit()&lt;/code&gt;,这样如果初始化失败controller里的代码也不会往下走了。最终封装在model基类里的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function check_inited_for_ajax{
	$CI =&amp;amp; get_instance();
	if(!$this-&amp;gt;is_inited){
		$jsonRst = -1;
		$jsonData = array();
		$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
		echo $CI-&amp;gt;exportData($jsonData,$jsonRst);
		exit();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，对于非ajax请求，可以封装一个类似的函数，导入到404页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function check_inited_for_href(){
    $CI =&amp;amp; get_instance();
    if(!$this-&amp;gt;is_inited){
        $CI-&amp;gt;topTyp = &amp;quot;gobacktop&amp;quot;;
        $CI-&amp;gt;top_title = &amp;quot;出错啦&amp;quot;;
        echo $CI-&amp;gt;load-&amp;gt;view(&#39;default_page&#39; ,[&#39;contents&#39;=&amp;gt;$CI-&amp;gt;load-&amp;gt;view(&#39;common/notFound&#39;,[],true)], true);
        exit();
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改动并不多，真的只是做了一点微小的贡献，然而每个model初始化容错只需要一行，看起来好爽啊。&lt;/p&gt;

&lt;p&gt;//做一个有代码洁癖的bug开发者真不容易。话说同事都是有N年开发经验是怎么忍受这样的代码的。。。&lt;/p&gt;

&lt;p&gt;update 2016/08/02&lt;/p&gt;

&lt;p&gt;一个简单地想法是ajax请求的出错信息，直接写死在代码里不是很合适，可以在model基类里面封装一个相关函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function gen_err_msg(){
	return &#39;数据有误&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可行性上没问题，但是觉得没太大的用处，算是对用户体验的一点改进吧。&lt;/p&gt;

&lt;p&gt;另一个想法是扩大适用范围，不仅仅是在初始化的时候，在model有一些业务逻辑判断，比如常见的权限判断，需要导入到一个类似于404页面的无权限页面，诸如此类都可以封装到model层而不是在controller里手动判断。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>http连接控制</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/</link>
      <pubDate>Tue, 26 Jul 2016 20:57:58 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/</guid>
      <description>

&lt;p&gt;http是一个应用层协议，http所依赖的传输层协议是TCP，对于http，只需要把需要传递的信息通过套接字socket传递给传输层的TCP，然后就可以坐等TCP可靠的把数据传到目标主机的目标进程了，至于TCP是如何处理数据如何传输的，从应用层角度并不需要关心，&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;我之前也对TCP如何实现功能给出了最简单的描述&lt;/a&gt;。然而http事务的性能很大程度上依赖TCP的性能，毕竟现在这个年代在端系统上处理数据一般很快，慢的是传输数据。那我们先看一下TCP哪些动作会引起时延，然后看提高http连接性能的技术。&lt;/p&gt;

&lt;h2 id=&#34;tcp引起时延的动作:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;TCP引起时延的动作&lt;/h2&gt;

&lt;h4 id=&#34;建立tcp连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;建立TCP连接&lt;/h4&gt;

&lt;p&gt;TCP是面向连接的，TCP在正式发送应用层信息之前需要与服务器端建立连接，建立连接的过程通常称为&lt;strong&gt;三次握手&lt;/strong&gt;，首先客户端发送一个&lt;strong&gt;SYN报文&lt;/strong&gt;请求建立连接、并携带一些初始化数据，服务器同意建立连接发送一个&lt;strong&gt;SYNACK报文&lt;/strong&gt;，上面说的两个报文都没有传递应用层的信息，只是为了建立连接交换一些必要的数据，直到第三次握手才传输应用层信息。&lt;/p&gt;

&lt;h4 id=&#34;延迟确认:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;延迟确认&lt;/h4&gt;

&lt;p&gt;为了实现可靠传输，TCP采取了累积确认机制，但是确认功能和传递应用层信息是两个不同的功能，仅仅为确认报文正确到达就发送一个TCP报文是不合算的，所以会等待要发送的应用层信息，尝试捎带确认信息。这一机制成为&lt;strong&gt;延迟确认&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;慢启动:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;慢启动&lt;/h4&gt;

&lt;p&gt;慢启动其实是TCP拥塞控制的一部分，在TCP连接的一开始传输速率其实是比较低的，随着通信的进行在一定速率范围内传输速率呈指数增长。&lt;/p&gt;

&lt;h2 id=&#34;提高http连接性能的技术:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;提高http连接性能的技术&lt;/h2&gt;

&lt;p&gt;上面提到的建立TCP连接的时间是不可避免的，但是我们可以通过一个TCP连接传递多条http报文的方式，使得每一个http报文所分摊的建立连接时间缩短。慢启动也不可避免，也可以通过和上面一样的方式重复利用同一个连接，减少慢启动带来的消耗。下面介绍三种提高http连接性能的方法。&lt;/p&gt;

&lt;h4 id=&#34;并行连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;并行连接&lt;/h4&gt;

&lt;p&gt;单个TCP连接的传输速率有限，但是如果是多个TCP连接一起运行速率就有可能提升。同时多个TCP连接比较消耗内存，所以浏览器在使用并行连接的同时，限制并行TCP连接的数量。&lt;/p&gt;

&lt;h4 id=&#34;持久连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;持久连接&lt;/h4&gt;

&lt;p&gt;一个TCP连接首先要通过三次握手，然后要经过慢启动才能以一个适合的速率传递报文，如果传递完一份应用层信息就关闭连接，岂不是太浪费了，所以就有了持久连接的技术，传递完一份应用层报文后并不立即关闭TCP连接。&lt;/p&gt;

&lt;p&gt;在http/1.1中，在现在这个年代已经不需要考虑http/1.0了，默认采用了持久连接的技术，你可能会在http请求头或者响应头中看到这样的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在http/1.1中，客户端假定收到响应后，除非响应中包含&lt;code&gt;Connection: close&lt;/code&gt;，不然http/1.1连接仍维持打开状态。但是，客户端和服务器仍然可以随时关闭TCP连接，也就是说，&lt;code&gt;Connection: keep-alive&lt;/code&gt;是一个不可靠的保证。&lt;/p&gt;

&lt;h4 id=&#34;管道化连接:bcf53f62b95030078a83e7b9bb07b9b2&#34;&gt;管道化连接&lt;/h4&gt;

&lt;p&gt;管道化连接是在持久连接的基础上的一项技术，在一条报文发出之后，在等待响应之前可以继续发送其他报文，提高连接的利用效率。&lt;/p&gt;

&lt;p&gt;管线化操作产生了顺序问题，TCP采用了&lt;strong&gt;回退N步&lt;/strong&gt;和&lt;strong&gt;选择重传&lt;/strong&gt;杂合的方式最终实现管道化连接。&lt;/p&gt;

&lt;p&gt;这篇文章没有从功能角度来描述TCP，而是从性能角度，讨论了影响TCP传输性能的几个因素，并给出了一些成熟提高传输性能的方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初识传输层</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/transportlayer/</link>
      <pubDate>Sun, 24 Jul 2016 20:36:07 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/transportlayer/</guid>
      <description>

&lt;p&gt;传输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。作为WEB开发者虽然并不直接接触传输层，但是了解一下基本原理对于理解应用层还是有帮助的。&lt;/p&gt;

&lt;h2 id=&#34;传输层的功能:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;传输层的功能&lt;/h2&gt;

&lt;p&gt;传输层的功能是为不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;。注意这里是逻辑通信，而不是物理通信，传输层是在端系统中实现的而不是在路由器中实现的。在发送端，传输层将从应用进程收到的报文转换成传输层报文段，添加传输层首部。在接收端，网络层从数据报中提取传输层报文，并将其交给传输层。传输层处理收到的报文段，为应用层提供数据。&lt;/p&gt;

&lt;p&gt;常见的传输层协议有UDP和TCP。UDP为应用层提供了不可靠、无连接的服务，而TCP提供了可靠、面向连接的服务。&lt;/p&gt;

&lt;h2 id=&#34;多路复用-多路分解:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;多路复用/多路分解&lt;/h2&gt;

&lt;p&gt;应用层和传输层之间不是直接交换数据，而是通过套接字socket。每一个套接字都有唯一标识符。&lt;/p&gt;

&lt;p&gt;为了在不同主机之间标示套接字，需要在传输层报文中有几个字段。在接收端，传输层检查这些字段，标识出接收套接字，进而将报文段定向到套接字。将传输层报文中的数据交付到正确的套接字的工作称为&lt;strong&gt;多路分解&lt;/strong&gt;。从源主机中不同套接字中收集数据块，为其封装首部信息，然后将报文段传给网络层，这些工作称为&lt;strong&gt;多路复用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在UDP中一个套接字是通过 目的IP和目的端口号标示的。在TCP中一个套接字是通过 源IP地址、源端口号、目的IP地址、目的端口号标示的。&lt;/p&gt;

&lt;h2 id=&#34;udp协议:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;UDP协议&lt;/h2&gt;

&lt;p&gt;UDP协议为应用层提供了不可靠、无连接的服务。UDP是应用层协议比较简单的实现，能提供的功能仅有多路复用/多路分用和差错检验。&lt;/p&gt;

&lt;p&gt;先说一下UDP报文的结构。传输层报文是在应用层报文基础上添加了首部信息，即传输层报文 = 传输层首部 + 应用信息。我们的关注点显然是首部字段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/udp.jpg&#34; alt=&#34;UDP报文结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;UDP有四个首部，分别是：源端口号、目的端口号、长度、校验和。源端口号和目的端口号是多路复用/多路分用的基础，长度字段指明了UDP报文的字节数（首部+数据）。校验和是为了差错检验功能。然而不幸的是UDP协议仅仅能够发现错误，但无法从错误中恢复出来，所以UDP协议无法提供可靠地数据传输。&lt;/p&gt;

&lt;p&gt;应用UDP协议的应用，一般是对数据可靠性要求没那么高的，比如DNS查询、网络电话、在线直播之类的。&lt;/p&gt;

&lt;h2 id=&#34;可靠数据传输原理:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;可靠数据传输原理&lt;/h2&gt;

&lt;p&gt;这个问题说实话有点大了，其实写一个系列丛书讨论这个问题都不为过。我这里就说点总结性的。&lt;/p&gt;

&lt;p&gt;为了检验数据是否有差错，采用了校验和。&lt;/p&gt;

&lt;p&gt;为了返回检查结果和接受信息，采用了反馈机制。&lt;/p&gt;

&lt;p&gt;为了处理丢包，采用了超时机制。&lt;/p&gt;

&lt;p&gt;为了处理数据错误和丢包，采用了重传机制（重传大法好）。&lt;/p&gt;

&lt;p&gt;为了标识每一个分组、处理冗余分组、检测丢包，采取了序号。&lt;/p&gt;

&lt;p&gt;为了解决管线化操作中的差错恢复，出现了回退N步和选择重传。&lt;/p&gt;

&lt;h2 id=&#34;tcp报文与tcp连接:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP报文与TCP连接&lt;/h2&gt;

&lt;p&gt;TCP相较于UDP，具有面向连接、可靠传输、流量控制、拥塞控制的功能，显然其所添加的首部字段更加复杂。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/tcppost.png&#34; alt=&#34;TCP报文结构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;源端口号和目的端口号是多路复用/多路分用的基础，显然TCP报文也会具有这两个字段。与UDP报文类似，TCP报文也具有检验和字段，用于检验比特错误。TCP具有序号和确认号两个字段，用于实现可靠的数据传输。接收窗口字段，用于流量控制。SYN、FIN字段用于建立连接和结束连接。ACK字段用于指示确认字段中的值是有效的。&lt;/p&gt;

&lt;p&gt;TCP是面向连接的，我们首先要看的是如何建立TCP连接。&lt;/p&gt;

&lt;p&gt;首先客户端TCP向服务器TCP发送一个特殊的TCP报文，该报文段不包含任何应用层传来的数据，但是在报文首部SYN字段标为1，因此这个特殊的报文被称为&lt;strong&gt;SYN报文段&lt;/strong&gt;。在序号字段中，会填入客户端随机产生的初始序号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/tcpestablish.jpg&#34; alt=&#34;三次握手&#34; /&gt;&lt;/p&gt;

&lt;p&gt;服务器端接收到这个建立连接的请求后会发送一个同意建立连接的响应报文。这个响应报文也不包含应用层信息，但是SYN字段标为1，确认字段为客户端传来的初始序号+1，ACK字段标为1表示确认字段有效，服务器会根据源IP、源端口号、目的主机、目的端口号以及其他信息利用散列函数生成一个服务器的初始序号，放到响应报文的序号字段中。因为SYN和ACK两个字段都被标为1，因此这个返回报文也被称为&lt;strong&gt;SYNACK报文段&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端收到服务器发回来的响应报文，明白了服务器同意建立连接，发送第三个报文，该报文中SYN字段被标为0，并且可以传递应用层信息了。这个报文的序列号是第一步中的序列号+1，确认号是服务器发回来的初始序号+1，因为确认字段有效所以ACK字段标为1。&lt;/p&gt;

&lt;p&gt;以上三步一般会统称为&lt;strong&gt;三次握手&lt;/strong&gt;，有一些程序员冷笑话就是根据这个来的。言归正传，你说为什么非要三次呢？两次不就解决了，还有为什么服务器初始序号的产生那么复杂？这两个问题的答案是有交叉的。服务器根据客户端的信息利用散列函数生成服务器初始序号，但此时服务器并不保存这个序号，也不为这个连接分配资源，仅仅是同意了建立连接。服务器的响应报文发出去之后，可能用户接收不到，需要第三次握手表示客户端已经收到服务器同意接受请求。同时通过第三次握手的确认字段表明曾经发起过连接请求。&lt;/p&gt;

&lt;p&gt;TCP建立连接之后，就可以进行可靠传输了。为了提高传输效率采用了管线化（也有翻译成流水线的）技术。可靠传输基本的原理上面已经提过了，TCP综合利用了检验和、累积确认、定时器、重传、序号、确认号。在传输过程中，通过报文中的接收窗口字段表明还可以接受多少内容，从而实现了流量控制，防止接收端数据溢出。这里还需要说的一句是确认信息正确到达和传递应用层信息是两个不同的功能，只是会倾向于将两个一起发送减少不必要的数据传输，这样就产生了&lt;strong&gt;延迟确认&lt;/strong&gt;的问题。&lt;/p&gt;

&lt;p&gt;在完成传输任务后，这个TCP连接可以保持一段时间后再拆除，也可以立即拆除。拆除连接时首先客户端向服务器端发送一个TCP报文，其中FIN字段被设为1。服务器接收到该报文段后，发送一个确认报文段。然后服务器连接关闭，发送它自己的终止报文段，FIN字段被置为1。最后，客户端对这个来自于服务器的终止报文确认，发送确认报文，进入TIME_WAIT状态，经过等待后释放相关资源，连接完全关闭。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/computernetwork/tcpfinish.jpg&#34; alt=&#34;拆除连接&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;tcp拥塞控制:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;拥塞是TCP发送报文速率相较于路由器接受能力过大，使得出现丢包、延迟的现象。TCP可以进行拥塞控制，那么，首先，TCP是如何感受拥塞的呢？TCP发送方定义了一个丢包事件：要么定时器超时、要么收到三个冗余ACK。然后TCP是如何进行拥塞控制、限制传输速率的？和流量控制中的接收窗口类似，TCP发送端也有一个拥塞窗口的概念，调节这个拥塞窗口即可改变传输速率。&lt;/p&gt;

&lt;p&gt;最后一个问题，TCP具体的拥塞控制实现是怎样的？总结起来是这么几句话：&lt;strong&gt;慢启动、加性增、乘性减&lt;/strong&gt;
。初始拥塞窗口比较小，随着发送拥塞窗口指数增长，称为慢启动（虽然感觉名字怪怪的）。到达一定传输速率后线性增加传输速率，丢包事件后快速减速，这一过程称为加性增，乘性减。这里的“一定传输速率”说起来就复杂了，目前我认为自己只需要知道有个“一定传输速率”的动态分界线即可。&lt;/p&gt;

&lt;p&gt;说到这里流量控制和拥塞控制这两者也应该能区分开了，流量控制解决的是接收端缓存不足的问题，拥塞控制为了解决路由缓存不足的问题。两者差的不是一点半点，虽然有些最终表现上是一致的。&lt;/p&gt;

&lt;h2 id=&#34;最后的总结:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;最后的总结&lt;/h2&gt;

&lt;p&gt;这里这篇文章并没有深入去描述传输层，只是简单地描述了传输层的功能、多路复用/多路分用的概念、UDP报文及应用、可靠传输需要的辅助字段、TCP连接过程/拆除过程、TCP可靠传输、TCP流量控制以及TCP拥塞控制。&lt;/p&gt;

&lt;p&gt;因为目前是以WEB开发的角度看待传输层，这些基本的描述性的东西对于我也应该足够了，或许以后会遇到socket编程吧，当然这是后话了。既然是从WEB开发的角度，我所熟悉的是应用层，传输层更像是一个API，最近我会写一篇文章，从应用层角度看待传输层。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>http方法和状态码</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/</link>
      <pubDate>Sun, 17 Jul 2016 20:44:32 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/</guid>
      <description>

&lt;p&gt;http协议是web开发的基础，然而内容太多，即使是入门级的内容也不是一两篇文章能总结好的。这里就先总结一下http方法和状态码。&lt;/p&gt;

&lt;h2 id=&#34;http方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;http方法&lt;/h2&gt;

&lt;h4 id=&#34;get方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;GET方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;方法通常用来向服务器请求某个资源。一般打开某个网页就是使用&lt;code&gt;GET&lt;/code&gt;方法。&lt;/p&gt;

&lt;h4 id=&#34;post方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;POST方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;方法是用来向服务器输入数据的。有的表单提交就是采用&lt;code&gt;POST&lt;/code&gt;方法，不过随着现在业务逻辑的复杂化，应该很少有人会直接使用这种方法提交表单，而是采用&lt;code&gt;ajax&lt;/code&gt;提交表单内容。&lt;/p&gt;

&lt;h4 id=&#34;head方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;HEAD方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt;方法和&lt;code&gt;GET&lt;/code&gt;方法很类似，但是服务器在响应中只会返回首部，而不会返回主体部分。&lt;/p&gt;

&lt;h4 id=&#34;put方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;PUT方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;PUT&lt;/code&gt;方法用于向服务器写入文档。&lt;code&gt;PUT&lt;/code&gt;方法的语义是让服务器用请求的主体部分来创建一个由所请求URL命名的新文档，或者，如果那个URL已经存在，就用这个主体替代它。&lt;/p&gt;

&lt;p&gt;因为&lt;code&gt;PUT&lt;/code&gt;方法允许对内容进行修改，对于WEB服务器，原则上应该需要用户登录确认身份。&lt;/p&gt;

&lt;h4 id=&#34;delete方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;DELETE方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;DELETE&lt;/code&gt;方法是与&lt;code&gt;PUT&lt;/code&gt;方法相反的方法，它用来删除文件。&lt;/p&gt;

&lt;h4 id=&#34;options方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;OPTIONS方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;OPTIONS&lt;/code&gt;方法请求服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。&lt;/p&gt;

&lt;h4 id=&#34;trace方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;TRACE方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;TRACE&lt;/code&gt;方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。服务器会在响应主体中携带它收到的原始请求报文。&lt;/p&gt;

&lt;h2 id=&#34;http状态码和原因短语:299e9942cf324699ed9e60279b71ca7a&#34;&gt;http状态码和原因短语&lt;/h2&gt;

&lt;p&gt;http状态码为客户端提供了一种理解事务处理结果的便捷方式。原因短语一般是为了方便人类理解而存在的。&lt;/p&gt;

&lt;h3 id=&#34;100-199-信息性状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;100-199 信息性状态码&lt;/h3&gt;

&lt;h4 id=&#34;101-switching-protocols:299e9942cf324699ed9e60279b71ca7a&#34;&gt;101 Switching Protocols&lt;/h4&gt;

&lt;p&gt;服务器正在根据客户端的指定，将协议切换成Update首部所列的首部。&lt;/p&gt;

&lt;h3 id=&#34;200-299-成功状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;200-299 成功状态码&lt;/h3&gt;

&lt;h4 id=&#34;200-ok:299e9942cf324699ed9e60279b71ca7a&#34;&gt;200 OK&lt;/h4&gt;

&lt;p&gt;表示从客户端发来的请求在服务器端正常处理了。在响应实体中包含了所请求的资源。&lt;/p&gt;

&lt;h4 id=&#34;204-no-content:299e9942cf324699ed9e60279b71ca7a&#34;&gt;204 No Content&lt;/h4&gt;

&lt;p&gt;表示客户端发来的请求在服务器端得到正常处理，但是在响应报文中不含实体的主体部分。大家可以看一下知乎专栏写文章那个页面，应该是监听输入事件然后发起ajax请求保存文章内容，然后返回的状态码就是204。虽然我个人认为知乎的这个保存设计不是很好。&lt;/p&gt;

&lt;h4 id=&#34;206-partical-content:299e9942cf324699ed9e60279b71ca7a&#34;&gt;206 Partical Content&lt;/h4&gt;

&lt;p&gt;成功执行了一个Range请求。206响应中必须包含&lt;code&gt;Content-Range&lt;/code&gt;、&lt;code&gt;Date&lt;/code&gt;、&lt;code&gt;ETag&lt;/code&gt;或&lt;code&gt;Content-Location&lt;/code&gt;首部。&lt;/p&gt;

&lt;h3 id=&#34;300-399-重定向状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;300-399 重定向状态码&lt;/h3&gt;

&lt;h4 id=&#34;301-moved-permanently:299e9942cf324699ed9e60279b71ca7a&#34;&gt;301 Moved Permanently&lt;/h4&gt;

&lt;p&gt;永久重定向。表示请求的资源已经被分配了新的URL，响应的&lt;code&gt;Location&lt;/code&gt;首部字段包含资源现在所处的URL。&lt;/p&gt;

&lt;h4 id=&#34;302-found-303-see-other-307-temporary-redirect:299e9942cf324699ed9e60279b71ca7a&#34;&gt;302 Found、303 See Other、307 Temporary Redirect&lt;/h4&gt;

&lt;p&gt;这三个状态码表示临时重定向 ，功能差不多，但是有些许差异，而且还牵扯到http/1.0和http/1.1版本问题。&lt;/p&gt;

&lt;p&gt;在http/1.0中，如果发送的是POST请求，服务器返回302，则需要向用户确认是否重发、重发依然是POST请求。&lt;/p&gt;

&lt;p&gt;在http/1.1中，浏览器对于302，其实是按照303处理的，即POST请求会转换为GET请求然后重发。&lt;/p&gt;

&lt;p&gt;在http/1.1中，浏览器对待307，其实和http/1.0中的302一致，不改变请求状态。&lt;/p&gt;

&lt;p&gt;换句话说对于&lt;code&gt;GET&lt;/code&gt;请求这几个没什么区别，对于&lt;code&gt;POST&lt;/code&gt;请求，正常人会希望重定向为一个新的&lt;code&gt;POST&lt;/code&gt;请求，会采用307状态码。然而有应用场景？&lt;/p&gt;

&lt;p&gt;可以参考&lt;a href=&#34;http://www.cnblogs.com/cswuyg/p/3871976.html&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;304-not-modified:299e9942cf324699ed9e60279b71ca7a&#34;&gt;304 Not Modified&lt;/h4&gt;

&lt;p&gt;客户端可以在请求首部中包含条件请求首部，如果不满足条件的话就返回304。带有这个状态码的响应不应该包含实体的主体部分。&lt;/p&gt;

&lt;h3 id=&#34;400-499-客户端错误状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;400-499 客户端错误状态码&lt;/h3&gt;

&lt;h4 id=&#34;400-bad-request:299e9942cf324699ed9e60279b71ca7a&#34;&gt;400 Bad Request&lt;/h4&gt;

&lt;p&gt;表示请求报文有语法错误&lt;/p&gt;

&lt;h4 id=&#34;403-forbidden:299e9942cf324699ed9e60279b71ca7a&#34;&gt;403 Forbidden&lt;/h4&gt;

&lt;p&gt;表示请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可在响应主体对原因进行说明。然而，通常情况下因为不想说明为什么拒绝才用这个状态码，所以我至今不明白为什么有那么两天mongodb中文网给我403。&lt;/p&gt;

&lt;h4 id=&#34;404-not-found:299e9942cf324699ed9e60279b71ca7a&#34;&gt;404 Not Found&lt;/h4&gt;

&lt;p&gt;这个就太熟悉了，服务器找不到所请求的url。&lt;/p&gt;

&lt;h3 id=&#34;500-599-服务器错误状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;500-599 服务器错误状态码&lt;/h3&gt;

&lt;h4 id=&#34;500-internal-server-error:299e9942cf324699ed9e60279b71ca7a&#34;&gt;500 Internal Server Error&lt;/h4&gt;

&lt;p&gt;在开发中，我的本地数据库连的同事的，然而有的时候连不上，就会报500。&lt;/p&gt;

&lt;h4 id=&#34;503-service-unavailable:299e9942cf324699ed9e60279b71ca7a&#34;&gt;503 Service Unavailable&lt;/h4&gt;

&lt;p&gt;服务器现在无法为请求提供服务，但将来可以。偶尔见到维护的时候用过这个状态码。&lt;/p&gt;

&lt;h2 id=&#34;请求行与响应行:299e9942cf324699ed9e60279b71ca7a&#34;&gt;请求行与响应行&lt;/h2&gt;

&lt;p&gt;请求行的语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;method&amp;gt;&amp;lt;request-URL&amp;gt;&amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子，请求知乎首页的请求行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;响应行的语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;version&amp;gt;&amp;lt;status&amp;gt;&amp;lt;reason-phrase&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求知乎首页响应行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求行和响应行需要方法、url、版本、状态码和状态短语。方法、状态码状态短语上面说过了，版本对于现代浏览器是http/1.1。url就不说了。&lt;/p&gt;

&lt;p&gt;update 2016/07/19&lt;/p&gt;

&lt;p&gt;既然提到了状态码，引用一段项目中的相关函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;redirect&#39;))
{
    function redirect($uri = &#39;&#39;, $method = &#39;location&#39;, $http_response_code = 302)
    {
        if ( ! preg_match(&#39;#^https?://#i&#39;, $uri))
        {
            $uri = site_url($uri);
        }

        switch($method)
        {
            case &#39;refresh&#39;  : header(&amp;quot;Refresh:0;url=&amp;quot;.$uri);
                break;
            default         : header(&amp;quot;Location: &amp;quot;.$uri, TRUE, $http_response_code);
                break;
        }
        exit;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码语言是最好的编程语言php（大雾。作用是重定向，这里默认的重定向状态码就是302，虽然严格来说用303更好。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DNS原理入门</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/dns/</link>
      <pubDate>Sun, 17 Jul 2016 00:43:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/dns/</guid>
      <description>&lt;p&gt;作为半路出发搞web开发的，计算机网络的知识很薄弱，我可不想一辈子写写页面做做增删查改就完了，要提高一下自己的知识水平。光看书也不行，把自己学到的讲出来，这样能够加深理解。&lt;/p&gt;

&lt;p&gt;一般的介绍计算机网络会从OSI模型或者TCP/IP模型开始介绍，虽然目前有个整体的概念但是理解还是不深，所以我想放到最后说。首先要说的应用层的DNS。DNS基本不会被用户手动使用，但是会被其他应用层程序调用，因为DNS的主要作用是将主机名映射到IP地址。为什么需要这么做？因为不同端系统之间的通信需要IP地址来帮助寻找目标主机。&lt;/p&gt;

&lt;p&gt;除了将主机名映射到IP地址这个作用外，DNS还有以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主机别名&lt;/li&gt;
&lt;li&gt;邮件服务器别名&lt;/li&gt;
&lt;li&gt;负载分配。这一点需要说一说，对于一些大站，为了性能优化会部署在多个服务器上。此时一个主机名就会对应多个IP地址。用户请求的时候DNS服务器返回的不是一个IP，而是一组，但是在每次响应时会循环地址次序。在客户端根据返回的IP发起请求的时候通常会先请求排在前面的IP地址，于是便实现了负载分配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整体掌握DNS的功能后，然后我们要看的是DNS查询的过程。&lt;/p&gt;

&lt;p&gt;处于种种原因（大家可以自行想象），DNS采取了分布式、分层次的数据库。DNS服务器大体分为三种类型：根DNS服务器、顶级域DNS服务器、权威DNS服务器。还有一个本地DNS服务器，通常本地DNS服务器是由ISP提供的，相当于是我们DNS查询的一个代理，并且还起到缓存的作用。&lt;/p&gt;

&lt;p&gt;我们要进行DNS查询，首先是查询本地hosts，如果有结果就直接返回IP，这就是为什么本地开发要改hosts。一般的用户是不会配置本地hosts的，不考虑浏览器缓存的话会向本地DNS服务器查询（其实是应用程序如浏览器的缓存优先级更高）。其实也不见得是向本地DNS服务器请求，因为可以设置DNS服务器IP，然而对于一般用户本地DNS服务器地址是接入网的时候就分配好的。通用过程是DNS服务器先向根DNS服务器请求，根DNS服务器会返回顶级域DNS服务器的地址，然后本地DNS服务器据此地址请求顶级域DNS服务器，顶级域DNS服务器返回权威DNS服务器的地址。本地DNS服务器再向权威DNS服务器请求，最终由权威DNS返回查询主机的IP。其实这只是一个简化模型，因为返回的可能不是下一层DNS服务器地址，而是一个中间DNS服务器地址。&lt;/p&gt;

&lt;p&gt;要获得一个主机到IP的映射本地DNS服务器至少要发起三次请求，接受三次回复，如果每次都重复此过程其实是比较昂贵的，所以就有了DNS缓存，通常本地DNS服务器会起到这么一个作用。在查询过程中，会先判断本地缓存有没有相关信息，再进行操作。DNS缓存也会有过期时间的概念，这点不难理解，毕竟互联网是一个动态的网络。&lt;/p&gt;

&lt;p&gt;最终本地DNS服务器向端系统返回IP。换句话说，对于客户端来说，直接发生作用的只有本地DNS服务器，向其他各级DNS服务器请求是本地DNS服务器帮助我们完成的。&lt;/p&gt;

&lt;p&gt;这里还会有 &lt;strong&gt;递归查询&lt;/strong&gt;、&lt;strong&gt;迭代查询&lt;/strong&gt;的概念，理解了上述过程，这两个概念理解起来就没什么难度了。&lt;/p&gt;

&lt;p&gt;DNS协议运行在传输层的UDP协议之上。&lt;/p&gt;

&lt;p&gt;DNS查询基本过程了解了，我们要看一下DNS记录的内容。DNS记录的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Name,Value,Type,TTL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TTL是生存时间，Name和Value的含义决定于Type&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;A&lt;/code&gt;，则Name是主机名，Value是主机名对应IP地址&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;NS&lt;/code&gt;，则Name是域，Value是知道如何获得该域权威DNS服务器的&lt;strong&gt;主机名&lt;/strong&gt;，注意Value是一个主机名，不是IP&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;CNAME&lt;/code&gt;，则Name是别名，Value是规范主机名。这就是为什么DNS会提供别名服务&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;MX&lt;/code&gt;，则Name是邮件服务系统的主机名，Value是别名。这就是为什么DNS会提供邮件服务器别名服务&lt;/p&gt;

&lt;p&gt;至于DNS报文，我目前认为没有太多值得在这里去说的。&lt;/p&gt;

&lt;p&gt;DNS的功能、DNS查询过程、DNS记录和报文相关的内容就说到这里吧。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考资料&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;James F. Kurose， Keith W. Ross. 计算机网络-自顶向下方法（原书第6版）. 机械工业出版社. 2014.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——tab.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/tab/</link>
      <pubDate>Thu, 14 Jul 2016 22:56:40 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/tab/</guid>
      <description>&lt;p&gt;tab切换是网页中的常见设计，从实现上讲也并不复杂，基本思路是导航监听事件，然后把之前显示的tab窗口隐藏掉，然后把导航对应的窗口展示出来，并且更新导航条的状态。bootstrap也对此提供了相应的插件支持，基本思路上都差不太多。先说一下依赖的html结构和css代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
  &amp;lt;!-- Nav tabs --&amp;gt;
  &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;active&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#home&amp;quot; aria-controls=&amp;quot;home&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Home
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#profile&amp;quot; aria-controls=&amp;quot;profile&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
   			 Profile
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#messages&amp;quot; aria-controls=&amp;quot;messages&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Messages
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#settings&amp;quot; aria-controls=&amp;quot;settings&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Settings
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;!-- Tab panes --&amp;gt; 
  &amp;lt;div class=&amp;quot;tab-content&amp;quot;&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane active&amp;quot; id=&amp;quot;home&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;profile&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;messages&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;settings&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体上分为两大块，一部分是导航，一部分是tab窗口，tab窗口的css比较简单，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tab-content &amp;gt; .tab-pane {
  display: none;
}
.tab-content &amp;gt; .active {
  display: block;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说白了只要控制&lt;code&gt;active&lt;/code&gt;类就能控制tab窗口的切换。比较复杂的是导航条的样式，基本款式有两种&lt;code&gt;nav-tabs&lt;/code&gt;和&lt;code&gt;nav-pills&lt;/code&gt;，这两个都可以配合&lt;code&gt;nav-justified&lt;/code&gt;类形成两端对齐的导航。其实这些样式层面的东西对于js代码没什么影响，我就说几个比较好玩的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs &amp;gt; li {
  float: left;
  margin-bottom: -1px;
}
.nav-tabs &amp;gt; li &amp;gt; a {
  margin-right: 2px;
  line-height: 1.42857143;
  border: 1px solid transparent;
  border-radius: 4px 4px 0 0;
}
.nav-tabs &amp;gt; li.active &amp;gt; a,
.nav-tabs &amp;gt; li.active &amp;gt; a:hover,
.nav-tabs &amp;gt; li.active &amp;gt; a:focus {
  color: #555;
  cursor: default;
  background-color: #fff;
  border: 1px solid #ddd;
  border-bottom-color: transparent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tab标签页我觉得是写的比较好的，尤其是对于导航条下面那条线的处理上。每一个标签项都是浮动的，显然会有清除浮动影响，没写在这里。那条线是写在整个导航条上的。那么如何实现 当前标签页没有下面那条线的？首先是利用&lt;code&gt;margin-bottom:-1px&lt;/code&gt;把每个标签项向下移动1px，然后每个标签项都有一个透明的1px边框，这时候标签项的下边框和导航条的下边框正好是重合的，由于颜色是透明的所以可以看得到导航条的边框。对于当前标签页，加了一个白色背景颜色，相当于是用背景色把导航边框色给盖住了。然而，为什么不用边框色盖住呢？非要写一个白色背景色，因为要处理&lt;code&gt;:hover&lt;/code&gt;和&lt;code&gt;:focus&lt;/code&gt;的情况。&lt;/p&gt;

&lt;p&gt;样式的东西就写这些，其实我觉得&lt;code&gt;nav-justified&lt;/code&gt;写得也很好，既实现了所有标签项占据100%空间，又能兼顾标签项内容的长度分配剩余空间，&lt;a href=&#34;http://stackoverflow.com/a/27846774&#34;&gt;stackoverflow上面有评论&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;说js部分了，利用data形式绑定事件以前已经说过了，然而我怀疑有没有必要整出&lt;code&gt;[data-toggle=&amp;quot;tab&amp;quot;]&lt;/code&gt;和&lt;code&gt;[data-toggle=&amp;quot;pill&amp;quot;]&lt;/code&gt;两个来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data(&#39;bs.tab&#39;)

	  if (!data) $this.data(&#39;bs.tab&#39;, (data = new Tab(this)))
	  if (typeof option == &#39;string&#39;) data[option]()
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和以往一样是把生成的对象挂到了data上，然后根据传入的参数做一些操作。在&lt;code&gt;Tab&lt;/code&gt;的原型上主要挂了两个方法&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;activate&lt;/code&gt; , &lt;code&gt;show&lt;/code&gt;方法主要的功能是判断要不要进行tab切换，切换的对象是谁。具体的切换是&lt;code&gt;activate&lt;/code&gt;方法实现的，这个方法相当于是对切换这个操作剥离出来，导航条标签的切换、tab窗口的切换都通过这个方法实现，这两个切换没有耦合在一起，这一点很不错。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;show&lt;/code&gt;方法里确定要展示的tab窗口是通过tab标签的&lt;code&gt;data-target&lt;/code&gt;或者&lt;code&gt;href&lt;/code&gt;实现的，弱弱的说一句，在bootstrap的插件里，有的是&lt;code&gt;href&lt;/code&gt;优先，有的是&lt;code&gt;data-target&lt;/code&gt;优先，不过正常人是不会两个都加上的。在&lt;code&gt;show&lt;/code&gt;方法里还触发了一些事件，相较于之前看过的几个插件，这里的事件复杂在有&lt;code&gt;relatedTarget&lt;/code&gt;的概念。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;activate&lt;/code&gt;方法中，首先获取当前活动的元素，然后判断是否要过渡。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var transition = callback
  &amp;amp;&amp;amp; $.support.transition
  &amp;amp;&amp;amp; ($active.length &amp;amp;&amp;amp; $active.hasClass(&#39;fade&#39;) || !!container.find(&#39;&amp;gt; .fade&#39;).length)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而我不太明白的是为啥一定要有callback才支持过渡。然后就是判断是否要过渡，如果要过渡的首先把当前展示的页面过渡、逐渐淡出，淡出完成后当前的移除&lt;code&gt;active&lt;/code&gt;类，target元素添加&lt;code&gt;active&lt;/code&gt;类，如果target元素需要过渡出来的话，还要先强制重绘一次，再添加&lt;code&gt;in&lt;/code&gt;这个类，否则会直接进入最终状态。如果不需要过渡直接从移除&lt;code&gt;active&lt;/code&gt;类开始执行。&lt;/p&gt;

&lt;p&gt;说实话，bootstrap的插件长的差不多，一开始觉得写法很独特，后来就习惯了，熟悉了写法之后其实插件的业务逻辑很好懂。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C#的基本语法</title>
      <link>http://jiangshanmeta.github.io/post/blog/csharp/</link>
      <pubDate>Wed, 13 Jul 2016 00:16:02 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/csharp/</guid>
      <description>

&lt;p&gt;今天老板问我，想学C#吗？于是我就念了两句诗：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;苟利国家生死以,岂因祸福避趋之&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;想想一个语言基本语法其实没多少，无非就是&lt;/p&gt;

&lt;h2 id=&#34;变量-常量-关键字-运算符-数组:daae90d06331bc886739d748003841f1&#34;&gt;变量、常量、关键字、运算符、数组&lt;/h2&gt;

&lt;h2 id=&#34;条件语句:daae90d06331bc886739d748003841f1&#34;&gt;条件语句&lt;/h2&gt;

&lt;h2 id=&#34;循环语句:daae90d06331bc886739d748003841f1&#34;&gt;循环语句&lt;/h2&gt;

&lt;p&gt;和我常用的javascript和php没什么太大区别，只是感觉有点像当年学的谭浩强的C。&lt;/p&gt;

&lt;p&gt;又想起来，被谭浩强支配的恐怖。&lt;/p&gt;

&lt;p&gt;为什么数组的长度是固定。。。。为什么数组内部元素要是一个类型。。。&lt;/p&gt;

&lt;p&gt;没有代码，因为真的不需要代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>本地存储的一些比较</title>
      <link>http://jiangshanmeta.github.io/post/blog/storage/</link>
      <pubDate>Sat, 09 Jul 2016 23:45:02 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/storage/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/blog/ebussiness/&#34;&gt;最近的项目中使用了localStorage实现了本地购物车&lt;/a&gt;，借着这个机会总结一下各种本地存储。还有，发现以往过于关注API层面的东西了，反而对API是为了解决什么忽视了。&lt;/p&gt;

&lt;h2 id=&#34;cookie:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;cookie&lt;/h2&gt;

&lt;p&gt;cookie应该是最早的本地存储，本来今天不想谈API的东西，但是cookie的api设计的简直反人类。&lt;/p&gt;

&lt;p&gt;cookie的一个很重要的应用是用来判断用户是谁（登录功能）。因为http是无状态协议，无法根据之前的状态进行本次的请求处理。在登录成功后后端返回的报文中会设定包含用户登录信息的cookie，以后请求的时候会在请求头信息中包含cookie。&lt;/p&gt;

&lt;p&gt;cookie在每次http请求中都是默认自带的，这点有好处也有坏处。好处是不用手动把cookie信息写入报文，并且一般后端语言也会默认支持对cookie的读取，比如php的&lt;code&gt;$_COOKIE&lt;/code&gt;，坏处是不管用不用得到都会一股脑传过去，虽然对于现在的网络环境而言这并不是什么太大的问题。cookie还有一个缺点是大小限制为4k，复杂点的web应用应该就不够用了。&lt;/p&gt;

&lt;p&gt;最近在看http相关的东西，发现还有个&lt;code&gt;httponly&lt;/code&gt;属性，我觉得挺好的，以前是以一个纯前端的角度去看cookie，因为js无法控制&lt;code&gt;httponly&lt;/code&gt;的cookie，所以没见过有人提。这个属性很好的提升了cookie的安全性。&lt;/p&gt;

&lt;h2 id=&#34;localstorage:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;localStorage&lt;/h2&gt;

&lt;p&gt;最近的项目中是要做一个购物车，因而使用了localStorage，相比较于cookie，它的存储空间更大，并且没有过期时间的概念，也就是说除非手动删除它会一直保存。&lt;/p&gt;

&lt;p&gt;和cookie还有一点不同就是需要自己手动向后端提交localStorage的内容，服务器端无法直接访问localStorage。确实可以减少网络传输。。毕竟设计的最大存储比cookie大多了，要是和cookie似的自动写到报文里每次请求估计最大的内容就是localStorage了吧。&lt;/p&gt;

&lt;p&gt;对于我的购物车功能，我觉得写得最折腾的就是同步本地数据和线上数据，每一次增删查改之后都要拿一份线上数据处理后然后返回给前端，前端再更新页面和更新localStorage。&lt;/p&gt;

&lt;h2 id=&#34;sessionstorage:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;sessionStorage&lt;/h2&gt;

&lt;p&gt;这是为了会话控制而存在的，看起来和localStorage很像但是生命周期短得多，如果关了网页重开就没了，开一个新的tab也不会有当前的sessionStorage。&lt;/p&gt;

&lt;h2 id=&#34;indexeddb:5fe4e2fe3590b5bd8669d1961910a370&#34;&gt;indexedDB&lt;/h2&gt;

&lt;p&gt;？？这货出现是为了解决啥？没想明白，难道是出来自high的？？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——collapse.js</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/collapse/</link>
      <pubDate>Fri, 08 Jul 2016 20:33:24 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/collapse/</guid>
      <description>&lt;p&gt;最近工作忙，好不容易闲下来身体又出bug了，好久没更新了。接着读bootstrap的代码，今天要说的是collapse.js。这个插件实现的展开与收缩效果。&lt;/p&gt;

&lt;p&gt;先看一下data-api&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).on(&#39;click.bs.collapse.data-api&#39;, &#39;[data-toggle=&amp;quot;collapse&amp;quot;]&#39;, function (e) {
	var $this   = $(this)

	if (!$this.attr(&#39;data-target&#39;)) e.preventDefault()

	var $target = getTargetFromTrigger($this)
	var data    = $target.data(&#39;bs.collapse&#39;)
	var option  = data ? &#39;toggle&#39; : $this.data()

	Plugin.call($target, option)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体绑定的方式和之前分析的alert、button差不多，都是利用事件委托机制。具体的回调函数比较复杂了。collapse.js设定了两种绑定展开收缩对象的形式，一种是通过a标签的&lt;code&gt;href&lt;/code&gt;属性，另一种是通过&lt;code&gt;data-target&lt;/code&gt;属性，并且还封装了一个小函数&lt;code&gt;getTargetFromTrigger&lt;/code&gt;找到对应的绑定元素。如果是通过&lt;code&gt;href&lt;/code&gt;属性指定展开收缩对象的话，需要阻止默认事件，至于阻止的是啥，还用我说嘛。然后的三行就写的比较巧妙了，先获取data上面保存的信息，然后如果之前保存过collapse的实例，给*option*赋值为&amp;rsquo;toggle&amp;rsquo;,如果没有，赋值为一个对象。为什么要返回一个data的对象？一开始我也没想明白，看到插件的具体内容才想明白为什么要加这个，因为这个插件还负责实现手风琴效果，手风琴效果总归需要一个包裹元素吧，这里的实现是通过&lt;code&gt;data-parent&lt;/code&gt;来决定这个包裹元素是谁。如果是最简单的展开收缩效果，option里面的只会有toggle，对于手风琴效果会对一个parent，针对这个parent有一些额外的操作。&lt;/p&gt;

&lt;p&gt;然后是Plugin的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data(&#39;bs.collapse&#39;)
	  var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == &#39;object&#39; &amp;amp;&amp;amp; option)

	  if (!data &amp;amp;&amp;amp; options.toggle &amp;amp;&amp;amp; /show|hide/.test(option)) options.toggle = false
	  if (!data) $this.data(&#39;bs.collapse&#39;, (data = new Collapse(this, options)))
	  if (typeof option == &#39;string&#39;) data[option]()
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bootstrap的插件基本上是按照一个模板出来的。在bootstrap插件里第一次见到使用&lt;code&gt;$.extend&lt;/code&gt;方法，使用过jquery的人应该了解这是合并对象用的，原生js的一个实现是&lt;code&gt;Object.assign&lt;/code&gt;，只是有点兼容问题。而且这里重新利用了&lt;strong&gt;toggle&lt;/strong&gt;属性，通过判断是否需要调用toggle方法，看Collapse构造函数就会明白这样会保证如果传入的不是&lt;code&gt;show&lt;/code&gt;或者&lt;code&gt;hide&lt;/code&gt;这两个字符串，就会&lt;strong&gt;toggle&lt;/strong&gt;一次。如果传入的是字符串，会调用相关方法。&lt;/p&gt;

&lt;p&gt;上面说的是写法上的巧妙之处，然而重点是这个展开收缩是如何实现的，在文档上有这么一句&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Collapse requires the transitions plugin to be included in your version of Bootstrap.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是说展开收缩效果是通过CSS3过渡实现的，我曾经想过如果用纯CSS实现这种展开收缩效果，但是由于&lt;code&gt;height&lt;/code&gt;无法从&lt;code&gt;auto&lt;/code&gt;过渡到一个具体数字，所以只能用有点hack意味的方案，我最终采用的是过渡&lt;code&gt;transform&lt;/code&gt;的&lt;code&gt;scale&lt;/code&gt;，这样有个问题的别的元素会认为这个元素依然是占据原来的大小。bootstrap的解决方案利用了js。&lt;/p&gt;

&lt;p&gt;当调用&lt;code&gt;show&lt;/code&gt;方法的时候，先做一些隔离，保证此时操作的元素处于hide状态。这时收缩状态的元素含有一个类&lt;code&gt;collapse&lt;/code&gt;，对应内容是&lt;code&gt;display:none&lt;/code&gt;，然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.$element
  .removeClass(&#39;collapse&#39;)
  .addClass(&#39;collapsing&#39;)[dimension](0)
  .attr(&#39;aria-expanded&#39;, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除&lt;code&gt;collapse&lt;/code&gt;这个类，这时候元素理应正常显示，这里强行设定高度为0，等一下我再吐槽这个&lt;code&gt;dimension&lt;/code&gt;，顺便吐槽&lt;code&gt;collapsing&lt;/code&gt;这个类。现在这个需要展开的元素高度为0，我们需要确定最终高度，bootstrap的实现我觉得挺巧的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scrollSize = $.camelCase([&#39;scroll&#39;, dimension].join(&#39;-&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是利用scrollHeight来确定最终高度的，初始高度、最终高度有了，过渡的最基本的条件就有了。过渡完成后的回调其实也比较有意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var complete = function () {
  this.$element
    .removeClass(&#39;collapsing&#39;)
    .addClass(&#39;collapse in&#39;)[dimension](&#39;&#39;)
  this.transitioning = 0
  this.$element
    .trigger(&#39;shown.bs.collapse&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除了&lt;code&gt;collapsing&lt;/code&gt;这个类，添加&lt;code&gt;collapse&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;两个类，并且把高度设置为默认值。为什么要这么做？因为以后这个展开收缩区域可能会动态添加或者删除内容，此时写死高度就有些不合适了。&lt;/p&gt;

&lt;p&gt;对应的&lt;code&gt;hide&lt;/code&gt;方法基本过程类似，其实只要看明白一个另一个也就差不多了。说一下要说的几点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.$element[dimension](this.$element[dimension]())[0].offsetHeight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前说过，无法实现、&lt;strong&gt;height&lt;/strong&gt;的从&lt;strong&gt;auto&lt;/strong&gt;到一个数值的过渡，我们需要获取元素的具体高度，这里还强行重绘了一次，保证把高度值从auto转换为具体的数值，之前&lt;code&gt;show&lt;/code&gt;方法里其实也强行重绘了一次，是在利用&lt;code&gt;scrollHeight&lt;/code&gt;获得高度的时候。其他的基本上就是&lt;code&gt;show&lt;/code&gt;方法的逆过程了。&lt;/p&gt;

&lt;p&gt;下面开始预告的吐槽&lt;/p&gt;

&lt;p&gt;在上面的解说中，我是直接把&lt;code&gt;dimension&lt;/code&gt;说成是&lt;code&gt;height&lt;/code&gt;，我们还是看代码把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collapse.prototype.dimension = function () {
	var hasWidth = this.$element.hasClass(&#39;width&#39;)
	return hasWidth ? &#39;width&#39; : &#39;height&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dimension就是上面几行代码的返回值，水平方向的展开收缩虽然不多见，但也总归是有，但是呢，你看你的控制过渡的类&lt;code&gt;collapsing&lt;/code&gt;的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  -webkit-transition-timing-function: ease;
       -o-transition-timing-function: ease;
          transition-timing-function: ease;
  -webkit-transition-duration: .35s;
       -o-transition-duration: .35s;
          transition-duration: .35s;
  -webkit-transition-property: height, visibility;
       -o-transition-property: height, visibility;
          transition-property: height, visibility;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你们写js的和写css的看来不是一个人啊，根本没实现对于宽度过渡的支持啊，你们。。。。&lt;/p&gt;

&lt;p&gt;这其实都是小事，我觉得一个让我很迷惑的问题是为啥&lt;code&gt;visibility&lt;/code&gt;这个属性也能过渡？于是&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2013/05/transition-visibility-show-hide/&#34;&gt;张鑫旭大神又解释过这个问题了&lt;/a&gt;。其中张鑫旭前辈提到了应用场景&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;举个例子，我们要实现淡入淡出效果，显然是需要改变透明度的，但是，元素即使透明度变成0，虽然肉眼看不见，但是，在页面上，元素还是可以点击，还是可以覆盖其他元素的，这显然是有问题的，我们最最希望的是在元素淡出动画结束后，元素可以自动隐藏！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人觉得他对&lt;code&gt;opacity:0;&lt;/code&gt;和&lt;code&gt;visibility:hidden&lt;/code&gt;的区别没有说清楚。这时候就要搬出&lt;a href=&#34;http://stackoverflow.com/a/273076&#34;&gt;stackoverflow上的回答&lt;/a&gt;。这两个都是不脱离文档流，但是前者依然响应事件，而后者不响应事件。不过回到这个插件里来，并没有用到&lt;code&gt;visibility&lt;/code&gt;的过渡。&lt;/p&gt;

&lt;p&gt;主体内容差不多就完了，关于手风琴效果的具体实现，以及其他的细节自己去看源码吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一个电商网站的基本实现</title>
      <link>http://jiangshanmeta.github.io/post/blog/ebussiness/</link>
      <pubDate>Tue, 05 Jul 2016 20:05:02 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/blog/ebussiness/</guid>
      <description>&lt;p&gt;最近在做的是一个简易的购物系统，因为并不是主营业务，所以并不像电商网站那样复杂，否则就我一个人做这件事情会崩溃的。虽然只是一个简易版的电商，但是各项功能还是有的。有商品的展示列表，商品的详情展示，购物车功能，订单功能，金流管理。其中支付功能和金流我要处理的并不多，只是在以往基础上添加几个参数写几个if else。其他的就要一个一个慢慢写。&lt;/p&gt;

&lt;p&gt;第一个要实现的是商品的本身。&lt;/p&gt;

&lt;p&gt;关于这些商品，一开始我们是线上部分只做纯展示使用，线下负责具体的业务，所以这个商品表的结构并不困难，一个名称，一段描述，一张图，一个价格范围，这些都是很简单的东西，比较复杂的是商品的分类，于是我们又建了一个商品分类表，商品表里保存着商品分类表里的一个id。这个商品分类表其实不复杂，一个名称，再加上一个enum的基础分类即可，其余字段都是小的辅助。有了商品做商品列表和商品详情页就没什么难的了，就是个纯展示的工作。因为种类本身就不多，连搜索都没加。第一阶段的工作就这样结束了，也没有后面这个小型电商网站什么事。&lt;/p&gt;

&lt;p&gt;后来，后来就开始做了呗。首先要做的是补充商品信息。原来只有一个简单的商品描述，但是型号、颜色之类的都没有去添加。针对这个问题，本来是想和淘宝似的做个正交的分类。然后老板直接说就做一级分类。这数据上的复杂度就直接下来了。一个商品对应多个型号，每个型号有自己的价格，与淘宝不同的是，我们线下有多家实体店，所以每个型号需要对应多个库存。一般来说这种多型号的应该建张商品型号表然后关联起来，然而本来为了偷懒我就建了个array然后多个型号都扔到这个这个array里。最终的后台编辑这个型号是用vue做的。深深感觉我在这里留了的坑。希望后人重构的时候能够淡定。其实还有个坑，是我在数据库的最终保存形式是json而不是一个array。我已经遇到一个坑了。自己挖的坑，含着泪也要踩下去。&lt;/p&gt;

&lt;p&gt;商品的必要信息有了，然后是购物车的实现。&lt;/p&gt;

&lt;p&gt;作为一个穷的只逛淘宝的人，其他的电商网站我还真的不熟悉。淘宝最近实在推app，对于购物车功能要求登录。然而传统的电商是不要求登陆的。于是我们需要本地存储。我们使用的本地存储方案是localStorage。之所以采用这个方案一个很重要的方案是因为同事也在用它做本地存储，当然，从纯技术角度来看localStorage比cookie好用，而且作为移动端项目也不用太过于担心兼容性问题。&lt;/p&gt;

&lt;p&gt;然后是购物车的数据结构。一开始有两个大的方向，一个是在用户本身建一个购物车字段存具体信息，因为我们使用的是mongoDB数据库，可以存一个array，另一个方案是拆一张表出来。于是我就问头其他电商的思路，头说考虑性能还是建张表吧。表的结构不复杂，用户的id，用户基本信息的快照，商品的id，商品型号，商品基本信息快照，商品数量，加入时间。最后一个我是见有的电商购物车保存多少天然后就删掉而预留的字段，目前并没有用到。用户每次想购物车加入商品，就会插入一条记录。&lt;/p&gt;

&lt;p&gt;数据结构约定好了就要实现同步了。其实我的做法是比较投机取巧的，如果是非登录态，添加商品的时候只会快照一些基本信息存到localStorage里，但是如果是在登录态，向购物里添加东西是需要ajax请求的，后端插入数据后返回的数据包含这个购物车记录的id，我就利用有没有这个id判断数据库是否已插入这条数据。遍历post过来的本地数据，如果没购物车id就直接插入一条新的记录，如果有这个id就update一下（可能会修改数量，本身我只支持修改数量，并不支持修改型号），一些安全校验就不说了。但是上面的实现有个问题，一开始我也没有想到，就是一条购物车记录线上有数据，但是用户在非登录态删除了，同步的时候上面的方法并无法识别。我的解决方案是 在处理post过来的数据之前先拿到此时线上购物车的ids 存成一个array（这个时间点很重要），然后处理post过来的数据，把post过来的数据库id也存成一个array，两者比较如果线上有post过来的没有，就说明本地删了数据，要把线上数据也删除。&lt;/p&gt;

&lt;p&gt;其他的就是些增删查改之类的工作了，没什么太大的难度，就是注意同步数据这个问题，顺便感谢vue。&lt;/p&gt;

&lt;p&gt;购物车实现完成之后就是从购物车到订单了。&lt;/p&gt;

&lt;p&gt;从购物车到订单这一步牵扯到的表比较多。购物车表、商品表、订单表，还有一个子订单表。购物车表就不用说了，商品表是因为要查一遍最新的商品信息，拿到最新的价格等信息，用户选中的购物车中的每一条记录都会转化成子订单中的一条记录，同时在订单表中更新。订单表除了子订单这一个字段外，还有一些用户的基本信息，状态、各种时间戳。&lt;/p&gt;

&lt;p&gt;从购物车生成订单后，还需要用户确认。因为业务的需要，有些商品虽然是线上卖，但是要到线下实体店处理（我不会告诉你处理这个写了不少代码），还有有的商品可以邮寄，就有了满多少钱包邮的问题。所以需要用户确认取货方式、去哪家店处理、最终支付金额。在这里用户可以选择删除部分子订单，或者把一些订单里的商品重新放回购物车，或者把订单彻底取消。前两个处理的时候需要考虑订单中商品价格的重新计算、顺带着还有是否达到包邮价格。&lt;/p&gt;

&lt;p&gt;后来同事吐槽我说你见过哪个电商有放回购物车这个功能的？于是我就念了两句诗。不要在乎这些细节，反正我实现了。&lt;/p&gt;

&lt;p&gt;用户确认订单后后进入支付环节。此时，用户依然可以取消订单。支付是用的同事封装好的代码，虽然我也改了几行，毕竟同事写的代码考虑的都是主营业务订单，我们这个小电商系统实际是自己写着玩的。在支付成功的回调函数中，我更新了订单的状态，写入了金流信息。&lt;/p&gt;

&lt;p&gt;现在用户已付款，剩下的就是门店获取订单信息，准备货，就是一些基本的增删查改。&lt;/p&gt;

&lt;p&gt;这个小电商基本上是实现了，但是我的主要工作是实现功能，也就是把js和php写完，换句话说就是样式完全没理，根本没法看。看看是让美术设计一套还是抄一套别的电商的样式。&lt;/p&gt;

&lt;p&gt;基本就这样。写了差不多一个星期，完活，撒花。&lt;/p&gt;

&lt;p&gt;然后就遇到坑了。在商品分类那里，原来是要考虑多家门店多个库存的，后来老板说这样维护起来压力过大，让我在商品分类那里存一个配件id，把这个当成一个配件，然后在库存表里查库存信息。其实写起来并没有什么问题，多查一次表而已。&lt;/p&gt;

&lt;p&gt;update 2016/08/02&lt;/p&gt;

&lt;p&gt;其实这个小电商功能一直没怎么用起来，今天又小修小补了，做了一个直接购买功能。其实是同事闲先加入购物车再购买是在太折腾，让我仿照其他电商网站做一个直接购买功能。仅仅从功能实现角度来看这个问题其实并不复杂，但是我发现我上面预言有坑的地方确实坑到了自己。每次的匹配规格做的太纠结了，当初真的该建一张新表。然而后悔也晚了，数据已经填进去了，现在改就太折腾了，所以还是想着法补救吧。其实现在想做的是把这个规格匹配封装到Model层中，至少不用每次复制粘贴规格匹配了。而且有了&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/exit/&#34;&gt;封装差错检测&lt;/a&gt;的经验这个也做起来很容易，匹配成功就返回必要的数据，匹配不成功就直接报错退出程序。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>图文混排布局的一个小tip</title>
      <link>http://jiangshanmeta.github.io/post/tabletip/</link>
      <pubDate>Tue, 28 Jun 2016 23:14:10 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/tabletip/</guid>
      <description>&lt;p&gt;如果想实现一个左图右文布局，可以使用浮动，这是很普遍的一点。但是如果如果右侧文字很少，会显得右侧很空，这时候我们会希望一些文字能够拿到下面来，差不多和图片齐平，显然浮动无法实现，一个很直接的想法是需要等高布局。等高布局比较靠谱的解决方案是利用&lt;a href=&#34;http://jiangshanmeta.github.io/post/table/&#34;&gt;css table&lt;/a&gt;，利用同一行中单元格等高这一特性来实现。但是说实话table真的很难驯服，再加上图文混排出幺蛾子的概率很高。如果按照默认样式的可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/table/tabletip.png&#34; alt=&#34;乱的布局&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要实现上面的结果其实还做过一些处理，因为图可能很大，但是我只希望图片区占有一定比例，其他的所以采用&lt;code&gt;table-layout:fixed&lt;/code&gt;属性加上百分比的宽度，具体的分析上面那个连接给出了说明。&lt;/p&gt;

&lt;p&gt;为什么文字会这么靠下呢，因为&lt;code&gt;vertical-align&lt;/code&gt;属性默认值为&lt;code&gt;baseline&lt;/code&gt;,把右侧文字区的&lt;code&gt;vertical-align&lt;/code&gt;设为&lt;code&gt;top&lt;/code&gt;就好了。然后想放在下面的文字就绝对定位就好了，别忘了给右侧文字区域加上&lt;code&gt;position:ralative&lt;/code&gt;，基本常识了。&lt;/p&gt;

&lt;p&gt;这样基本上差不多了，可以上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;了。&lt;/p&gt;

&lt;p&gt;稍微精益求精的可以发现左侧图片区的高度比图片高度大那么一点，换句话说就是图片下面还有一定空间，这一因为行高，可行的解决方案有如下几个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图片设置为&lt;code&gt;display:block;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片区行高设置&lt;code&gt;line-height:0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片&lt;code&gt;vertical-align&lt;/code&gt;设置为&lt;code&gt;top&lt;/code&gt; || &lt;code&gt;bottom&lt;/code&gt; || &lt;code&gt;middle&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是第二天就用到相关知识了。老板想做类似的东西，左侧依然是图片区，中间是文字区，右侧是一个垂直居中的箭头。这个设计确实挺常见的。然后我就把上面的实现说了一下，然后最右侧加了一个&lt;code&gt;vertical-align:middle&lt;/code&gt;,我实现的demo和上面的demo放在一个页面里了。老板听完我的实现后就默默地决定最右边的那个箭头放背景图里然后默默切图去了。嘤嘤嘤。&lt;/p&gt;

&lt;p&gt;update 2016/07/19&lt;/p&gt;

&lt;p&gt;看到&lt;a href=&#34;http://www.w3cplus.com/css/media-object-vs-flag-object.html&#34;&gt;一篇文章&lt;/a&gt;是讲这一类布局的，还起了一个高大上的名字叫做&lt;strong&gt;媒体对象&lt;/strong&gt;，话说bootstrap里也有类似实现。里面也提到了这种利用table布局的方式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>table那些事</title>
      <link>http://jiangshanmeta.github.io/post/table/</link>
      <pubDate>Mon, 27 Jun 2016 21:09:14 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/table/</guid>
      <description>

&lt;p&gt;最近我的知乎时间线上出现了这么一个问题:&lt;a href=&#34;https://www.zhihu.com/question/20003535&#34;&gt;网页的 Table 布局和 DIV+CSS 布局从哪里可以看出来？Table 布局已经过时了吗？&lt;/a&gt;，于是便想着总结一下关于table的一些知识点。先声明一下，这里table是指css table，而不是html table，以下所说的可能用html的形式来写，但都是指的css table。&lt;/p&gt;

&lt;h2 id=&#34;基本概念:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;基本概念&lt;/h2&gt;

&lt;h4 id=&#34;关于表格的display值:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于表格的display值&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;table                对应html中的&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row            对应html中的&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-cell           对应htnl中的&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row-group      对应html中的&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-header-group   对应html中的&lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-footer-group   对应html中的&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-caption        对应html中的&lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column         对应html中的&lt;code&gt;&amp;lt;col&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column-group   对应html中的&lt;code&gt;&amp;lt;colgroup&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最重要的是前三个属性，而最后两个可以认为没什么用处，因为css将其表模型定义为以行为主，也就是说，它认为web开发者会显式声明行，而列是从单元格行的布局推导出来的。&lt;/p&gt;

&lt;h4 id=&#34;匿名表对象:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;匿名表对象&lt;/h4&gt;

&lt;p&gt;在html的table，有一些嵌套标签即使你不去写，浏览器也会去帮你填充，css的table也有类似的现象，可以将“遗漏的”组件作为匿名对象插入。插入遵循以下规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一个table-cell元素的父元素不是table-row元素，则会在该table-cell元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素的所有连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的父元素不是table、table-row-group元素，则会在该table-row元素及其父元素之间插入一个匿名table元素。插入的这个对象将包含该table-row元素的连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-column元素的父元素不是table、table-column-group元素，则在该table-column元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在该table元素及其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素及所有不是table-row-group、table-header-group、table-footer-group、table-row、table-caption元素的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row对象，则在该元素及其子元素之间插入一个匿名table-row对象。这个匿名对象包含该子元素及其所有非table-row对象的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象。这个匿名对象包含该子元素及其所有非table-cell元素的连续兄弟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看起来比较理论，大家自己读读就好。&lt;/p&gt;

&lt;h4 id=&#34;固定布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;固定布局&lt;/h4&gt;

&lt;p&gt;熟悉css属性的人对于&lt;code&gt;table-layout&lt;/code&gt;应该不陌生，这个属性很大程度上影响了table的布局。首先介绍的固定布局，对应的属性值是&lt;code&gt;fixed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要实现固定布局，首先要设定&lt;code&gt;table-layout&lt;/code&gt;为&lt;code&gt;fixed&lt;/code&gt;,这是显然的，但是也是不足的，除此之外还要设定table的宽度，否则会按照自动布局进行。&lt;/p&gt;

&lt;p&gt;具体实现上包括以下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;width属性不是auto的列元素会根据width值设置该列的宽度。&lt;/li&gt;
&lt;li&gt;如果一个列的宽度为auto，但是表首行中该列的单元格width不为auto，则根据单元格宽度设置此列宽度。其它行设定的宽度无效。&lt;/li&gt;
&lt;li&gt;经过前两步，如果列的宽度依然为auto，会自动确定其大小，使其宽度尽可能相等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;固定布局速度比较快，因为布局不依赖与内容，而是根据表的宽度、列和单元格的width决定。&lt;/p&gt;

&lt;p&gt;上面提到的第三点是table实现等分布局的基础。&lt;/p&gt;

&lt;h4 id=&#34;自动布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;自动布局&lt;/h4&gt;

&lt;p&gt;自动布局是table的默认布局，但是因为要根据内容决定布局，所以布局速度较慢。&lt;/p&gt;

&lt;p&gt;对于自动布局，具体宽度的计算比较复杂，而且对于中英文分割也比较复杂。所以这里就简要介绍一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于一列的各个单元格，计算最小和最大单元格宽度。&lt;/li&gt;
&lt;li&gt;对于各列，计算最小和最大列宽&lt;/li&gt;
&lt;li&gt;计算出表的真正宽度和各列宽度。如果表的&lt;code&gt;width&lt;/code&gt;属性不是auto，则将width属性值与所有列宽之和比较，取较大的作为表的宽度。如果最终宽度大于各列宽度之和，多余宽度各列均分。如果表的&lt;code&gt;width&lt;/code&gt;属性为auto，则将各列宽度之和作为表的宽度。换句话说，表的宽度恰好足够显示其内容，这一点是&lt;strong&gt;不定宽元素水平居中&lt;/strong&gt;的基础。然而，在&lt;code&gt;width&lt;/code&gt;为&lt;code&gt;auto&lt;/code&gt;的情况下，一个表可能会很难看，尤其是中文，有的时候可能发现每一列宽度都很小甚至只能写下一个字然后整个文字就竖起来了。目测bootstrap也是因为这个所以给table一个&lt;code&gt;width:100%&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;关于height:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于height&lt;/h4&gt;

&lt;p&gt;对于web开发者来说，一般很少显式声明一个元素的高度，但是对于table来说，就有点有趣了&lt;/p&gt;

&lt;p&gt;先约定一下页面结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;display:table;height:600px;&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果行高度不限制，三行内容一致，你会发现三行等分了整个表的高度，共同占据了600px的高度，这一点和常规div表现不一致。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果高度不限制，三行内容不一致，那么三行均分剩余高度。看起来上面说的内容一致的是这里的特殊情况。你不觉得和&lt;code&gt;flex&lt;/code&gt;有点像吗，&lt;code&gt;flex-grow&lt;/code&gt;属性就可以分配剩余空间，不过能设置分配系数，比这里强大点。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;//于是，我无意间实现了简单模拟&lt;code&gt;flex-grow&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;如果高度限制了比例，你会发现这里的比例只是参考比例，如果足够放得下，那么就按照这个比例，如果不够放，那么会调整比例使其恰能放开。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（依然和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上面的情况延伸一下，如果有一个行高度设为了100%，其它行高度会调整为恰好够填充，而这一行会填充满剩余空间。之前提到过这一点可以用来实现sticky footer，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;table的用处:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;table的用处&lt;/h2&gt;

&lt;h4 id=&#34;不定宽元素水平居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;不定宽元素水平居中&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-table{
  display:table;
  margin-left:auto;
  margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面有说，是自动布局&lt;code&gt;width&lt;/code&gt;属性为&lt;code&gt;auto&lt;/code&gt;时&lt;code&gt;display:table&lt;/code&gt;的元素宽度为内容宽度&lt;/p&gt;

&lt;h4 id=&#34;垂直居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;垂直居中&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&#34;http://jiangshanmeta.github.io/post/center/&#34;&gt;我的总结&amp;ndash;居中的实现&lt;/a&gt;中提到到过，利用的是&lt;code&gt;vertical-align:middle&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;等分布局-多列布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等分布局/多列布局&lt;/h4&gt;

&lt;p&gt;这两类基本布局我更习惯用浮动实现，对于&lt;code&gt;table&lt;/code&gt;实现没有什么特别大的爱好，等分布局需要&lt;code&gt;table-layout:fixed;&lt;/code&gt;这一属性。&lt;/p&gt;

&lt;h4 id=&#34;等高布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等高布局&lt;/h4&gt;

&lt;p&gt;如果不用table，实现等高布局的最简单方式应该是&lt;code&gt;flex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还是直接上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;吧，我这里实现了图文混排下的等高。&lt;/p&gt;

&lt;h4 id=&#34;sticky-footer:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;sticky footer&lt;/h4&gt;

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/stickyfooter/&#34;&gt;总结过sticky footer的实现&lt;/a&gt;,以及&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>