<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Networking on jsmeta</title>
    <link>http://jiangshanmeta.github.io/categories/computer-networking/</link>
    <description>Recent content in Computer Networking on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 24 Jul 2016 20:36:07 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/categories/computer-networking/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>初识传输层</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/transportlayer/</link>
      <pubDate>Sun, 24 Jul 2016 20:36:07 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/transportlayer/</guid>
      <description>

&lt;p&gt;传输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。作为WEB开发者虽然并不直接接触传输层，但是了解一下基本原理对于理解应用层还是有帮助的。&lt;/p&gt;

&lt;h2 id=&#34;传输层的功能:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;传输层的功能&lt;/h2&gt;

&lt;p&gt;传输层的功能是为不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;。注意这里是逻辑通信，而不是物理通信，传输层是在端系统中实现的而不是在路由器中实现的。在发送端，传输层将从应用进程收到的报文转换成传输层报文段，添加传输层首部。在接收端，网络层从数据报中提取传输层报文，并将其交给传输层。传输层处理收到的报文段，为应用层提供数据。&lt;/p&gt;

&lt;p&gt;常见的传输层协议有UDP和TCP。UDP为应用层提供了不可靠、无连接的服务，而TCP提供了可靠、面向连接的服务。&lt;/p&gt;

&lt;h2 id=&#34;多路复用-多路分解:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;多路复用/多路分解&lt;/h2&gt;

&lt;p&gt;应用层和传输层之间不是直接交换数据，而是通过套接字socket。每一个套接字都有唯一标识符。&lt;/p&gt;

&lt;p&gt;为了在不同主机之间标示套接字，需要在传输层报文中有几个字段。在接收端，传输层检查这些字段，标识出接收套接字，进而将报文段定向到套接字。将传输层报文中的数据交付到正确的套接字的工作称为&lt;strong&gt;多路分解&lt;/strong&gt;。从源主机中不同套接字中收集数据块，为其封装首部信息，然后将报文段传给网络层，这些工作称为&lt;strong&gt;多路复用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在UDP中一个套接字是通过 目的IP和目的端口号标示的。在TCP中一个套接字是通过 源IP地址、源端口号、目的IP地址、目的端口号标示的。&lt;/p&gt;

&lt;h2 id=&#34;udp协议:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;UDP协议&lt;/h2&gt;

&lt;p&gt;UDP协议为应用层提供了不可靠、无连接的服务。UDP是应用层协议比较简单的实现，能提供的功能仅有多路复用/多路分用和差错检验。&lt;/p&gt;

&lt;p&gt;先说一下UDP报文的结构。传输层报文是在应用层报文基础上添加了首部信息，即传输层报文 = 传输层首部 + 应用信息。我们的关注点显然是首部字段。&lt;/p&gt;

&lt;p&gt;UDP有四个首部，分别是：源端口号、目的端口号、长度、校验和。源端口号和目的端口号是多路复用/多路分用的基础，长度字段指明了UDP报文的字节数（首部+数据）。校验和是为了差错检验功能。然而不幸的是UDP协议仅仅能够发现错误，但无法从错误中恢复出来，所以UDP协议无法提供可靠地数据传输。&lt;/p&gt;

&lt;p&gt;应用UDP协议的应用，一般是对数据可靠性要求没那么高的，比如DNS查询、网络电话、在线直播之类的。&lt;/p&gt;

&lt;h2 id=&#34;可靠数据传输原理:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;可靠数据传输原理&lt;/h2&gt;

&lt;p&gt;这个问题说实话有点大了，其实写一个系列丛书讨论这个问题都不为过。我这里就说点总结性的。&lt;/p&gt;

&lt;p&gt;为了检验数据是否有差错，采用了校验和。&lt;/p&gt;

&lt;p&gt;为了返回检查结果和接受信息，采用了反馈机制。&lt;/p&gt;

&lt;p&gt;为了处理丢包，采用了超时机制。&lt;/p&gt;

&lt;p&gt;为了处理数据错误和丢包，采用了重传机制（重传大法好）。&lt;/p&gt;

&lt;p&gt;为了标识每一个分组、处理冗余分组、检测丢包，采取了序号。&lt;/p&gt;

&lt;p&gt;为了解决管线化操作中的差错恢复，出现了回退N步和选择重传。&lt;/p&gt;

&lt;h2 id=&#34;tcp报文:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP报文&lt;/h2&gt;

&lt;h2 id=&#34;tcp连接:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP连接&lt;/h2&gt;

&lt;h2 id=&#34;tcp流量控制:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP流量控制&lt;/h2&gt;

&lt;h2 id=&#34;tcp拥塞控制:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;h2 id=&#34;从应用层角度看传输层:7d394745458fab98d1011e5dc7ce06d1&#34;&gt;从应用层角度看传输层&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>http方法和状态码</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/</link>
      <pubDate>Sun, 17 Jul 2016 20:44:32 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/</guid>
      <description>

&lt;p&gt;http协议是web开发的基础，然而内容太多，即使是入门级的内容也不是一两篇文章能总结好的。这里就先总结一下http方法和状态码。&lt;/p&gt;

&lt;h2 id=&#34;http方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;http方法&lt;/h2&gt;

&lt;h4 id=&#34;get方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;GET方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;方法通常用来向服务器请求某个资源。一般打开某个网页就是使用&lt;code&gt;GET&lt;/code&gt;方法。&lt;/p&gt;

&lt;h4 id=&#34;post方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;POST方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;方法是用来向服务器输入数据的。有的表单提交就是采用&lt;code&gt;POST&lt;/code&gt;方法，不过随着现在业务逻辑的复杂化，应该很少有人会直接使用这种方法提交表单，而是采用&lt;code&gt;ajax&lt;/code&gt;提交表单内容。&lt;/p&gt;

&lt;h4 id=&#34;head方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;HEAD方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt;方法和&lt;code&gt;GET&lt;/code&gt;方法很类似，但是服务器在响应中只会返回首部，而不会返回主体部分。&lt;/p&gt;

&lt;h4 id=&#34;put方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;PUT方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;PUT&lt;/code&gt;方法用于向服务器写入文档。&lt;code&gt;PUT&lt;/code&gt;方法的语义是让服务器用请求的主体部分来创建一个由所请求URL命名的新文档，或者，如果那个URL已经存在，就用这个主体替代它。&lt;/p&gt;

&lt;p&gt;因为&lt;code&gt;PUT&lt;/code&gt;方法允许对内容进行修改，对于WEB服务器，原则上应该需要用户登录确认身份。&lt;/p&gt;

&lt;h4 id=&#34;delete方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;DELETE方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;DELETE&lt;/code&gt;方法是与&lt;code&gt;PUT&lt;/code&gt;方法相反的方法，它用来删除文件。&lt;/p&gt;

&lt;h4 id=&#34;options方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;OPTIONS方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;OPTIONS&lt;/code&gt;方法请求服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。&lt;/p&gt;

&lt;h4 id=&#34;trace方法:299e9942cf324699ed9e60279b71ca7a&#34;&gt;TRACE方法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;TRACE&lt;/code&gt;方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。服务器会在响应主体中携带它收到的原始请求报文。&lt;/p&gt;

&lt;h2 id=&#34;http状态码和原因短语:299e9942cf324699ed9e60279b71ca7a&#34;&gt;http状态码和原因短语&lt;/h2&gt;

&lt;p&gt;http状态码为客户端提供了一种理解事务处理结果的便捷方式。原因短语一般是为了方便人类理解而存在的。&lt;/p&gt;

&lt;h3 id=&#34;100-199-信息性状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;100-199 信息性状态码&lt;/h3&gt;

&lt;h4 id=&#34;101-switching-protocols:299e9942cf324699ed9e60279b71ca7a&#34;&gt;101 Switching Protocols&lt;/h4&gt;

&lt;p&gt;服务器正在根据客户端的指定，将协议切换成Update首部所列的首部。&lt;/p&gt;

&lt;h3 id=&#34;200-299-成功状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;200-299 成功状态码&lt;/h3&gt;

&lt;h4 id=&#34;200-ok:299e9942cf324699ed9e60279b71ca7a&#34;&gt;200 OK&lt;/h4&gt;

&lt;p&gt;表示从客户端发来的请求在服务器端正常处理了。在响应实体中包含了所请求的资源。&lt;/p&gt;

&lt;h4 id=&#34;204-no-content:299e9942cf324699ed9e60279b71ca7a&#34;&gt;204 No Content&lt;/h4&gt;

&lt;p&gt;表示客户端发来的请求在服务器端得到正常处理，但是在响应报文中不含实体的主体部分。大家可以看一下知乎专栏写文章那个页面，应该是监听输入事件然后发起ajax请求保存文章内容，然后返回的状态码就是204。虽然我个人认为知乎的这个保存设计不是很好。&lt;/p&gt;

&lt;h4 id=&#34;206-partical-content:299e9942cf324699ed9e60279b71ca7a&#34;&gt;206 Partical Content&lt;/h4&gt;

&lt;p&gt;成功执行了一个Range请求。206响应中必须包含&lt;code&gt;Content-Range&lt;/code&gt;、&lt;code&gt;Date&lt;/code&gt;、&lt;code&gt;ETag&lt;/code&gt;或&lt;code&gt;Content-Location&lt;/code&gt;首部。&lt;/p&gt;

&lt;h3 id=&#34;300-399-重定向状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;300-399 重定向状态码&lt;/h3&gt;

&lt;h4 id=&#34;301-moved-permanently:299e9942cf324699ed9e60279b71ca7a&#34;&gt;301 Moved Permanently&lt;/h4&gt;

&lt;p&gt;永久重定向。表示请求的资源已经被分配了新的URL，响应的&lt;code&gt;Location&lt;/code&gt;首部字段包含资源现在所处的URL。&lt;/p&gt;

&lt;h4 id=&#34;302-found-303-see-other-307-temporary-redirect:299e9942cf324699ed9e60279b71ca7a&#34;&gt;302 Found、303 See Other、307 Temporary Redirect&lt;/h4&gt;

&lt;p&gt;这三个状态码表示临时重定向 ，功能差不多，但是有些许差异，而且还牵扯到http/1.0和http/1.1版本问题。&lt;/p&gt;

&lt;p&gt;在http/1.0中，如果发送的是POST请求，服务器返回302，则需要向用户确认是否重发、重发依然是POST请求。&lt;/p&gt;

&lt;p&gt;在http/1.1中，浏览器对于302，其实是按照303处理的，即POST请求会转换为GET请求然后重发。&lt;/p&gt;

&lt;p&gt;在http/1.1中，浏览器对待307，其实和http/1.0中的302一致，不改变请求状态。&lt;/p&gt;

&lt;p&gt;换句话说对于&lt;code&gt;GET&lt;/code&gt;请求这几个没什么区别，对于&lt;code&gt;POST&lt;/code&gt;请求，正常人会希望重定向为一个新的&lt;code&gt;POST&lt;/code&gt;请求，会采用307状态码。然而有应用场景？&lt;/p&gt;

&lt;p&gt;可以参考&lt;a href=&#34;http://www.cnblogs.com/cswuyg/p/3871976.html&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;304-not-modified:299e9942cf324699ed9e60279b71ca7a&#34;&gt;304 Not Modified&lt;/h4&gt;

&lt;p&gt;客户端可以在请求首部中包含条件请求首部，如果不满足条件的话就返回304。带有这个状态码的响应不应该包含实体的主体部分。&lt;/p&gt;

&lt;h3 id=&#34;400-499-客户端错误状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;400-499 客户端错误状态码&lt;/h3&gt;

&lt;h4 id=&#34;400-bad-request:299e9942cf324699ed9e60279b71ca7a&#34;&gt;400 Bad Request&lt;/h4&gt;

&lt;p&gt;表示请求报文有语法错误&lt;/p&gt;

&lt;h4 id=&#34;403-forbidden:299e9942cf324699ed9e60279b71ca7a&#34;&gt;403 Forbidden&lt;/h4&gt;

&lt;p&gt;表示请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可在响应主体对原因进行说明。然而，通常情况下因为不想说明为什么拒绝才用这个状态码，所以我至今不明白为什么有那么两天mongodb中文网给我403。&lt;/p&gt;

&lt;h4 id=&#34;404-not-found:299e9942cf324699ed9e60279b71ca7a&#34;&gt;404 Not Found&lt;/h4&gt;

&lt;p&gt;这个就太熟悉了，服务器找不到所请求的url。&lt;/p&gt;

&lt;h3 id=&#34;500-599-服务器错误状态码:299e9942cf324699ed9e60279b71ca7a&#34;&gt;500-599 服务器错误状态码&lt;/h3&gt;

&lt;h4 id=&#34;500-internal-server-error:299e9942cf324699ed9e60279b71ca7a&#34;&gt;500 Internal Server Error&lt;/h4&gt;

&lt;p&gt;在开发中，我的本地数据库连的同事的，然而有的时候连不上，就会报500。&lt;/p&gt;

&lt;h4 id=&#34;503-service-unavailable:299e9942cf324699ed9e60279b71ca7a&#34;&gt;503 Service Unavailable&lt;/h4&gt;

&lt;p&gt;服务器现在无法为请求提供服务，但将来可以。偶尔见到维护的时候用过这个状态码。&lt;/p&gt;

&lt;h2 id=&#34;请求行与响应行:299e9942cf324699ed9e60279b71ca7a&#34;&gt;请求行与响应行&lt;/h2&gt;

&lt;p&gt;请求行的语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;method&amp;gt;&amp;lt;request-URL&amp;gt;&amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子，请求知乎首页的请求行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;响应行的语法如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;version&amp;gt;&amp;lt;status&amp;gt;&amp;lt;reason-phrase&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求知乎首页响应行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求行和响应行需要方法、url、版本、状态码和状态短语。方法、状态码状态短语上面说过了，版本对于现代浏览器是http/1.1。url就不说了。&lt;/p&gt;

&lt;p&gt;update 2016/07/19&lt;/p&gt;

&lt;p&gt;既然提到了状态码，引用一段项目中的相关函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;redirect&#39;))
{
    function redirect($uri = &#39;&#39;, $method = &#39;location&#39;, $http_response_code = 302)
    {
        if ( ! preg_match(&#39;#^https?://#i&#39;, $uri))
        {
            $uri = site_url($uri);
        }

        switch($method)
        {
            case &#39;refresh&#39;  : header(&amp;quot;Refresh:0;url=&amp;quot;.$uri);
                break;
            default         : header(&amp;quot;Location: &amp;quot;.$uri, TRUE, $http_response_code);
                break;
        }
        exit;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码语言是最好的编程语言php（大雾。作用是重定向，这里默认的重定向状态码就是302，虽然严格来说用303更好。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DNS原理入门</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/dns/</link>
      <pubDate>Sun, 17 Jul 2016 00:43:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/dns/</guid>
      <description>&lt;p&gt;作为半路出发搞web开发的，计算机网络的知识很薄弱，我可不想一辈子写写页面做做增删查改就完了，要提高一下自己的知识水平。光看书也不行，把自己学到的讲出来，这样能够加深理解。&lt;/p&gt;

&lt;p&gt;一般的介绍计算机网络会从OSI模型或者TCP/IP模型开始介绍，虽然目前有个整体的概念但是理解还是不深，所以我想放到最后说。首先要说的应用层的DNS。DNS基本不会被用户手动使用，但是会被其他应用层程序调用，因为DNS的主要作用是将主机名映射到IP地址。为什么需要这么做？因为不同端系统之间的通信需要IP地址来帮助寻找目标主机。&lt;/p&gt;

&lt;p&gt;除了将主机名映射到IP地址这个作用外，DNS还有以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主机别名&lt;/li&gt;
&lt;li&gt;邮件服务器别名&lt;/li&gt;
&lt;li&gt;负载分配。这一点需要说一说，对于一些大站，为了性能优化会部署在多个服务器上。此时一个主机名就会对应多个IP地址。用户请求的时候DNS服务器返回的不是一个IP，而是一组，但是在每次响应时会循环地址次序。在客户端根据返回的IP发起请求的时候通常会先请求排在前面的IP地址，于是便实现了负载分配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整体掌握DNS的功能后，然后我们要看的是DNS查询的过程。&lt;/p&gt;

&lt;p&gt;处于种种原因（大家可以自行想象），DNS采取了分布式、分层次的数据库。DNS服务器大体分为三种类型：根DNS服务器、顶级域DNS服务器、权威DNS服务器。还有一个本地DNS服务器，通常本地DNS服务器是由ISP提供的，相当于是我们DNS查询的一个代理，并且还起到缓存的作用。&lt;/p&gt;

&lt;p&gt;我们要进行DNS查询，首先是查询本地hosts，如果有结果就直接返回IP，这就是为什么本地开发要改hosts。一般的用户是不会配置本地hosts的，不考虑浏览器缓存的话会向本地DNS服务器查询（其实是应用程序如浏览器的缓存优先级更高）。其实也不见得是向本地DNS服务器请求，因为可以设置DNS服务器IP，然而对于一般用户本地DNS服务器地址是接入网的时候就分配好的。通用过程是DNS服务器先向根DNS服务器请求，根DNS服务器会返回顶级域DNS服务器的地址，然后本地DNS服务器据此地址请求顶级域DNS服务器，顶级域DNS服务器返回权威DNS服务器的地址。本地DNS服务器再向权威DNS服务器请求，最终由权威DNS返回查询主机的IP。其实这只是一个简化模型，因为返回的可能不是下一层DNS服务器地址，而是一个中间DNS服务器地址。&lt;/p&gt;

&lt;p&gt;要获得一个主机到IP的映射本地DNS服务器至少要发起三次请求，接受三次回复，如果每次都重复此过程其实是比较昂贵的，所以就有了DNS缓存，通常本地DNS服务器会起到这么一个作用。在查询过程中，会先判断本地缓存有没有相关信息，再进行操作。DNS缓存也会有过期时间的概念，这点不难理解，毕竟互联网是一个动态的网络。&lt;/p&gt;

&lt;p&gt;最终本地DNS服务器向端系统返回IP。换句话说，对于客户端来说，直接发生作用的只有本地DNS服务器，向其他各级DNS服务器请求是本地DNS服务器帮助我们完成的。&lt;/p&gt;

&lt;p&gt;这里还会有 &lt;strong&gt;递归查询&lt;/strong&gt;、&lt;strong&gt;迭代查询&lt;/strong&gt;的概念，理解了上述过程，这两个概念理解起来就没什么难度了。&lt;/p&gt;

&lt;p&gt;DNS协议运行在传输层的UDP协议之上。&lt;/p&gt;

&lt;p&gt;DNS查询基本过程了解了，我们要看一下DNS记录的内容。DNS记录的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Name,Value,Type,TTL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TTL是生存时间，Name和Value的含义决定于Type&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;A&lt;/code&gt;，则Name是主机名，Value是主机名对应IP地址&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;NS&lt;/code&gt;，则Name是域，Value是知道如何获得该域权威DNS服务器的&lt;strong&gt;主机名&lt;/strong&gt;，注意Value是一个主机名，不是IP&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;CNAME&lt;/code&gt;，则Name是别名，Value是规范主机名。这就是为什么DNS会提供别名服务&lt;/p&gt;

&lt;p&gt;如果Type是&lt;code&gt;MX&lt;/code&gt;，则Name是邮件服务系统的主机名，Value是别名。这就是为什么DNS会提供邮件服务器别名服务&lt;/p&gt;

&lt;p&gt;至于DNS报文，我目前认为没有太多值得在这里去说的。&lt;/p&gt;

&lt;p&gt;DNS的功能、DNS查询过程、DNS记录和报文相关的内容就说到这里吧。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考资料&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;James F. Kurose， Keith W. Ross. 计算机网络-自顶向下方法（原书第6版）. 机械工业出版社. 2014.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>