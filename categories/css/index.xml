<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Css on jsmeta</title>
    <link>http://jiangshanmeta.github.io/categories/css/</link>
    <description>Recent content in Css on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Aug 2016 20:03:58 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/categories/css/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>上网的不科学指南</title>
      <link>http://jiangshanmeta.github.io/post/computernetwork/summarize/</link>
      <pubDate>Tue, 16 Aug 2016 20:03:58 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/computernetwork/summarize/</guid>
      <description>&lt;p&gt;看计算机网络已经有一段时间了，对于应用层、传输层、网络层、链路层也有了基本的了解。但是感觉自己学的比较零碎，缺乏一个整体的概念，所以想写一篇总结，把这些东西串起来。&lt;/p&gt;

&lt;p&gt;想要上网的话，首先要通过&lt;strong&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;&lt;/strong&gt;获得一个IP地址。&lt;/p&gt;

&lt;p&gt;客户端这里首先生成一个DHCP发现报文，然后把这个报文交给传输层传输层的&lt;code&gt;UDP&lt;/code&gt;，DHCP有固定的源端口号和目的端口号。&lt;code&gt;UDP&lt;/code&gt;封装好之后，交给网络层去处理，网络层的IP报文需要填写目的IP地址和源IP地址，然而目前自身的IP待分配、目的IP地址也未知，这里就需要两个特殊的IP地址了，源IP地址为&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，目的IP地址为&lt;code&gt;255.255.255.255&lt;/code&gt;表示广播地址。网络层处理完交给数据链路层处理，需要源MAC地址和目的MAC地址，现在连DHCP服务器是谁都不知道怎么确定MAC地址？答案和刚提到的广播IP地址类似，目的MAC地址填上广播MAC地址&lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;局域网内部的每一台主机都能收到这个报文，但是只有DHCP服务器才会做出响应。对于DHCP服务器，数据自下传递到上层，然后把分配的IP地址、DNS服务器地址、默认网关地址、子网掩码 作为DHCP ACK报文，然后向下逐层封装。形成IP报文的时候目的地址依然为广播地址。在这里说一句无论是DHCP发现报文还是DHCP ACK报文，中间都经过&lt;code&gt;链路层交换机&lt;/code&gt;，链路层交换机会根据源MAC地址和输入链路的接口在交换机表中记录一条记录，作为转发的基础。&lt;/p&gt;

&lt;p&gt;现在我们这台主机获得了自己的IP地址，顺便还有默认DNS服务器地址、默认网关地址、子网掩码。当我们在地址栏中输入一个url的时候，比如 &lt;a href=&#34;http://jiangshanmeta.github.io&#34;&gt;http://jiangshanmeta.github.io&lt;/a&gt; ，就需要通过&lt;code&gt;DNS&lt;/code&gt;服务（至少对于chrome调用DNS不见得一定在输入url然后确认之后，我们没有必要关心这个调用的时机）。DNS服务器地址是在DHCP返回的，有可能和我们的主机在一个子网内，也可能不在一个子网内，这需要结合两者的IP地址和&lt;strong&gt;子网掩码&lt;/strong&gt;判断，通常不要指望在一个子网内。要和子网外部进行通信需要通过网关，我们已经有了默认网关地址（一个IP地址），但是数据链路层需要MAC地址，因而我们需要&lt;code&gt;ARP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;ARP是根据IP地址返回MAC地址，它也是利用广播，子网内每台主机都会收到ARP报文，但是只有IP地址对应的才会返回MAC地址。通过ARP获得默认网关MAC地址，这样在主机那里各层发送DNS报文所需要的基本信息就有了，DNS交给UDP、UDP交给IP然后交给链路层封装成帧，所形成的数据帧传递到路由器，路由器这里根据由&lt;code&gt;路由协议&lt;/code&gt;（这么复杂的协议我说这么一句话真的好吗）决定的转发表决定转发的输出链路，根据转发表提供的下一跳IP地址利用ARP获得新的目的MAC地址重写数据链路层（在路由器网络层首部和数据链路层都会有一些首部字段被修改，目的MAC地址是每经过一次路由器就修改，但是目的IP地址相一般不会修改，除非是经过了&lt;code&gt;NAT&lt;/code&gt;）。本地DNS服务器获得请求之后，可能&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;经过一系列请求&lt;/a&gt;，也可能直接根据缓存返回要查询的IP地址。这样我们的主机获得了请求域名的IP地址，对网页的请求的准备工作基本完成了。&lt;/p&gt;

&lt;p&gt;现在需要发起HTTP请求了，以我上面提到的网址为例就是发送一个GET请求，应用层把http报文交给TCP，TCP相比较上面提到的传输层协议UDP，提供可靠传输功能。它需要首先建立连接，然后才能传递上层传来的数据。再往下层的东西上面已经提及了，通过网关出子网，然后经过各种路由转发最终到达目标服务器，目标服务器根据请求的url提供文件，然后又是一层层封装路由转发解封装到达应用层，这样我们得到了请求的文件，比如html，剩下的就是浏览器如何解析返回的数据了，这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;这样我基本上把所学到的计算机网络知识串了起来，包括&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;DNS&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/&#34;&gt;http&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;传输层&lt;/a&gt;的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/&#34;&gt;TCP&lt;/a&gt;和UDP、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;、网络层的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/ip/&#34;&gt;网际协议&lt;/a&gt;和路由协议、NAT、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/mac/&#34;&gt;链路层MAC地址、ARP协议（这是个跨层的协议）、链路层交换机&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;每一层都有了一定的了解，下面的任务是转入http协议的学习和设计模式的学习了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>终于bootstrap满足不了我了——用flex实现一个栅格系统</title>
      <link>http://jiangshanmeta.github.io/post/css/flex/</link>
      <pubDate>Sat, 13 Aug 2016 14:16:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/flex/</guid>
      <description>&lt;p&gt;bootstrap样式方面我觉得最重要的就是栅格系统了，然而在实际项目中觉得有些情况它所能提供的满足不了我的需求了。最近感受比较深的就是列表展示页面，每一个列表项对应的图片文字大小所需空间不一致，我的一个解决方案是利用CSS文字强制只显示一行或多行（不知道如何实现的自行百度），然后图片&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;放在一个正方形的盒子里展示&lt;/a&gt;，确实是一个解决问题的方法但我觉得不够优雅。其实根本问题出现在bootstrap的栅格系统是基于浮动的，每一个列高度不一致导致布局错乱显然是不可避免的。bootstrap也考虑到了这个问题，他们的解决方案是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;建议联合使用 .clearfix 和 响应式工具类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说的没错，只要在每行之间加上一个&lt;code&gt;.clearfix&lt;/code&gt;确实能解决问题。但是我显然是动态输出页面的啊，我还要手动写个计数器然后输出这个清除浮动的标签，总觉得略折腾。&lt;/p&gt;

&lt;p&gt;那既然问题是不等高造成的做个等高布局怎么样？ 说的就和等高布局好做似的。padding撑出去+margin缩回来方案hack意味太浓，table的同行单元格等高这一属性可以利用但是我还要输出表示行的标签，折腾程度差不多，响应式处理起来更折腾，那似乎就剩下flex了。但是对于flex float又直接失效。&lt;/p&gt;

&lt;p&gt;于是我想着干脆用flex模拟一个bootstrap的栅格系统，对于熟悉flex布局和bootstrap的同学这并不难。&lt;/p&gt;

&lt;p&gt;首先是container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
	box-sizing:border-box;
}
.flex-container {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
@media (min-width: 768px) {
  .flex-container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .flex-container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .flex-container {
    width: 1170px;
  }
}
.flex-container-fluid {
	display:flex;
	margin-right:auto;
	margin-left:auto;
	flex-flow:row wrap;
	justify-content:flex-start;
	align-items:stretch;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是每一列的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-12 {
	flex:0 0 100%;
}
.flex-col-xs-11 {
	flex:0 0 91.66666667%;
}
.flex-col-xs-10 {
	flex:0 0 83.33333333%;
}
.flex-col-xs-9 {
	flex:0 0 75%;
}
.flex-col-xs-8 {
	flex:0 0 66.66666667%;
}
.flex-col-xs-7 {
	flex:0 0 58.33333333%;
}
.flex-col-xs-6 {
	flex:0 0 50%;
}
.flex-col-xs-5 {
	flex:0 0 41.66666667%;
}
.flex-col-xs-4 {
	flex:0 0 33.33333333%;
}
.flex-col-xs-3 {
	flex:0 0 25%;
}
.flex-col-xs-2 {
	flex:0 0 16.66666667%;
}
.flex-col-xs-1 {
	flex:0 0 8.33333333%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是列的响应式处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media (min-width: 768px) {
	.flex-col-sm-12 {
		flex:0 0 100%;
	}
	.flex-col-sm-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-sm-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-sm-9 {
		flex:0 0 75%;
	}
	.flex-col-sm-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-sm-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-sm-6 {
		flex:0 0 50%;
	}
	.flex-col-sm-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-sm-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-sm-3 {
		flex:0 0 25%;
	}
	.flex-col-sm-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-sm-1 {
		flex:0 0 8.33333333%;
	}
}


@media (min-width: 992px) {
	.flex-col-md-12 {
		flex:0 0 100%;
	}
	.flex-col-md-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-md-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-md-9 {
		flex:0 0 75%;
	}
	.flex-col-md-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-md-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-md-6 {
		flex:0 0 50%;
	}
	.flex-col-md-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-md-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-md-3 {
		flex:0 0 25%;
	}
	.flex-col-md-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-md-1 {
		flex:0 0 8.33333333%;
	}

}

@media (min-width: 1200px) {
	.flex-col-lg-12 {
		flex:0 0 100%;
	}
	.flex-col-lg-11 {
		flex:0 0 91.66666667%;
	}
	.flex-col-lg-10 {
		flex:0 0 83.33333333%;
	}
	.flex-col-lg-9 {
		flex:0 0 75%;
	}
	.flex-col-lg-8 {
		flex:0 0 66.66666667%;
	}
	.flex-col-lg-7 {
		flex:0 0 58.33333333%;
	}
	.flex-col-lg-6 {
		flex:0 0 50%;
	}
	.flex-col-lg-5 {
		flex:0 0 41.66666667%;
	}
	.flex-col-lg-4 {
		flex:0 0 33.33333333%;
	}
	.flex-col-lg-3 {
		flex:0 0 25%;
	}
	.flex-col-lg-2 {
		flex:0 0 16.66666667%;
	}
	.flex-col-lg-1 {
		flex:0 0 8.33333333%;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列偏移部分，只列出了xs部分，没写响应式部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-offset-12 {
  margin-left: 100%;
}
.flex-col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.flex-col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.flex-col-xs-offset-9 {
  margin-left: 75%;
}
.flex-col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.flex-col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.flex-col-xs-offset-6 {
  margin-left: 50%;
}
.flex-col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.flex-col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.flex-col-xs-offset-3 {
  margin-left: 25%;
}
.flex-col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.flex-col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.flex-col-xs-offset-0 {
  margin-left: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列排序，和bootstrap一样，基于&lt;code&gt;position:relative&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.flex-col-xs-1,
.flex-col-xs-2,
.flex-col-xs-3,
.flex-col-xs-4,
.flex-col-xs-5,
.flex-col-xs-6,
.flex-col-xs-7,
.flex-col-xs-8,
.flex-col-xs-9,
.flex-col-xs-10,
.flex-col-xs-11,
.flex-col-xs-12{
	position:relative;
}

.flex-col-xs-pull-12 {
  right: 100%;
}
.flex-col-xs-pull-11 {
  right: 91.66666667%;
}
.flex-col-xs-pull-10 {
  right: 83.33333333%;
}
.flex-col-xs-pull-9 {
  right: 75%;
}
.flex-col-xs-pull-8 {
  right: 66.66666667%;
}
.flex-col-xs-pull-7 {
  right: 58.33333333%;
}
.flex-col-xs-pull-6 {
  right: 50%;
}
.flex-col-xs-pull-5 {
  right: 41.66666667%;
}
.flex-col-xs-pull-4 {
  right: 33.33333333%;
}
.flex-col-xs-pull-3 {
  right: 25%;
}
.flex-col-xs-pull-2 {
  right: 16.66666667%;
}
.flex-col-xs-pull-1 {
  right: 8.33333333%;
}
.flex-col-xs-pull-0 {
  right: auto;
}
.flex-col-xs-push-12 {
  left: 100%;
}
.flex-col-xs-push-11 {
  left: 91.66666667%;
}
.flex-col-xs-push-10 {
  left: 83.33333333%;
}
.flex-col-xs-push-9 {
  left: 75%;
}
.flex-col-xs-push-8 {
  left: 66.66666667%;
}
.flex-col-xs-push-7 {
  left: 58.33333333%;
}
.flex-col-xs-push-6 {
  left: 50%;
}
.flex-col-xs-push-5 {
  left: 41.66666667%;
}
.flex-col-xs-push-4 {
  left: 33.33333333%;
}
.flex-col-xs-push-3 {
  left: 25%;
}
.flex-col-xs-push-2 {
  left: 16.66666667%;
}
.flex-col-xs-push-1 {
  left: 8.33333333%;
}
.flex-col-xs-push-0 {
  left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个基于flex的栅格系统就差不多了，包含响应式布局、列偏移、列排序，其实还可以列嵌套，我其实还可以宣称自己基于移动优先的理念之类的。和bootstrap的栅格系统相比，还差点兼容性以及gutter的概念，这个没什么难的，就这样吧。&lt;/p&gt;

&lt;p&gt;还有，女神叫我出去浪，我却在这写博客，终于明白为什么我会孤独一生了。&lt;/p&gt;

&lt;p&gt;update 2016/08/17&lt;/p&gt;

&lt;p&gt;还是把&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.less&#34;&gt;less文件&lt;/a&gt;  和 &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/flexgrid/flexgrid.css&#34;&gt;编译出来的CSS文件放到这里吧&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS中一些“奇技淫巧”</title>
      <link>http://jiangshanmeta.github.io/post/css/csstricks/</link>
      <pubDate>Sun, 31 Jul 2016 20:28:36 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css/csstricks/</guid>
      <description>

&lt;p&gt;声明一下，这里的奇技淫巧是指自己用得少觉得新奇而且有实际应用场景的CSS属性，而不是诸如用CSS画个IE8不支持的IE8图标之类的纯粹为了炫技然而实际没什么用途的黑魔法。&lt;/p&gt;

&lt;h4 id=&#34;1-currentcolor:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;1.currentColor&lt;/h4&gt;

&lt;p&gt;这是一个颜色的关键字值，浏览器将对应的值解析为color的值，可以用在border 、box-shadow、background上面。有点像less、sass中的变量。用途的话&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2014/10/currentcolor-css3-powerful-css-keyword/&#34;&gt;张鑫旭大神已经给了几个&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-user-select:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;2.user-select&lt;/h4&gt;

&lt;p&gt;知乎上有一个作者保留权利，对于这种情况如果用户复制的话会复制一些版权信息。其实现上我猜是监听了copy事件之类的。我觉得知乎可以对这些作者保留权利的内容使用&lt;code&gt;user-select:none;&lt;/code&gt;，这样对于普通用户连选择都做不到。&lt;/p&gt;

&lt;p&gt;不过这个属性兼容性有点差，在&lt;a href=&#34;http://caniuse.com/#search=user-select%3A&#34;&gt;can I use&lt;/a&gt;上查到的信息是目前还是乖乖加上私有前缀吧。&lt;/p&gt;

&lt;h4 id=&#34;3-selection:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;3.::selection&lt;/h4&gt;

&lt;p&gt;在CSS中伪元素常用的只有&lt;code&gt;::before&lt;/code&gt;和&lt;code&gt;::after&lt;/code&gt;,&lt;code&gt;::selection&lt;/code&gt;就显得比较小众了。浏览器默认的文字选中样式是白字蓝底，说实话真的不好看。这个伪元素就给了我们控制选中状态文字样式的可能性。&lt;/p&gt;

&lt;p&gt;本来以为萌娘百科的黑幕样式会使用这一个选择器，然而他们使用了浏览器的默认选择状态。&lt;/p&gt;

&lt;h4 id=&#34;4-pointer-events-none:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;4.pointer-events:none&lt;/h4&gt;

&lt;p&gt;这个CSS让js和CSS的边界越来越模糊。想象这么一个场景：要做一个活动页，需要全屏的canvas绘制一些东西，这个canvas相当于一个遮罩层，但是我又想遮罩层下面的元素响应各种事件，尤其是点击事件。想通过js完成这件事目测要写一堆，但是对这个遮罩层使用&lt;code&gt;pointer-events:none&lt;/code&gt;即可让这个遮罩层不响应点击事件。&lt;/p&gt;

&lt;h4 id=&#34;5-content的attr:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;5.content的attr&lt;/h4&gt;

&lt;p&gt;伪元素大家应该不陌生了，但是伪元素的content属性我一般用的不多，后来发现一篇文章&lt;a href=&#34;http://web.jobbole.com/86079/&#34;&gt;美化加载失败的图片&lt;/a&gt;发现了content属性的一些玩法。我们可以通过attr属性引入一些属性的内容，比如&lt;code&gt;img::after{content:&#39;[&#39;attr(src)&#39;]&#39;}&lt;/code&gt;，这样就能在图片加载不出来的时候把原始图片地址显示出来（虽然我怀疑用户能否理解）。类似的思路，我们可以显示a标签的href属性&lt;code&gt;a::after{content:attr(href)}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;今天发现了一个&lt;a href=&#34;http://codepen.io/airen/pen/jrNBKp&#34;&gt;attr结合data的一个demo&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-direction:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;6.direction&lt;/h4&gt;

&lt;p&gt;这个属性有用的只有两个值：&lt;code&gt;ltr&lt;/code&gt;、&lt;code&gt;rtl&lt;/code&gt;，含义分别是从左向右和从右向左。猜也能猜出来默认值是&lt;code&gt;ltr&lt;/code&gt;。或许你会认为应用&lt;code&gt;rtl&lt;/code&gt;后会改变文字排版变成从右向左排布，然而那是&lt;code&gt;writing-mode&lt;/code&gt;的工作（顺便说一句，目前文字排版的常规模式是从左到右从上到下，除了搞两句古诗词的文艺小清新我觉得没人会闲的改变这种模式）。那么这个&lt;code&gt;direction&lt;/code&gt;改变的是什么的方向？ 改变的是&lt;strong&gt;内联元素块&lt;/strong&gt;的左右顺序，而内联元素块内部的元素是当做一个整体看待。换句话说，&lt;code&gt;direction&lt;/code&gt;属性可以在不改变DOM前后顺序的前提下改变内联元素块的前后顺序，听着好像低配版的flex布局的&lt;code&gt;order&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;干什么用呢？&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/03/css-direction-introduction-apply/&#34;&gt;张鑫旭大神提供了例子&lt;/a&gt;，在不改变DOM的情况下添加类名改变弹框组件的按钮顺序。&lt;/p&gt;

&lt;h4 id=&#34;7-padding:153eaa3ceec693de6b0bebfe9dc213fa&#34;&gt;7.padding&lt;/h4&gt;

&lt;p&gt;关于padding作为前端应该都不陌生，但是padding本身也是具有奇技淫巧的。&lt;/p&gt;

&lt;p&gt;之前我利用padding实现了&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;自适应的正方形和长宽比一定的长方形&lt;/a&gt;，今天学了一手新的，结合&lt;code&gt;padding&lt;/code&gt;以及&lt;code&gt;background-clip&lt;/code&gt;绘制图形。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/csstricks/padding.html&#34;&gt;在线demo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;在bootstrap导航条组件中，有一个三道杠的图标，他们的实现是使用三个span元素做的，根据张鑫旭大神的思路，这里使用一个div就完成了。对于这个需求，其实也可以通过伪元素来实现。&lt;/p&gt;

&lt;p&gt;另外还有一些视频进度条的圆环，我结合伪元素、圆角、padding、background-clip也实现了。对于这一需求，也可以通过&lt;code&gt;box-shadow&lt;/code&gt;来实现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>图文混排布局的一个小tip</title>
      <link>http://jiangshanmeta.github.io/post/tabletip/</link>
      <pubDate>Tue, 28 Jun 2016 23:14:10 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/tabletip/</guid>
      <description>&lt;p&gt;如果想实现一个左图右文布局，可以使用浮动，这是很普遍的一点。但是如果如果右侧文字很少，会显得右侧很空，这时候我们会希望一些文字能够拿到下面来，差不多和图片齐平，显然浮动无法实现，一个很直接的想法是需要等高布局。等高布局比较靠谱的解决方案是利用&lt;a href=&#34;http://jiangshanmeta.github.io/post/table/&#34;&gt;css table&lt;/a&gt;，利用同一行中单元格等高这一特性来实现。但是说实话table真的很难驯服，再加上图文混排出幺蛾子的概率很高。如果按照默认样式的可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/table/tabletip.png&#34; alt=&#34;乱的布局&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要实现上面的结果其实还做过一些处理，因为图可能很大，但是我只希望图片区占有一定比例，其他的所以采用&lt;code&gt;table-layout:fixed&lt;/code&gt;属性加上百分比的宽度，具体的分析上面那个连接给出了说明。&lt;/p&gt;

&lt;p&gt;为什么文字会这么靠下呢，因为&lt;code&gt;vertical-align&lt;/code&gt;属性默认值为&lt;code&gt;baseline&lt;/code&gt;,把右侧文字区的&lt;code&gt;vertical-align&lt;/code&gt;设为&lt;code&gt;top&lt;/code&gt;就好了。然后想放在下面的文字就绝对定位就好了，别忘了给右侧文字区域加上&lt;code&gt;position:ralative&lt;/code&gt;，基本常识了。&lt;/p&gt;

&lt;p&gt;这样基本上差不多了，可以上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;了。&lt;/p&gt;

&lt;p&gt;稍微精益求精的可以发现左侧图片区的高度比图片高度大那么一点，换句话说就是图片下面还有一定空间，这一因为行高，可行的解决方案有如下几个&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图片设置为&lt;code&gt;display:block;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片区行高设置&lt;code&gt;line-height:0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左侧图片&lt;code&gt;vertical-align&lt;/code&gt;设置为&lt;code&gt;top&lt;/code&gt; || &lt;code&gt;bottom&lt;/code&gt; || &lt;code&gt;middle&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是第二天就用到相关知识了。老板想做类似的东西，左侧依然是图片区，中间是文字区，右侧是一个垂直居中的箭头。这个设计确实挺常见的。然后我就把上面的实现说了一下，然后最右侧加了一个&lt;code&gt;vertical-align:middle&lt;/code&gt;,我实现的demo和上面的demo放在一个页面里了。老板听完我的实现后就默默地决定最右边的那个箭头放背景图里然后默默切图去了。嘤嘤嘤。&lt;/p&gt;

&lt;p&gt;update 2016/07/19&lt;/p&gt;

&lt;p&gt;看到&lt;a href=&#34;http://www.w3cplus.com/css/media-object-vs-flag-object.html&#34;&gt;一篇文章&lt;/a&gt;是讲这一类布局的，还起了一个高大上的名字叫做&lt;strong&gt;媒体对象&lt;/strong&gt;，话说bootstrap里也有类似实现。里面也提到了这种利用table布局的方式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>table那些事</title>
      <link>http://jiangshanmeta.github.io/post/table/</link>
      <pubDate>Mon, 27 Jun 2016 21:09:14 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/table/</guid>
      <description>

&lt;p&gt;最近我的知乎时间线上出现了这么一个问题:&lt;a href=&#34;https://www.zhihu.com/question/20003535&#34;&gt;网页的 Table 布局和 DIV+CSS 布局从哪里可以看出来？Table 布局已经过时了吗？&lt;/a&gt;，于是便想着总结一下关于table的一些知识点。先声明一下，这里table是指css table，而不是html table，以下所说的可能用html的形式来写，但都是指的css table。&lt;/p&gt;

&lt;h2 id=&#34;基本概念:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;基本概念&lt;/h2&gt;

&lt;h4 id=&#34;关于表格的display值:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于表格的display值&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;table                对应html中的&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row            对应html中的&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-cell           对应htnl中的&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-row-group      对应html中的&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-header-group   对应html中的&lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-footer-group   对应html中的&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-caption        对应html中的&lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column         对应html中的&lt;code&gt;&amp;lt;col&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;table-column-group   对应html中的&lt;code&gt;&amp;lt;colgroup&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最重要的是前三个属性，而最后两个可以认为没什么用处，因为css将其表模型定义为以行为主，也就是说，它认为web开发者会显式声明行，而列是从单元格行的布局推导出来的。&lt;/p&gt;

&lt;h4 id=&#34;匿名表对象:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;匿名表对象&lt;/h4&gt;

&lt;p&gt;在html的table，有一些嵌套标签即使你不去写，浏览器也会去帮你填充，css的table也有类似的现象，可以将“遗漏的”组件作为匿名对象插入。插入遵循以下规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一个table-cell元素的父元素不是table-row元素，则会在该table-cell元素及其父元素之间插入一个匿名table-row对象。所插入的这个对象将包含该table-cell元素的所有连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的父元素不是table、table-row-group元素，则会在该table-row元素及其父元素之间插入一个匿名table元素。插入的这个对象将包含该table-row元素的连续兄弟。&lt;/li&gt;
&lt;li&gt;如果一个table-column元素的父元素不是table、table-column-group元素，则在该table-column元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名table元素。&lt;/li&gt;
&lt;li&gt;如果一个table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在该table元素及其子元素之间插入一个匿名table-row对象。这个匿名对象将包含该子元素及所有不是table-row-group、table-header-group、table-footer-group、table-row、table-caption元素的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row对象，则在该元素及其子元素之间插入一个匿名table-row对象。这个匿名对象包含该子元素及其所有非table-row对象的连续兄弟&lt;/li&gt;
&lt;li&gt;如果一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象。这个匿名对象包含该子元素及其所有非table-cell元素的连续兄弟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看起来比较理论，大家自己读读就好。&lt;/p&gt;

&lt;h4 id=&#34;固定布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;固定布局&lt;/h4&gt;

&lt;p&gt;熟悉css属性的人对于&lt;code&gt;table-layout&lt;/code&gt;应该不陌生，这个属性很大程度上影响了table的布局。首先介绍的固定布局，对应的属性值是&lt;code&gt;fixed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要实现固定布局，首先要设定&lt;code&gt;table-layout&lt;/code&gt;为&lt;code&gt;fixed&lt;/code&gt;,这是显然的，但是也是不足的，除此之外还要设定table的宽度，否则会按照自动布局进行。&lt;/p&gt;

&lt;p&gt;具体实现上包括以下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;width属性不是auto的列元素会根据width值设置该列的宽度。&lt;/li&gt;
&lt;li&gt;如果一个列的宽度为auto，但是表首行中该列的单元格width不为auto，则根据单元格宽度设置此列宽度。其它行设定的宽度无效。&lt;/li&gt;
&lt;li&gt;经过前两步，如果列的宽度依然为auto，会自动确定其大小，使其宽度尽可能相等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;固定布局速度比较快，因为布局不依赖与内容，而是根据表的宽度、列和单元格的width决定。&lt;/p&gt;

&lt;p&gt;上面提到的第三点是table实现等分布局的基础。&lt;/p&gt;

&lt;h4 id=&#34;自动布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;自动布局&lt;/h4&gt;

&lt;p&gt;自动布局是table的默认布局，但是因为要根据内容决定布局，所以布局速度较慢。&lt;/p&gt;

&lt;p&gt;对于自动布局，具体宽度的计算比较复杂，而且对于中英文分割也比较复杂。所以这里就简要介绍一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于一列的各个单元格，计算最小和最大单元格宽度。&lt;/li&gt;
&lt;li&gt;对于各列，计算最小和最大列宽&lt;/li&gt;
&lt;li&gt;计算出表的真正宽度和各列宽度。如果表的&lt;code&gt;width&lt;/code&gt;属性不是auto，则将width属性值与所有列宽之和比较，取较大的作为表的宽度。如果最终宽度大于各列宽度之和，多余宽度各列均分。如果表的&lt;code&gt;width&lt;/code&gt;属性为auto，则将各列宽度之和作为表的宽度。换句话说，表的宽度恰好足够显示其内容，这一点是&lt;strong&gt;不定宽元素水平居中&lt;/strong&gt;的基础。然而，在&lt;code&gt;width&lt;/code&gt;为&lt;code&gt;auto&lt;/code&gt;的情况下，一个表可能会很难看，尤其是中文，有的时候可能发现每一列宽度都很小甚至只能写下一个字然后整个文字就竖起来了。目测bootstrap也是因为这个所以给table一个&lt;code&gt;width:100%&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;关于height:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;关于height&lt;/h4&gt;

&lt;p&gt;对于web开发者来说，一般很少显式声明一个元素的高度，但是对于table来说，就有点有趣了&lt;/p&gt;

&lt;p&gt;先约定一下页面结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;display:table;height:600px;&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;display:table-row;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果行高度不限制，三行内容一致，你会发现三行等分了整个表的高度，共同占据了600px的高度，这一点和常规div表现不一致。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果高度不限制，三行内容不一致，那么三行均分剩余高度。看起来上面说的内容一致的是这里的特殊情况。你不觉得和&lt;code&gt;flex&lt;/code&gt;有点像吗，&lt;code&gt;flex-grow&lt;/code&gt;属性就可以分配剩余空间，不过能设置分配系数，比这里强大点。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;//于是，我无意间实现了简单模拟&lt;code&gt;flex-grow&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;如果高度限制了比例，你会发现这里的比例只是参考比例，如果足够放得下，那么就按照这个比例，如果不够放，那么会调整比例使其恰能放开。&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/table.html&#34;&gt;在线demo（依然和上面同一个）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上面的情况延伸一下，如果有一个行高度设为了100%，其它行高度会调整为恰好够填充，而这一行会填充满剩余空间。之前提到过这一点可以用来实现sticky footer，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;table的用处:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;table的用处&lt;/h2&gt;

&lt;h4 id=&#34;不定宽元素水平居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;不定宽元素水平居中&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-table{
  display:table;
  margin-left:auto;
  margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理上面有说，是自动布局&lt;code&gt;width&lt;/code&gt;属性为&lt;code&gt;auto&lt;/code&gt;时&lt;code&gt;display:table&lt;/code&gt;的元素宽度为内容宽度&lt;/p&gt;

&lt;h4 id=&#34;垂直居中:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;垂直居中&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&#34;http://jiangshanmeta.github.io/post/center/&#34;&gt;我的总结&amp;ndash;居中的实现&lt;/a&gt;中提到到过，利用的是&lt;code&gt;vertical-align:middle&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;等分布局-多列布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等分布局/多列布局&lt;/h4&gt;

&lt;p&gt;这两类基本布局我更习惯用浮动实现，对于&lt;code&gt;table&lt;/code&gt;实现没有什么特别大的爱好，等分布局需要&lt;code&gt;table-layout:fixed;&lt;/code&gt;这一属性。&lt;/p&gt;

&lt;h4 id=&#34;等高布局:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;等高布局&lt;/h4&gt;

&lt;p&gt;如果不用table，实现等高布局的最简单方式应该是&lt;code&gt;flex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还是直接上&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/table/tabletip.html&#34;&gt;demo&lt;/a&gt;吧，我这里实现了图文混排下的等高。&lt;/p&gt;

&lt;h4 id=&#34;sticky-footer:9fb6e0094eeac5ea481f3c3b33e3088c&#34;&gt;sticky footer&lt;/h4&gt;

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/stickyfooter/&#34;&gt;总结过sticky footer的实现&lt;/a&gt;,以及&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/08/12&lt;/p&gt;

&lt;p&gt;说一个实际用到的场景吧，我们的前端框架是bootstrap，它的栅格系统是实现多列布局的常用工具，我以前&lt;a href=&#34;http://jiangshanmeta.github.io/post/bootstrap/grid/&#34;&gt;讲过它的具体实现&lt;/a&gt;，简单地说是基于浮动布局的。用栅格系统做展示列表的时候，如果每一列的高度不一致（毕竟指望各列图片文字高度一致属于别想了），熟悉浮动的同学应该能脑补出来会出现什么样的悲剧，那我最终的解决方案是使用表格中同一行中单元格等高这一属性解决问题的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——栅格系统</title>
      <link>http://jiangshanmeta.github.io/post/bootstrap/grid/</link>
      <pubDate>Sat, 25 Jun 2016 19:23:09 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/bootstrap/grid/</guid>
      <description>

&lt;p&gt;bootstrap的CSS部分中最出名的应该就是栅格系统了，它解决了网页中常见的多列布局问题。对应的实现其实并不是特别复杂，主要包括以下知识点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;盒模型&lt;/li&gt;
&lt;li&gt;浮动&lt;/li&gt;
&lt;li&gt;相对定位&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;基本概念:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;栅格系统的行（row）必须包裹在&lt;code&gt;.container&lt;/code&gt;或者&lt;code&gt;container-fluid&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}
@media (min-width: 768px) {
  .container {
    width: 750px;
  }
}
@media (min-width: 992px) {
  .container {
    width: 970px;
  }
}
@media (min-width: 1200px) {
  .container {
    width: 1170px;
  }
}
.container-fluid {
  padding-right: 15px;
  padding-left: 15px;
  margin-right: auto;
  margin-left: auto;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中看出bootstrap中移动优先的理念，默认的都是小屏下的样式，再逐步通过媒体查询实现大屏下的样式。&lt;code&gt;container&lt;/code&gt;和&lt;code&gt;container-fluid&lt;/code&gt;在小屏下的行为是一致的，但是在pad屏或者更大的屏幕下，前者表现为有固定宽度居中显示，而后者一直保持宽度100%，虽然我很好奇后者为什么要添加上&lt;code&gt;margin-left:auto;margin-right:auto;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而列的样式比较有趣&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.row {
  margin-right: -15px;
  margin-left: -15px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;row要包含在container中，container包含了15px的左右padding，row却用左右各-15px的margin撑了出去，抵消了container的padding，写这个框架的人在想什么？问题的答案在于列的样式以及列嵌套。在列的通用样式里，有这样的设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;padding-right: 15px;
padding-left: 15px;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想要实现列嵌套，例如如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-sm-9&amp;quot;&amp;gt;
    Level 1: .col-sm-9
    &amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;col-xs-8 col-sm-6&amp;quot;&amp;gt;
        Level 2: .col-xs-8 .col-sm-6
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;col-xs-4 col-sm-6&amp;quot;&amp;gt;
        Level 2: .col-xs-4 .col-sm-6
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要内层的row抵消掉外层的col的padding。&lt;/p&gt;

&lt;h2 id=&#34;盒模型部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;盒模型部分&lt;/h2&gt;

&lt;p&gt;默认情况下box-sizing为content-box，bootstrap上来就重置了盒模型为border-box。为什么要这么做呢？因为栅格系统的每一列的宽度都是根据百分比计算得到的，如果使用默认的content-box，如果有的列加上border或者padding，布局直接会乱掉。基本上等分布局的实现离不开这一设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* {
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;浮动部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;浮动部分&lt;/h2&gt;

&lt;p&gt;如果让你实现多列布局，你想怎么办？最容易想到的就是浮动啊。bootstrap确实是使用浮动实现多列布局的。&lt;/p&gt;

&lt;p&gt;部分代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {
  float: left;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然使用了浮动，那么就免不了要处理浮动带来的盒子塌陷问题。具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container:after,
.container-fluid:after,
.row:after{
  display: table;
  content: &amp;quot; &amp;quot;;
  clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的时候我们需要对列进行偏移，bootstrap提供了&lt;code&gt;col-*-offset-*&lt;/code&gt;一系列类，实现原理是通过margin-left。&lt;/p&gt;

&lt;h2 id=&#34;相对定位部分:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;相对定位部分&lt;/h2&gt;

&lt;p&gt;一开始读bootstrap 源码的时候，发现列的公共样式里面有这么一条：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position: relative;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说相对定位是和绝对定位结合使用的，这里有没有绝对定位是干什么的呢？当我读到关于列顺序的代码的时候我就明白了。&lt;/p&gt;

&lt;p&gt;相对定位的元素，如果是使用top left right bottom ，其定位是相对于原来的位置进行定位。举个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.col-xs-push-6 {
  left: 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用此类后col相对于原来的位置向右偏移了50%。看起来是在模拟flex布局的order。然而我真的没在生产环境里用过，真的没有。&lt;/p&gt;

&lt;h2 id=&#34;响应式布局:53f7ea7618082d6b557ccddb7ec1053e&#34;&gt;响应式布局&lt;/h2&gt;

&lt;p&gt;作为一个前端框架，bootstrap显然要处理不同屏幕下的显示问题，所以使用了响应式布局。处于移动优先这一概念的考虑，bootstrap默认设施都是在手机小屏下，然后通过媒体查询实现其他较大屏幕的样式设置。当浏览器宽度超过了分界点，如果没有设置此区间的新样式，按照更小屏幕的样式显示。&lt;/p&gt;

&lt;p&gt;其实对于手机端来说，bootstrap一方面可能太重了，另一方面响应式布局也不见得是万能的。这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;对于bootstrap的css，目前觉得也就是它的栅格系统有必要说一下，其他的再说吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何将页脚固定在页面底部</title>
      <link>http://jiangshanmeta.github.io/post/stickyfooter/</link>
      <pubDate>Fri, 24 Jun 2016 20:05:51 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/stickyfooter/</guid>
      <description>

&lt;p&gt;在一个网页中通常会有页脚的设置。如果页面内容较少，看起来页脚就像是浮了起来，在浏览器的下面还有一块白色，显得非常难看。我不会告诉你我最近看到的新鲜的页面里还有这种问题，都是同行，给人个面子，不给链接了。那么如何解决这一问题呢？&lt;/p&gt;

&lt;h2 id=&#34;javascript方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;javascript方案&lt;/h2&gt;

&lt;p&gt;不难，请自行百度。然而我总是想能用css解决的绝对不用js。先约定一下页面结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
	&amp;lt;header id=&amp;quot;header&amp;quot;&amp;gt;

	&amp;lt;/header &amp;gt;
	&amp;lt;main id=&amp;quot;header&amp;quot;&amp;gt;

	&amp;lt;/main&amp;gt;
	&amp;lt;footer id=&amp;quot;footer&amp;quot;&amp;gt;

	&amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公共的样式设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{
	margin:0;
	padding:0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;table方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;table方案&lt;/h2&gt;

&lt;p&gt;这里所说的table并不是说html table，而是css table。在css的display属性中，有一堆关于table的值，比如&lt;code&gt;table&lt;/code&gt;,&lt;code&gt;table-row&lt;/code&gt;,&lt;code&gt;table-cell&lt;/code&gt;。这些值可以帮助我们像表格一样布局而不使用html table。这里用到的是&lt;code&gt;table&lt;/code&gt;和&lt;code&gt;table-row&lt;/code&gt;两个值。&lt;/p&gt;

&lt;p&gt;我们可以把整个body视为一个table，然后header、main、footer三部分视为table-row。并且让main占据100%高度。可能你觉得很奇怪如果main高度设为100%，那么header和footer的高度岂不是零了？但是table有许多神奇的特性，header和footer会正常显示。这里的header和footer的高度会变成恰能放下内容的高度，main占据剩余空间。因为table的话无论是宽度还是高度计算都比较复杂，web开发者所设置的width或者height都是参考值。&lt;/p&gt;

&lt;p&gt;这样你会发现依然没有实现固定在底部。因为body的高度现在是由内容决定的，我们要设置body的最小高度设为视口高度。可以采用100vh这么一个方案，如果担心兼容性问题，可以把高度设为百分比。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body{
	display:table;
	width:100%;
	min-height:100vh;
}
#main{
	display:table-row;
	height:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在线demo：&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/table.html&#34;&gt;固定在底部的页脚——table方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flex方案:57c3c18f56fe86510d201aa293fed882&#34;&gt;flex方案&lt;/h2&gt;

&lt;p&gt;flex作为布局神器，基本上你想到的用flex都能做。这里所需要的是两个属性&lt;code&gt;flex-direction&lt;/code&gt;和&lt;code&gt;flex-grow&lt;/code&gt;。我们需要把body作为 flex盒子，并把flex盒子方向设为column，把我们的主体内容的扩展属性设为1，header和footer不扩展，这样就会让主体内容自动填充空余部分。&lt;/p&gt;

&lt;p&gt;代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body{
	display:flex;
	flex-direction:column;
	min-height:100vh;
}
#main{
	flex-grow:1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在线demo：&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/stickyfooter/flex.html&#34;&gt;固定在底部的页脚——flex方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结:57c3c18f56fe86510d201aa293fed882&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于如何实现固定在底部的页脚，其实也有许多方案，但是有各种各样的问题，比如footer的高度必须是固定的。我上面所说的两种纯CSS方案都不需要固定footer的高度，基本上可以直接拿到生产环境里用。另外，关于css table的使用自己还需要多多学习，希望近期能够写篇总结。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于CSS3 transition 的几个小tip</title>
      <link>http://jiangshanmeta.github.io/post/transitiontip/</link>
      <pubDate>Tue, 21 Jun 2016 20:19:53 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/transitiontip/</guid>
      <description>

&lt;p&gt;关于CSS3的transition一般写过一阵的基本玩法也都会了，这里收集一些transition的小细节&lt;/p&gt;

&lt;h2 id=&#34;关于伪元素的过渡:fe079bb6a643aa02f488f646a5d5f38e&#34;&gt;关于伪元素的过渡&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/pseudo/&#34;&gt;之前总结过伪元素的一些应用&lt;/a&gt;，但是没有提及如何使用伪元素进行过渡。
直接修改伪元素的属性或者给伪元素添加类名都是很折腾的。常见的改变伪元素的方案是给其父元素添加类名或者利用父元素的伪类。提到伪类，那么能否直接对伪元素本身应用伪类？比如:hover，希望伪元素hover的时候状态改变。然而尝试的结果是否定的。目前对其父元素添加类名或者伪类是对伪元素应用过渡的最简单可行的方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/transitiontip/pseudo.html&#34;&gt;在线demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;模拟input宽度的改变:fe079bb6a643aa02f488f646a5d5f38e&#34;&gt;模拟input宽度的改变&lt;/h2&gt;

&lt;p&gt;如果想利用硬件加速，避免重绘，我们一般要避免width、height、margin之类的属性过渡。然而，有的时候我们确实需要宽度变化的过渡，比如输入框在获取焦点的时候变长，失去焦点后宽度又恢复原状。&lt;a href=&#34;http://t.imooc.com/learn/42&#34;&gt;慕课网一个美化表单案例&lt;/a&gt;就提到了这么一种需求。想实现这一需求可以使用width、padding属性的过渡实现，但是免不了大量的重绘，从前端性能优化的角度来看实现地并不优雅。&lt;/p&gt;

&lt;p&gt;其实换一种思路，我们不见得让输入框真的变长，只要是输入框看起来变长了就行，毕竟我们的目的是加一个动画效果提升用户体验。于是就有了这么一个障眼法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;clipped&amp;quot; &amp;gt;
	&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
	&amp;lt;div class=&amp;quot;clip&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.clipped{
	position:relative;
	width:154px;
}
.clipped .clip{
	position:absolute;
	right:0;
	top:0;
	width:50px;
	height:25px;
	border:2px solid #ccc;
	border-left:0;
	border-radius:4px;
	/*pointer-events:none;*/
	z-index:-1;
	transition:0.4s linear;
}
.clipped input{
	width:150px;
	height:25px;
	border:2px solid #ccc;
	border-radius:4px;
	border-right:0px;
	
}
.clipped input:focus{
	outline:none;
	
}
.clipped input:focus ~.clip{
	transform:translate3d(40px,0,0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/transitiontip/clipping.html&#34;&gt;在线demo&lt;/a&gt;
基本原理是一个绝对定位的div，定位到输入框的右边，模拟输入框右边的样子，input框获得焦点的时候把这个div transform。具体的看代码。如果可以的话想用伪元素实现这个div，然而input并不支持伪元素。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解贝塞尔曲线之如何实现匀加/减速动画</title>
      <link>http://jiangshanmeta.github.io/post/cubicbezier/</link>
      <pubDate>Tue, 14 Jun 2016 19:24:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/cubicbezier/</guid>
      <description>

&lt;p&gt;如果要实现web动画，通常有三个方式，第一是使用gif图，第二是使用CSS3中的transition和animation，第三是使用javascript。gif图一般交给美术去制作，不需要coding，js实现web动画是一个比较成熟的方案了，它的特点是兼容性好，能控制的动画效果多，适合制作复杂的动画效果。随着CSS3的浏览器支持程度越来越高，使用CSS3写web动画也成为一个流行的方式。&lt;/p&gt;

&lt;p&gt;为了控制动画进行过程，CSS3为我们提供了缓动函数，分别为transition-timing-function和animition-timing-function (以下统称timing-function),通常用的是几个关键字属性：linear、ease、ease-in、ease-out、ease-in-out。&lt;/p&gt;

&lt;p&gt;linear是线性动画；ease是默认的动画效果，特点是先快后慢，时间50%的时候已经完成80%的动画效果了；ease-in是动画进行过程中一直加速；ease-out是动画进行过程中一直减速；ease-in-out和ease很相似，都是先加速后减速，但是时间50%的时候完成动画的50%；一般来说，如果没太大的追求这些关键字就足够了。有这种想法的可以直接点击右上角的那个X了。&lt;/p&gt;

&lt;p&gt;稍微高级一点的玩法是使用cubic-bezier,通过指定贝塞尔曲线的两个控制点控制缓动函数。其实三次贝塞尔曲线有四个控制点，然而对于CSS来说第一个控制点是(0,0)，第四个控制点是(1,1)，所以留给我们操作的只有两个控制点了。而且这两个控制点也是有限制的，横坐标∈[0,1]，纵坐标可以大于1。上面几个关键字其实是预定义好的贝塞尔曲线。&lt;/p&gt;

&lt;p&gt;这个贝塞尔曲线就是我们今天的主角。原始需求是：实现匀加/减速动画。最一开始的想法是使用js控制，好像也没什么难度，会高中物理的就能解决。后来我就想能不能用CSS实现这一效果，毕竟我的一个原则是能用CSS实现的绝对不用js。&lt;/p&gt;

&lt;p&gt;先上图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/beziercurve.jpg&#34; alt=&#34;贝塞尔曲线的物理含义&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用这张图说明一下对应的物理含义。横轴是时间进度，纵轴是动画进度。有高中物理水平的就能看得出来这不就是 *路程-时间曲线*嘛。所以曲线一阶导数的物理含义就是速度，二阶导数的物理含义就是加速度。想要实现匀加/减速动画，只要使二阶导数是一个不为零的常数就好了。&lt;/p&gt;

&lt;h4 id=&#34;前方高能预警-大量数学出没-请做好战斗准备:eec53d87b272616feb247dfa262869de&#34;&gt;前方高能预警，大量数学出没，请做好战斗准备&lt;/h4&gt;

&lt;p&gt;三次贝塞尔曲线公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/cubicbezier.jpg&#34; alt=&#34;三次贝塞尔曲线公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于CSS的限制 P0为(0,0)，P3为(1,1)将其带入方程并展开，可以得到对x,y方向的两个方程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation1.jpg&#34; alt=&#34;x,y方向的两个方程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们得到的是两个参数方程。要想得到y对x的二阶导数，需要下面的公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/derivative.jpg&#34; alt=&#34;参数方程二阶导数公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看不懂过程就不要在乎这些细节了，公式推导里有一步我应该曾经明白但我现在不明白。直接看结论，我们需要两个参数方程对t的一阶导数和二阶导数&lt;/p&gt;

&lt;p&gt;于是便有了下面的几个式子&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation2.jpg&#34; alt=&#34;一阶导数和二阶导数&#34; /&gt;&lt;/p&gt;

&lt;p&gt;带入不明觉厉的公式，我们可以观察到，分母最高次项是六次，而分子最高次项是三次，要使结果为一个常数，六次项的系数要为零&lt;/p&gt;

&lt;p&gt;于是我们得到了第一个公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation3.jpg&#34; alt=&#34;第一个公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;将第一个公式带入二阶导数中，我们会发现分母最高次项为3，分子最高此项为2，和上面类似的思路，我们可以得到第二个公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation4.jpg&#34; alt=&#34;第二个公式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两个方程联立我们可以解得&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation5.jpg&#34; alt=&#34;第一个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样分母就是一个常数了，分子还有一个一次项，所以&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation6.jpg&#34; alt=&#34;第二个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/equation7.jpg&#34; alt=&#34;第三个结论&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意到&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/webanimation/conclusion.jpg&#34; alt=&#34;第四个结论&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解CSS3中width新的几个关键字成员</title>
      <link>http://jiangshanmeta.github.io/post/css3width/</link>
      <pubDate>Mon, 30 May 2016 21:39:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/css3width/</guid>
      <description>

&lt;p&gt;最近看了&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/&#34;&gt;张鑫旭大神的一片文章&lt;/a&gt;,介绍了&lt;code&gt;width&lt;/code&gt;属性的几个关键字成员：&lt;code&gt;fill-available&lt;/code&gt;、&lt;code&gt;max-content&lt;/code&gt;、&lt;code&gt;min-content&lt;/code&gt;、&lt;code&gt;fit-content&lt;/code&gt;。如果有不熟悉基本概念的链接都有了自己点过去看。他的那篇文章偏重于概念介绍，我想介绍一些细节以及应用&lt;/p&gt;

&lt;h2 id=&#34;fill-available:3de20cc74c1f43aee615802a184084e5&#34;&gt;fill-available&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.fill-available{
	width:fill-available;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个关键字使得盒子尽可能填充满剩余空间，听起来很像是&lt;code&gt;width:100%;&lt;/code&gt;。那么直接用&lt;code&gt;width:100%;&lt;/code&gt;行吗,至少没有兼容问题啊？&lt;/p&gt;

&lt;p&gt;其实是分情况的。如果对这个盒子设置了&lt;code&gt;box-sizing:border-box&lt;/code&gt;,那真的无所谓，用什么都行。但是默认的&lt;code&gt;box-sizing&lt;/code&gt;是*content-box*在这种情况下如果有margin padding border的，此时使用&lt;code&gt;width:100%&lt;/code&gt;就会面临超出父盒子的问题，但是&lt;code&gt;width:fill-available&lt;/code&gt;就没有这个问题。&lt;/p&gt;

&lt;p&gt;//像我们这种基于bootstrap改改用的，已经有了&lt;code&gt;*{box-sizing:border-box;}&lt;/code&gt;，所以好像没什么用。&lt;/p&gt;

&lt;h2 id=&#34;max-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;max-content&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;max-content的行为表现可以这么理解，假设我们的容器有足够的宽度，足够的空间，此时，所占据的宽度是就是max-content所表示的尺寸。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说实话至今我没想起来这个能用来干什么。如果内容很长，会出现横向滚动条，对于web横向滚动条并不是什么好的设计。如果内容并不多，它的表现和下面的fit-content是一致的。真·找不到应用场景。&lt;/p&gt;

&lt;h2 id=&#34;min-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;min-content&lt;/h2&gt;

&lt;p&gt;这个就比较有意思了，我们可以用来自适应内部元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;&amp;quot; class=&amp;quot;responsive-wrap&amp;quot;&amp;gt;
	&amp;lt;img src=&amp;quot;http://jiangshanmeta.github.io/demo/myWork/csssecrets/2.jpg&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以往常见的图片展示效果是规定外层div的大小，然后图片大小跟着外层div来。bootstrap里的一个实现是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;img-responsive{
	display: block;
	max-width: 100%;
	height: auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我偏要父元素的宽度跟着子元素走，以往我可能会这么做：给外层div加个&lt;code&gt;display:table;&lt;/code&gt;利用其尺寸收缩的特性。有点hack的味道在这里。而且这么做健壮性不够，如果我想给图片下面加上几行描述，尤其是字数要长长长，这时候&lt;code&gt;display:table;&lt;/code&gt;的效果，&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/css3width/table.html&#34;&gt;点开自己看&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果把div的width设为min-content,就能在长描述的存在下，依然做到父元素大小跟着图片大小走。结果请点击上面链接&lt;/p&gt;

&lt;h2 id=&#34;fit-content:3de20cc74c1f43aee615802a184084e5&#34;&gt;fit-content&lt;/h2&gt;

&lt;p&gt;这个属性的性质和上面说的&lt;code&gt;display:table;&lt;/code&gt;最终表现可以说一模一样。我没找到区别。&lt;/p&gt;

&lt;h2 id=&#34;结束语:3de20cc74c1f43aee615802a184084e5&#34;&gt;结束语&lt;/h2&gt;

&lt;p&gt;好像也就min-content用处多点，其他的我还在想能做什么特别而且能用到的事情&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>结构与样式相分离之CSS图形</title>
      <link>http://jiangshanmeta.github.io/post/cssshape/</link>
      <pubDate>Sun, 29 May 2016 18:19:27 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/cssshape/</guid>
      <description>&lt;p&gt;做前端的应该都听说过“结构与样式相分离”这一句话。最简单的理解是HTML负责结构，CSS负责样式。然而，自己在实际项目中并没有很好地应用这句话，经常为了实现某个特殊样式加上一堆div。&lt;/p&gt;

&lt;p&gt;比如说之前实现的一个效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/cssshape1.png&#34; alt=&#34;彩色的边框&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当时实现这个效果的基本思路是用border画出外面的环，由于角度问题，所以还要加上一个transform转45deg，这样边框就画出来了，但是内部的人物头像也随着父元素，所以也要加上一个transform抵消父元素转动的影响。&lt;/p&gt;

&lt;p&gt;这样虽然实现了，但是总感觉不够优雅，加的额外的HTML和CSS略多，而仅仅是为了实现一个环。&lt;/p&gt;

&lt;p&gt;再次安利一下我最近看的书&lt;strong&gt;CSS Secrets&lt;/strong&gt;，这本书还没看完，但是给我不少启发。之前写过一篇&lt;a href=&#34;http://jiangshanmeta.github.io/post/pseudo/&#34;&gt;小的总结&lt;/a&gt;，谈到了伪元素的一些应用。我想，用伪元素做一些装饰性的工作，可以减少冗余的div和CSS，增强重用性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div class=&amp;quot;img-outer-circle&amp;quot;&amp;gt;
	&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.img-outer-circle{
	position:relative;
	width:135px;
	height:135px;
}
.img-outer-circle::before{
	content:&#39;&#39;;
	position:absolute;
	top:-10px;
	left:-10px;
	right:-10px;
	bottom:-10px;
	border-radius:50%;
	border-width:5px;
	border-style:solid;
	border-color:#3d8ceb #3d8ceb #f1cb2f #f1cb2f ;
	-webkit-transform:rotate(-45deg);
	transform:rotate(-45deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，HTML还是以前的，因为像是&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;这样的自闭合标签没有伪元素这一说法，不能直接加在图片上。CSS上实现边框的思路还是和以前一样，但是因为不是对整个div进行transform，所以不用对图片再进行处理了。目前看不出来什么特别的优势。但是试想如果来了需求，说要给图片加个出场动画，如果用animation实现的话，免不了各种transform，transform各种影响，免不了出些奇奇怪怪的bug。//不要问我怎么知道的&lt;/p&gt;

&lt;p&gt;这里提一句，本来是想用&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;的伪元素写一个边框的，但是没能实现，上面的理由说的太简单了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/21296044&#34;&gt;知乎上有个相关问题&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-&amp;lt;img&amp;gt;```也不是完全不能应用伪元素，比如[利用伪元素美化加载失败的图片](http://web.jobbole.com/86079/)&#34;&gt;

伪元素能做的装饰性的东西其实很多，上面是伪元素结合border做了一个彩色的边框，其实还可以做一些三角形、菱形、梯形之类的。三角形和菱形就不说了，简单说一下梯形。

在**CSS Secrets**这本书中，作者采用的方法伪元素+transform3d，伪元素的方案我是赞同的，但是transform3d一方面有些兼容性问题，另一方面3d效果理解起来比较困难，尤其是结合transform-origin的3d效果。于是，我决定用border一条路走到黑。

因为border经常用来实现各种图形，我[结合Vue实现了一个查看border能做什么的demo](http://jiangshanmeta.github.io/demo/myWork/org/vue/v_box.html)，想象力再丰富也比不上直接拖拖拽拽看效果来的快。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.tab{
    position:relative;
    display:inline-block;
    padding-right:8px;
    padding-left:8px;
    margin-right:25px;
    text-align:center;
}&lt;/p&gt;

&lt;p&gt;.tab::before{
    z-index:-1;
    content:&amp;ldquo;;
    position:absolute;
    top:0;
    left:-10px;
    right:-10px;
    bottom:0;
    width:100%;
    height:0;
    border-style:solid;
    border-width:0 10px 18px 10px;
    border-color:transparent transparent yellowgreen transparent;
}
```&lt;/p&gt;

&lt;p&gt;这样也可以实现梯形标签。其实如果浏览器支持嵌套伪元素这个问题就更好解决了。不知道那时候那群玩one div的会搞出什么来。&lt;/p&gt;

&lt;p&gt;先写到这里吧，以后在实践中如果有用到的再补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>居中的常见实现</title>
      <link>http://jiangshanmeta.github.io/post/center/</link>
      <pubDate>Mon, 16 May 2016 21:26:45 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/center/</guid>
      <description>

&lt;p&gt;约定HTML结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;lt;div &amp;gt;
	&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-水平居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;1.水平居中&lt;/h2&gt;

&lt;p&gt;实现水平居中其实并不难，而且有多个可靠地方案可以使用。&lt;/p&gt;

&lt;h4 id=&#34;margin方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;margin方案&lt;/h4&gt;

&lt;p&gt;用过bootstrap的人会很熟悉这么一个类名&lt;code&gt;.center-block&lt;/code&gt;，这是实现居中的一个类名，具体实现是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-block{
	display:block;
	margin-left:auto;
	margin-right:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这应该是学习页面布局最基本的水平居中方案了，也没什么额外操作&lt;/p&gt;

&lt;h4 id=&#34;绝对定位方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;p&gt;基本实现是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-x-ab{
	position:absolute;
	left:50%;
	transform:translateX(-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是应用了translate如果值为百分比，则参考于自身。如果为了水平居中而这么做就有点折腾了，然而这一方案可以扩展到垂直居中和水平垂直都居中。这样做的缺点是父元素需要处理子元素绝对定位带来的问题。在实践中，制作h5页面慎用这种方法居中，因为h5页面经常有动画，动画离不开transform,两者同时存在会看到很诡异的问题。&lt;/p&gt;

&lt;h4 id=&#34;文本居中方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;文本居中方案&lt;/h4&gt;

&lt;p&gt;需要将要居中元素的父元素设定&lt;code&gt;text-align:center;&lt;/code&gt;需要居中的元素的display要设定为&lt;code&gt;inline-block&lt;/code&gt;,需要处理文本居中带来的影响，这一方案感觉用的不多。&lt;/p&gt;

&lt;h4 id=&#34;flex方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;1.你为什么不用margin方案的方案&lt;/p&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex&lt;/code&gt; 子元素img&lt;code&gt;margin-left:auto;margin-right:auto;&lt;/code&gt;我的评价见小标题&lt;/p&gt;

&lt;p&gt;2.感觉有点大材小用的方案&lt;/p&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex:justify-content:center;&lt;/code&gt;评价如小标题
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/animation/animation_spin.html&#34;&gt;上个例子&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-垂直居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;2.垂直居中&lt;/h2&gt;

&lt;p&gt;相较于水平居中，垂直居中相比较而言就有点难度了&lt;/p&gt;

&lt;h4 id=&#34;单行文字垂直居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;单行文字垂直居中&lt;/h4&gt;

&lt;p&gt;在我刚开始学习写页面的时候，就听说过让&lt;strong&gt;line-height&lt;/strong&gt;和&lt;strong&gt;height&lt;/strong&gt;值相等即可使单行文字垂直居中，最开始只是从使用的角度看这个问题，没有深入思考过，后来&lt;a href=&#34;http://t.imooc.com/learn/403&#34;&gt;张鑫旭大神告诉我们&lt;/a&gt;，这只是伪垂直居中。从工程实践角度这已经够用了，不要在意这些细节&lt;/p&gt;

&lt;h4 id=&#34;绝对定位方案-1:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;p&gt;在水平居中中提到可以使用绝对定位实现水平居中，同样也可以使用绝对定位实现垂直居中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.center-y-ab{
	position:absolute;
	left:50%;
	transform:translateY(-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然要处理绝对定位带来的后果，考虑到垂直居中方案并不多，这不失为一个好方案。&lt;/p&gt;

&lt;h4 id=&#34;table方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;table方案&lt;/h4&gt;

&lt;p&gt;请参阅&lt;a href=&#34;https://css-tricks.com/centering-in-the-unknown/&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;flex方案-1:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;父元素div &lt;code&gt;display:flex&lt;/code&gt; 子元素img&lt;code&gt;margin-top:auto;margin-right:bottom;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然你也可以折腾flex的相关属性去，说的就是某些关于对其的属性。&lt;/p&gt;

&lt;h2 id=&#34;3-水平垂直都居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;3.水平垂直都居中&lt;/h2&gt;

&lt;h4 id=&#34;绝对定位方案-2:903435e3d66e261bf87738ad6f965a5c&#34;&gt;绝对定位方案&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.center-xy-ab{
	position:absolute;
	top:50%;
	left:50%;
	transform:translate(-50%,-50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有代码有真相，就是结合水平、垂直居中的绝对定位方案&lt;/p&gt;

&lt;h4 id=&#34;flex方案-2:903435e3d66e261bf87738ad6f965a5c&#34;&gt;flex方案&lt;/h4&gt;

&lt;p&gt;父元素&lt;code&gt;display:flex;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;子元素&lt;code&gt;margin:auto;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也不用去折腾各种对齐的属性&lt;/p&gt;

&lt;h4 id=&#34;水平文本居中-垂直table-的大杂烩:903435e3d66e261bf87738ad6f965a5c&#34;&gt;水平文本居中 + 垂直table 的大杂烩&lt;/h4&gt;

&lt;p&gt;如果真考虑兼容性的话，这似乎是兼容性最好的方案了
然而，需要多写一层标签&lt;/p&gt;

&lt;p&gt;水平垂直居中算是水平居中和垂直居中的综合使用，上个&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/center.html&#34;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-基于视口的居中:903435e3d66e261bf87738ad6f965a5c&#34;&gt;4.基于视口的居中&lt;/h2&gt;

&lt;p&gt;常见的各种模态框基本上是相较于视口水平垂直居中的，其实我最早知道模态框的实现的时候它的居中是通过js计算得到的。作为 &lt;em&gt;能用CSS实现的就绝对不用js实现&lt;/em&gt; 神教教徒，这个需求肯定要尝试使用CSS解决。&lt;/p&gt;

&lt;h4 id=&#34;transform方案:903435e3d66e261bf87738ad6f965a5c&#34;&gt;transform方案&lt;/h4&gt;

&lt;p&gt;基本上是上边的绝对定位方案的翻版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;position:fixed;
top:50%;
left:50%;
transform:translate(-50%,-50%);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相关&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/center/center.css&#34;&gt;CSS下载&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>伪元素的应用总结</title>
      <link>http://jiangshanmeta.github.io/post/pseudo/</link>
      <pubDate>Mon, 16 May 2016 20:00:31 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/pseudo/</guid>
      <description>

&lt;dl&gt;
&lt;dt&gt;CSS中的伪元素CSS中经常能玩出花样的东西，它包括::first-letter、::first-line、::before、::after、::selection,作为强迫症晚期患者我觉得还应该出现::last-letter和::last-line，然而并没有，我很伤心。&lt;/dt&gt;
&lt;/dl&gt;

&lt;p&gt;::first-letter、::first-line、::selection通常是用来对文字进行装饰，比如::first-letter实现首字母下沉效果,::selection实现萌娘百科的黑幕效果，目前我还没发现这三个能玩出太大的花样。这里主要总结::before和::after两个伪元素的花样。一直在纠结如何整理这些东西，最后还是决定按照表现分类，毕竟CSS关系的是样式。&lt;/p&gt;

&lt;h2 id=&#34;clearfix:dc5e44b284002f2c33b84936afab53a1&#34;&gt;clearfix&lt;/h2&gt;

&lt;p&gt;写过几个网页的人就会知道clearfix，毕竟是布局相关的东西，实现起来有不少，经典的是&lt;code&gt;.clearfix::after{content:&#39;&#39;;display:table;clear:both;}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;字体图标:dc5e44b284002f2c33b84936afab53a1&#34;&gt;字体图标&lt;/h2&gt;

&lt;p&gt;网页上的小图标是很常见的设计，通常的实现方案有图片和字体图标两种，作为并不喜欢切图的我显然更倾向于使用字体图标这种方式。目前用过的字体图标有&lt;a href=&#34;http://v3.bootcss.com/components/#glyphicons-glyphs&#34;&gt;bootstrap&lt;/a&gt;里面自带的，还有&lt;a href=&#34;http://fontawesome.dashgame.com/&#34;&gt;font-awesome&lt;/a&gt;两个，基本能满足需求，如果不能满足请说服美术。&lt;/p&gt;

&lt;h2 id=&#34;一条线:dc5e44b284002f2c33b84936afab53a1&#34;&gt;一条线&lt;/h2&gt;

&lt;p&gt;为了一条线写一个标签通常来说是很不划算的，除非你很爱敲键盘。
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/cateList/cateList.html&#34;&gt;我之前写的一个分类列表&lt;/a&gt;这里结合使用了:checked伪类和::after伪元素，实现了无JS的tab切换效果。&lt;/p&gt;

&lt;p&gt;之前也见过在tab切换中，使用::after伪元素画一条线表示当前tab的。&lt;/p&gt;

&lt;p&gt;在bootstrap里的面包屑导航里，也采用了::before伪元素做一条分割线。&lt;/p&gt;

&lt;p&gt;还有见过走马灯效果里，用::after做分割的。然而最近没怎么见过走马灯效果了，这个设计目测已经过气了。&lt;/p&gt;

&lt;h2 id=&#34;背景图形:dc5e44b284002f2c33b84936afab53a1&#34;&gt;背景图形&lt;/h2&gt;

&lt;h4 id=&#34;模拟多背景-实现多重边框:dc5e44b284002f2c33b84936afab53a1&#34;&gt;模拟多背景、实现多重边框&lt;/h4&gt;

&lt;p&gt;在多背景支持性还不够好的时候，就有人试图用&lt;a href=&#34;http://nicolasgallagher.com/multiple-backgrounds-and-borders-with-css2/&#34;&gt;::before和::after来实现多背景&lt;/a&gt;。这项技术其实已经有点老了，然而其中提到的&lt;strong&gt;用伪元素实现多边框&lt;/strong&gt;依然具有实战意义。&lt;/p&gt;

&lt;h4 id=&#34;阴影效果:dc5e44b284002f2c33b84936afab53a1&#34;&gt;阴影效果&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://t.imooc.com/learn/240&#34;&gt;CSS3实现“图片阴影”效果&lt;/a&gt;,给慕课网打个广告吧。如果对阴影效果扩展一下，就可以模拟弹出层的背景。&lt;/p&gt;

&lt;h4 id=&#34;边框内圆角:dc5e44b284002f2c33b84936afab53a1&#34;&gt;边框内圆角&lt;/h4&gt;

&lt;p&gt;这一效果是在*CSS Secrets*一书中看到的，基本原理是border-radius+定位+z-index。&lt;/p&gt;

&lt;h4 id=&#34;各种图形:dc5e44b284002f2c33b84936afab53a1&#34;&gt;各种图形&lt;/h4&gt;

&lt;p&gt;之前的日志中，我利用::before实现了&lt;a href=&#34;http://jiangshanmeta.github.io/post/autosquare/&#34;&gt;自适应的正方形&lt;/a&gt;,同时这一原理也可以用来实现长宽比一定的矩形。&lt;/p&gt;

&lt;p&gt;伪元素实现三角形早就成为前端的必备技能了，不细说了。&lt;/p&gt;

&lt;p&gt;在三角形的基础上也能实现其他的图形，&lt;em&gt;CSS Secrets&lt;/em&gt; 一书中提到了如何使用伪元素实现平行四边形和菱形，主要利用了transform+绝对定位。&lt;/p&gt;

&lt;p&gt;更多的图形可以参见 &lt;a href=&#34;https://css-tricks.com/examples/ShapesOfCSS/&#34;&gt;css tricks&lt;/a&gt;,然而我觉得很多只是做着玩而不能在生产环境下使用。&lt;/p&gt;

&lt;h4 id=&#34;结合filter实现毛玻璃效果:dc5e44b284002f2c33b84936afab53a1&#34;&gt;结合filter实现毛玻璃效果&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://dabblet.com/gist/d9f243ddd7dbffa341a4&#34;&gt;局部毛玻璃模糊效果的实现&lt;/a&gt;，从&lt;strong&gt;CSS Secrets&lt;/strong&gt;中看到的&lt;/p&gt;

&lt;h2 id=&#34;扩大响应区域:dc5e44b284002f2c33b84936afab53a1&#34;&gt;扩大响应区域&lt;/h2&gt;

&lt;p&gt;其实这也不算是样式了，已经是交互部分了。伪元素结合定位就可以扩展原来元素的相应区域，结合:hover伪类应该能做出一些东西，目前没见过眼前一亮的例子&lt;/p&gt;

&lt;h2 id=&#34;模拟float-center:dc5e44b284002f2c33b84936afab53a1&#34;&gt;模拟float:center&lt;/h2&gt;

&lt;p&gt;浮动其实是没有center这一值的，但是一个居中的文字环绕效果确实挺漂亮。别人的&lt;a href=&#34;https://css-tricks.com/float-center/&#34;&gt;demo&lt;/a&gt;,使用具有一定宽度和高度的伪元素浮动占据位置，再用绝对定位把图片定位到伪元素占据的地方。这个效果我觉得很有创意。&lt;/p&gt;

&lt;p&gt;伪元素能做的东西很多，然而自己接触的还比较少，上面所说的就是我目前所见到的。其实结合:hover伪类，:checked伪类，以及transition和animation，是可以做一些小东西出来的，至少可以取代一些用js才能写出来的效果。以后看到效果试着能否只是用CSS实现。&lt;/p&gt;

&lt;p&gt;update 2016/05/19
&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/dopant/cssclock/cssclock.html&#34;&gt;使用伪元素结合CSS3动画做的时钟&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/05/29
&lt;a href=&#34;http://jiangshanmeta.github.io/post/cssshape/&#34;&gt;使用伪元素结合border实现彩色环和梯形&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/07/07
&lt;a href=&#34;https://css-tricks.com/centering-in-the-unknown/&#34;&gt;伪元素在垂直居中的应用&lt;/a&gt;。这是一篇发布在css-tricks上的文章，显示利用&lt;code&gt;table&lt;/code&gt;+&lt;code&gt;vertical-align:middle&lt;/code&gt;实现了垂直居中。考虑到&lt;code&gt;vertical-align&lt;/code&gt;依赖于&lt;code&gt;table-cell&lt;/code&gt;或&lt;code&gt;inline-block&lt;/code&gt;或&lt;code&gt;inline&lt;/code&gt;，这篇文章又利用&lt;code&gt;inline-block&lt;/code&gt;实现了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>你真的会用CSS画写正方形吗？</title>
      <link>http://jiangshanmeta.github.io/post/autosquare/</link>
      <pubDate>Sat, 14 May 2016 11:26:46 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/autosquare/</guid>
      <description>

&lt;p&gt;用CSS写一个正方形，对于前端工作者来说是一个再常见不过的需求了，通常情况下，你可能会写出这样的代码：&lt;code&gt;width:200px;height:200px;&lt;/code&gt; 这是最简单的实现了，然而，如果我想要一个300px的正方形呢？或许你会写出如下代码：&lt;code&gt;width:300px;height:300px;&lt;/code&gt; 。那么，如果我想要一个400px的正方形呢？你可能会写出以下代码：&lt;code&gt;width:400px;height:400px;&lt;/code&gt; 同时开始准备和产品以及美术来一场大战。&lt;/p&gt;

&lt;p&gt;显然，一个爱敲键盘的程序员不是好程序员，想偷懒就要对上面的需求进行抽象，然后脑洞大开。上面的需求可以抽象为如何写一个自适应的正方形，这一点其实没什么问题。&lt;/p&gt;

&lt;h2 id=&#34;脑洞大开时间:e010fd746b92c0785d41a89ff0373934&#34;&gt;脑洞大开时间&lt;/h2&gt;

&lt;p&gt;CSS经常被一些大神认为不是一种编程语言，然而，我们可以假装CSS是一门编程语言，就像我可以假装自己有女朋友一样。好了，现在CSS是一门编程语言了，那它会有什么？ &lt;strong&gt;this&lt;/strong&gt;，&lt;strong&gt;this&lt;/strong&gt;，&lt;strong&gt;this&lt;/strong&gt;，一门编程语言没有this你还怎么面向对象编程。如果CSS有this的话，这里就可以这么写了&lt;code&gt;height:this.width&lt;/code&gt;,感觉上挺自然的，以后写CSS会不会要求OOP风格？&lt;/p&gt;

&lt;p&gt;然而，CSS并不支持this，所以脑洞时间结束了，回归现实世界吧&lt;/p&gt;

&lt;h2 id=&#34;回归正常前的瞎折腾阶段:e010fd746b92c0785d41a89ff0373934&#34;&gt;回归正常前的瞎折腾阶段&lt;/h2&gt;

&lt;p&gt;在CSS中，有一些相对单位，比如em，rem，vw，vh之类的，能否用这些做点尝试。&lt;/p&gt;

&lt;p&gt;比如，一个div，宽度是50vw，那么高度也是50vw就好了，算是一种自适应的正方形的实现方案吧。然而，宽高都要基于视口，稍微复杂点的场景就解决不了了，比如，这个div的宽度根本就不是根据视口来的你想怎么办。vw和vh的解决方案由于不够健壮而排出，em 、rem的实现也类似，宽度和高度都要写死 是多少rem/em，大家都有同样的问题，所以也排除了。&lt;/p&gt;

&lt;h2 id=&#34;咦-为什么一定要纠结于设定高度呢:e010fd746b92c0785d41a89ff0373934&#34;&gt;咦，为什么一定要纠结于设定高度呢？&lt;/h2&gt;

&lt;p&gt;对啊，需求是写一个自适应的正方形，谁说一定要在height上折腾，比如，可以用padding撑开这个盒子啊。这一要说一点知识性的东西了，padding值如果取值为百分比，则该百分比是相对于父元素的宽度进行计算的，比那个height的百分比不知道高到哪里去了（height的百分比是相较于父元素的高度的），所以以下代码就可以实现一个响应式的正方形&lt;code&gt;width:25%;padding-bottom:25%;&lt;/code&gt;然而还不够优雅，还是要针对不同的场景写不同的padding-bottom。&lt;/p&gt;

&lt;p&gt;给大家安利一本我最近在看的书 &lt;strong&gt;CSS Secrets&lt;/strong&gt;，其中讲到伪元素能做很多事情。那这里伪元素能做什么呢？伪元素如果是块级元素，其宽度就是父元素宽度（不考虑padding和border），那么伪元素的padding如果为百分比，就是参考于我们正在处理的这个盒子，所以我们有了阶段性的成果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.auto-square::before{
	content:&#39;&#39;;
	display:block;
	padding-bottom:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是一个自适应的正方形就这么写出来了&lt;/p&gt;

&lt;p&gt;于是，又有新的需求的，还要填内容啊！！&lt;/p&gt;

&lt;h2 id=&#34;在自适应的正方形里如何填内容呢:e010fd746b92c0785d41a89ff0373934&#34;&gt;在自适应的正方形里如何填内容呢？&lt;/h2&gt;

&lt;p&gt;如果按照正常的流填什么内容都会破坏正方形的结构，所以我的解决方案是对内容进行绝对定位定位到正方形里。相应的，CSS代码也要加点东西&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.auto-square{
	position:relative;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实战:e010fd746b92c0785d41a89ff0373934&#34;&gt;实战&lt;/h2&gt;

&lt;p&gt;朋友圈里经常有人发个九连拍，每张图所在的盒子就是一个正方形。然而，朋友圈的图片是正方形缩略图，在自己的项目中还要拜托后端处理出一张缩略图来。想想自己也要写后端就觉得干脆用原图然后居中显示得了。&lt;/p&gt;

&lt;p&gt;下面是核心代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;.auto-square{
	position:relative;
}
.auto-square::before{
	content:&#39;&#39;;
	display:block;
	padding-bottom:100%;
}
.center-ab{
	position:absolute;
	top:50%;
	left:50%;
	-webkit-transform:translate(-50%,-50%);
	-moz-transform:translate(-50%,-50%);
	-ms-transform:translate(-50%,-50%);
	-o-transform:translate(-50%,-50%);
	transform:translate(-50%,-50%);
}
.img-responsive{
	display:block;
	max-width:100%;
	max-height:100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及一个&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/layout/auto-square.html&#34;&gt;简单地实例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;update 2016/5/16
想起来这一方法不仅仅能够实现正方形，也能实现长宽比一定的矩形&lt;/p&gt;

&lt;p&gt;update 2017/7/10
慕课网上&lt;a href=&#34;http://t.imooc.com/video/12102&#34;&gt;张鑫旭大神分享了相关内容&lt;/a&gt;，只是他说的是&lt;code&gt;margin&lt;/code&gt;，我这里实现的都是使用&lt;code&gt;padding&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;update 2017/9/3&lt;/p&gt;

&lt;p&gt;话说我为什么一直局限在矩形的范围内呢？如果我加上&lt;code&gt;border-radius:50%&lt;/code&gt;不就是一个圆形了吗？
&lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/csstricks/padding.html&#34;&gt;上demo&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.auto-circle{
    border-radius:50%;
    position:relative;
}
.auto-circle::after{
    content:&#39;&#39;;
    display:block;
    padding-bottom:100%;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>两列布局常见方法</title>
      <link>http://jiangshanmeta.github.io/post/twocolumn/</link>
      <pubDate>Thu, 12 May 2016 20:10:08 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/twocolumn/</guid>
      <description>

&lt;p&gt;画页面最开始要想好的就是如何进行布局。两列布局既是一种常见的布局方式，又是多列布局的基础。本文就我所熟悉的两列布局方式进行总结和比较。&lt;/p&gt;

&lt;h2 id=&#34;浮动布局:5a257f88feea4060d9c6a1cf42573807&#34;&gt;浮动布局&lt;/h2&gt;

&lt;p&gt;浮动最初是为文字环绕功能而设计的，然而现在成了基本的布局方式。&lt;/p&gt;

&lt;p&gt;熟悉bootstrap的人都知道，其经典的12列网格设计就是基于浮动所实现的。bootstrap的网格主要的知识点就是浮动+ &lt;code&gt;box-sizing:border-box&lt;/code&gt; + 媒体查询&lt;/p&gt;

&lt;p&gt;浮动所带来的问题是盒子的塌陷，bootstrap的网格布局解决方案是采取百分比进行限制。这样实现的是两列自适应布局，然而，要实现一列定宽一列自适应就比较困难了，所幸CSS支持计算，可以利用&lt;code&gt;calc&lt;/code&gt; 实现两列一列定宽一列自适应的两列布局&lt;/p&gt;

&lt;p&gt;bootstrap采用的是两列均左浮动实现两列布局，那么一列左浮动可不可以？当然可以。只要给右侧足够的&lt;code&gt;margin-left&lt;/code&gt;就行了。知乎首页人和问题的两列布局就是采用的这种布局方式。这种布局方式有什么问题呢？一是&lt;code&gt;margin-left&lt;/code&gt;值是要写死在代码里的，这一点其实还好，因为基本上大的布局不会变，所以基本上不会改。二是如果右侧有清除浮动的元素，会影响布局。当然对于知乎来说不存在这个问题，毕竟只是文字和图片。&lt;/p&gt;

&lt;p&gt;有什么方法解决上面说的第二个问题呢？对第二个列加上一行&lt;code&gt;overflow:hidden;&lt;/code&gt;就好了。原理是形成BFC然后自己就玩自己的去了。&lt;/p&gt;

&lt;p&gt;update 2017/7/10
上面基本上说的是左侧定宽右侧自适应，如果我想实现右侧定宽左侧自适应，你可能说简单，右侧&lt;code&gt;float:right;&lt;/code&gt;加上一个固定的宽度，左侧&lt;code&gt;margin-right&lt;/code&gt;即可。确实没错，但是这要求右侧定宽区域的html更靠前，而感觉上左侧才应该更靠前。如果我偏要实现左侧靠前呢（一般是处于SEO的考虑），我们可以考虑结合浮动和负值margin&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;left-wrap&amp;quot;&amp;gt;
	&amp;lt;div id=&amp;quot;left-cont&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;right-cont&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;#left-wrap{
	float:left;
	width:100%;
}
#left-cont{
	margin-right:200px; //假设右侧定宽为200px
}
#right-cont{
	float:left;
	margin-left:-200px;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的思路，可以实现&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2009/11/%E6%88%91%E7%86%9F%E7%9F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%89%E6%A0%8F%E7%BD%91%E9%A1%B5%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/&#34;&gt;左右两侧定宽中间自适应且中间html更靠前的三列布局&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;column:5a257f88feea4060d9c6a1cf42573807&#34;&gt;column&lt;/h2&gt;

&lt;p&gt;coolumn的出现是为了模仿报纸的排版的，如果想要实现文字的两列或者多列布局，应用column布局很轻松，然而，不幸的是，如果想要使用column布局的话，我建议还是放弃这个想法吧，一方面各大浏览器对其支持还不够，需要加私有前缀，另一方面其显示有些问题，具体可见&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/pic/waterfall/waterfall_CSS.html&#34;&gt;column实现的瀑布流效果&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;table:5a257f88feea4060d9c6a1cf42573807&#34;&gt;table&lt;/h2&gt;

&lt;p&gt;这里的table指的可不是HTML中的table，而是&lt;code&gt;display:table;&lt;/code&gt;利用table布局很容易实现两列布局，而且还能顺便实现等高布局。关于table的各种坑，我以后会做一个总结。&lt;a href=&#34;http://jiangshanmeta.github.io/post/table/&#34;&gt;关于table的总结&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flex:5a257f88feea4060d9c6a1cf42573807&#34;&gt;flex&lt;/h2&gt;

&lt;p&gt;flex确实是布局神器，然而在生产环境下还是注意一下的好，移动端的情况稍微好点，然而在pc端IE10才支持，至少在pc端有替代方案的就用替代方案吧&lt;/p&gt;

&lt;h2 id=&#34;inline-block:5a257f88feea4060d9c6a1cf42573807&#34;&gt;inline-block&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;display:inline-block;&lt;/code&gt;确实是可以实现两列布局，如果两列宽度加起来不够父元素的宽度，那还好说，如果你想两个元素宽度均为50%,你很有可能会发现并没有实现。原因是两列之间有空格，两个50%加上一个空格显然超过100%。解决方案可以是通过那双灵巧的手，写HTML的时候注意空格，然而对于这种缩进会被不经意间手抖改掉，所以你还要写三遍注释告诉别人和自己不要手抖。这么干的人实在是太无聊了。靠谱点的解决方案是设定父元素&lt;code&gt;font-size:0;&lt;/code&gt;，然后两列字体大小该多少是多少，是个靠谱的解决方案。&lt;/p&gt;

&lt;p&gt;总结起来我个人倾向于各种基于浮动的方案。&lt;/p&gt;

&lt;p&gt;update 2016/08/07&lt;/p&gt;

&lt;p&gt;今天写代码的时候发现老板在项目中的某个地方写了一个两列布局，具体实现 竟然是通过&lt;code&gt;display:inline-block&lt;/code&gt;+百分比宽度实现，不过目测我亲爱的CTO应该是发现了有些问题所以两列的百分比之和不是100%，说一下为什么完全不建议使用&lt;code&gt;display:inline-block&lt;/code&gt;进行两列布局，因为html中会有各种各样的空格换行，对于块级元素或者浮动元素，根本不会去理会这些空格，但是对于内联元素或者内联块级元素，空格会合并，注意是合并而不是忽略，所以如果两个内联块级元素想结合百分比宽度进行两列布局，要么向我们的CTO那样让百分比之和不为100%，手动留出这些空格的空间，要么先在两列外部的容器上使用&lt;code&gt;font-size:0&lt;/code&gt;使得消除空格的影响，然后两列重设字体大小消除&lt;code&gt;font-size:0&lt;/code&gt;的影响，无论哪一个我都不觉得优雅。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>