<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on jsmeta</title>
    <link>https://jiangshanmeta.github.io/categories/javascript/</link>
    <description>Recent content in Javascript on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Feb 2017 19:27:11 +0800</lastBuildDate>
    <atom:link href="https://jiangshanmeta.github.io/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>21天并不能精通underscore.js</title>
      <link>https://jiangshanmeta.github.io/post/js/underscore/</link>
      <pubDate>Tue, 21 Feb 2017 19:27:11 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/underscore/</guid>
      <description>

&lt;p&gt;underscore.js是一个javascript库，它提供了一系列实用功能。在介绍具体的功能之前，需要重新学习几个基本概念。&lt;/p&gt;

&lt;h2 id=&#34;基本概念:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;首先要学习的是&lt;strong&gt;高阶函数&lt;/strong&gt;，高阶函数本身是一个函数，它的参数中包含函数，或者返回一个函数。听起来比较抽象，我们举一个实际的例子吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var property = function(key) {
	return function(obj) {
	  return obj == null ? void 0 : obj[key];
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据文档描述，这个函数返回一个新函数，新函数返回传入任何对象的key属性。上面的property函数就是一个高阶函数，除此之外，对这个函数还有一些可说的。比如说&lt;strong&gt;闭包&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;property函数每次被调用的时候都会创建一个新的执行上下文，其中key被赋值为我们传入的值，比如说underscore会内置一个方法&lt;code&gt;getLength&lt;/code&gt;传入的就是length，当函数走到return的时候，返回新函数，但是这个key还不能被释放掉，因为我们会在新函数中用到这个key，闭包算是老生常谈的了，常常在一起提及的还有作用域链、内存泄漏，不多说了。&lt;/p&gt;

&lt;p&gt;第三个要了解的新概念是&lt;strong&gt;偏函数&lt;/strong&gt;，偏函数是相对于原函数而言的，偏的意思是部分，原函数的部分参数或者变量被预置形成的新函数就是偏函数。underscore.js中提供了&lt;code&gt;_.partial&lt;/code&gt;方法，它相当于一个偏函数工厂，原料是原函数，生成偏函数。看下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	var self = baseCreate(sourceFunc.prototype);
	var result = sourceFunc.apply(self, args);
	if (_.isObject(result)) return result;
	return self;
};
_.partial = function(func) {
var boundArgs = slice.call(arguments, 1);
var bound = function() {
  var position = 0, length = boundArgs.length;
  var args = Array(length);
  for (var i = 0; i &amp;lt; length; i++) {
    args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
  }
  while (position &amp;lt; arguments.length) args.push(arguments[position++]);
  return executeBound(func, bound, this, this, args);
};
return bound;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，我们在partial中可以预填一些参数，如果想跳过某些参数可以用&lt;code&gt;_&lt;/code&gt;占位，在执行的的时候会用相应的参数替换的。&lt;/p&gt;

&lt;p&gt;需要先说明的基本概念就这些，然后我要从函数相关的函数讲起了。&lt;/p&gt;

&lt;h2 id=&#34;函数相关的函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;函数相关的函数&lt;/h2&gt;

&lt;p&gt;你可能会奇怪为啥我要从函数相关的函数开始说，按照文档或者源码应该先说整体结构或者集合啊，因为看到作者写的关于函数的函数我怀疑我以前写的是假javascript。&lt;/p&gt;

&lt;h4 id=&#34;bind:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.bind&lt;/h4&gt;

&lt;p&gt;函数执行的时候有一个执行上下文，通过作用域链我们可以一级一级向上访问变量，直到全局作用域，bind的作用就是改变执行上下文。在jQuery中绑定执行上下文的方法是&lt;code&gt;jQuery.proxy&lt;/code&gt;，它那里用的是apply方法，在underscore中用的是bind方法。这两个其实差异挺大的，apply/call会立即执行函数，而bind方法仅仅是绑定执行上下文，不会立即执行，所以jQuery源码在外面又包了一层函数。其实我们可以这么看：apply和bind方法都能改变执行上下文，apply同时还做了调用函数，包了一层函数会推迟绑定的时间，直到外层包裹函数被调用的时候才执行绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy: function( fn, context ) {
	var tmp, args, proxy;
	if ( typeof context === &amp;quot;string&amp;quot; ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}
	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !jQuery.isFunction( fn ) ) {
		return undefined;
	}
	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};
	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是jQuery的代码，函数内部的那个&lt;code&gt;proxy&lt;/code&gt;就是我说的包的一层函数。而underscore的做法是直接使用原生的bind方法，如果没有原生的bind方法就用一个兼容函数，兼容函数的基本思路和jQuery的是一致的。我们去看&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;MDN上bind方法的文档&lt;/a&gt;，其中提到bind方法的一个作用是偏函数，想想也对，bind调用的时候不仅仅可以绑定作用域，而且可以传参，这样返回的新函数确实是偏函数，这里或许会加深你对偏函数的理解。&lt;/p&gt;

&lt;h4 id=&#34;memoize:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.memoize&lt;/h4&gt;

&lt;p&gt;这个函数是个工厂函数，返回的新函数具有缓存结果的能力。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.memoize = function(func, hasher) {
	var memoize = function(key) {
	  var cache = memoize.cache;
	  var address = &#39;&#39; + (hasher ? hasher.apply(this, arguments) : key);
	  if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	  return cache[address];
	};
	memoize.cache = {};
	return memoize;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码并不难理解，以前我也写过具有缓存功能的函数，思路都是一致的，作者进一步抽象，做了一个缓存函数工厂，使得输出的函数每一个都具有缓存能力。这里同时提供了一个可选的hasher参数，用来生成缓存的键。&lt;/p&gt;

&lt;p&gt;用处很多了，文档中给的例子是递归，为了防止栈溢出。&lt;/p&gt;

&lt;h4 id=&#34;throttle:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.throttle&lt;/h4&gt;

&lt;p&gt;这个函数能够控制函数的执行频率，保证至少间隔wait时间才能执行一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.throttle = function(func, wait, options) {
	var context, args, result;
	var timeout = null;
	var previous = 0;
	if (!options) options = {};
	var later = function() {
	  previous = options.leading === false ? 0 : _.now();
	  timeout = null;
	  result = func.apply(context, args);
	  if (!timeout) context = args = null;
	};
	return function() {
	  var now = _.now();
	  if (!previous &amp;amp;&amp;amp; options.leading === false) previous = now;
	  var remaining = wait - (now - previous);
	  context = this;
	  args = arguments;
	  if (remaining &amp;lt;= 0 || remaining &amp;gt; wait) {
	    if (timeout) {
	      clearTimeout(timeout);
	      timeout = null;
	    }
	    previous = now;
	    result = func.apply(context, args);
	    if (!timeout) context = args = null;
	  } else if (!timeout &amp;amp;&amp;amp; options.trailing !== false) {
	    timeout = setTimeout(later, remaining);
	  }
	  return result;
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，基本原理是利用时间戳记录上次执行时间，这点其实好理解，比较复杂的是配置参数&lt;code&gt;leading&lt;/code&gt;和&lt;code&gt;trailing&lt;/code&gt;。
在默认条件下两者均为undefined，在这一条件下触发函数，func被调用，在wait时间内触发都不会调用func，直到wait时间结束后才会被调用(对应的参数是最后一次触发时的参数)。leading为undefined，trailing为false，则在调用的时候func被调用，wait时间内多次触发没有效果。leading为false，trailing为undefined，则在wait时间结束func才会被调用，期间的触发会改变context和args。然后我们可以看到&lt;code&gt;if (!timeout) context = args = null;&lt;/code&gt;，这句话其实是为了优化性能，减少闭包占用的内存。&lt;/p&gt;

&lt;h4 id=&#34;debounce:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.debounce&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;_.debounce = function(func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function() {
	  var last = _.now() - timestamp;

	  if (last &amp;lt; wait &amp;amp;&amp;amp; last &amp;gt;= 0) {
	    timeout = setTimeout(later, wait - last);
	  } else {
	    timeout = null;
	    if (!immediate) {
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  }
	};

	return function() {
	  context = this;
	  args = arguments;
	  timestamp = _.now();
	  var callNow = immediate &amp;amp;&amp;amp; !timeout;
	  if (!timeout) timeout = setTimeout(later, wait);
	  if (callNow) {
	    result = func.apply(context, args);
	    context = args = null;
	  }

	  return result;
	};
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照文档的说法，返回 function 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 wait 毫秒之后。基本思路是有一个标识上次触发的时间戳，然后比较时间看能否执行。这个请结合时间轴理解。我记得Vue1里面变淡那里有类似的概念，好像Vue2去掉了。&lt;/p&gt;

&lt;h4 id=&#34;negate:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.negate&lt;/h4&gt;

&lt;p&gt;返回一个断言函数的相反版本，这个函数在内部经常被调用，思路上没什么难的，但是作者做了一步抽象成为了函数工厂。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.negate = function(predicate) {
	return function() {
	  return !predicate.apply(this, arguments);
	};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;delay:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.delay&lt;/h4&gt;

&lt;p&gt;这个函数相比较之下可说的不多了，直接上源码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.delay = function(func, wait) {
	var args = slice.call(arguments, 2);
	return setTimeout(function(){
	  return func.apply(null, args);
	}, wait);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;before-after-once:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.before _.after _.once&lt;/h4&gt;

&lt;p&gt;这三个函数是和函数调用次数有关的，after是被触发times次之后才调用func，before是最多只能调用times次(不含times，所以我觉得很奇怪)，once只是before的特殊情况，可以看到源码里once是利用partial将before加工生成的偏函数。&lt;/p&gt;

&lt;p&gt;关于函数的函数每一个都是高阶函数，都返回新的处理过的函数，每一个具体的功能其实或多或少都实现过，但是抽象能力没有作者这么高。&lt;/p&gt;

&lt;h2 id=&#34;集合相关函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;集合相关函数&lt;/h2&gt;

&lt;p&gt;集合相关函数基本上都会用到迭代器，而用户传入的迭代器不仅仅可以是一个函数，对象、字符串、数字、甚至不传都可以，underscore在内部会做统一处理，使其变成一个函数的形式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var optimizeCb = function(func, context, argCount) {
	if (context === void 0) return func;
	switch (argCount == null ? 3 : argCount) {
	  case 1: return function(value) {
	    return func.call(context, value);
	  };
	  case 2: return function(value, other) {
	    return func.call(context, value, other);
	  };
	  case 3: return function(value, index, collection) {
	    return func.call(context, value, index, collection);
	  };
	  case 4: return function(accumulator, value, index, collection) {
	    return func.call(context, accumulator, value, index, collection);
	  };
	}
	return function() {
	  return func.apply(context, arguments);
	};
};

var cb = function(value, context, argCount) {
	if (value == null) return _.identity;
	if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	if (_.isObject(value)) return _.matcher(value);
	return _.property(value);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在源码的一开始，一开始读的时候会感觉莫名其妙，我来一一解读。cb函数是用来将各种用户传入的迭代器转换成内部能够使用的迭代器的。首先，如果用户不传迭代器，默认迭代器就是&lt;code&gt;_.identity&lt;/code&gt;，这个函数返回与传入参数相等的值，真的很没用，而且听着描述就能顺手把这个函数实现掉。这个函数被_.compact调用过，虽然我觉得后者也没啥用。然后第二类参数是函数，这应该是最常见的情况了，在内部对函数做了优化(optimizeCb)，顺手说下这个奇怪的optimizeCb，初读的时候会发现switch里返回的函数和最后默认返回的函数干的事同一件事情，为啥还要写这么多相似的代码？查了一下我的结论是魔术变量arguments有性能上的问题，这里还一点是&lt;code&gt;void 0&lt;/code&gt;，一般很少见人用这个啊，他这里考虑的是undefined可能会被篡改。下一种类型是Object(含array)，他这里返回的是matcher函数生成的偏函数，偏函数用于检测传入的新对象是否包含这里的对象value。最后一种情况是字符串、数字，property函数的具体实现已经在最开始说过了。&lt;/p&gt;

&lt;p&gt;到这里我们已经有工具预处理用户传入的迭代器，拿到内部可用的新迭代器了。剩下的就套路比较多了。&lt;/p&gt;

&lt;h4 id=&#34;each:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.each&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;_.each = _.forEach = function(obj, iteratee, context) {
	iteratee = optimizeCb(iteratee, context);
	var i, length;
	if (isArrayLike(obj)) {
	  for (i = 0, length = obj.length; i &amp;lt; length; i++) {
	    iteratee(obj[i], i, obj);
	  }
	} else {
	  var keys = _.keys(obj);
	  for (i = 0, length = keys.length; i &amp;lt; length; i++) {
	    iteratee(obj[keys[i]], keys[i], obj);
	  }
	}
	return obj;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原生js给array原型上加了一个forEach方法用来迭代数组，只能处理数组，jQuery也有一个each不仅仅能够处理数组，类数组、和对象也都能处理，underscore的each和jQuery的其实差不多，但是在jQuery中如果迭代返回false就停止迭代了。&lt;/p&gt;

&lt;p&gt;这里还有个内部函数&lt;code&gt;isArrayLike&lt;/code&gt;，其实jQuery也有个同样功能的函数，看下代码吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
var getLength = property(&#39;length&#39;);
var isArrayLike = function(collection) {
	var length = getLength(collection);
	return typeof length == &#39;number&#39; &amp;amp;&amp;amp; length &amp;gt;= 0 &amp;amp;&amp;amp; length &amp;lt;= MAX_ARRAY_INDEX;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面的&lt;code&gt;getLength&lt;/code&gt;函数我其实在最开始说&lt;code&gt;property&lt;/code&gt;函数的时候已经提过了。&lt;/p&gt;

&lt;h4 id=&#34;map:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.map&lt;/h4&gt;

&lt;p&gt;原生js的array上也有个map方法，但是只能用在array上，这里也是推广到了类数组和对象。其实有了上面&lt;code&gt;_.each&lt;/code&gt;的代码，我们完全可以照着实现一个map，代码上也没有太多难以理解的。&lt;/p&gt;

&lt;p&gt;一个相类似的函数是&lt;code&gt;_.mapObject&lt;/code&gt;，它只能对object进行迭代，并且mapObject的结果是一个object，而map的结果是一个array&lt;/p&gt;

&lt;h4 id=&#34;reduce-reduceright:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.reduce  _.reduceRight&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function createReduce(dir) {
	function iterator(obj, iteratee, memo, keys, index, length) {
	  for (; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; length; index += dir) {
	    var currentKey = keys ? keys[index] : index;
	    memo = iteratee(memo, obj[currentKey], currentKey, obj);
	  }
	  return memo;
	}

	return function(obj, iteratee, memo, context) {
	  iteratee = optimizeCb(iteratee, context, 4);
	  var keys = !isArrayLike(obj) &amp;amp;&amp;amp; _.keys(obj),
	      length = (keys || obj).length,
	      index = dir &amp;gt; 0 ? 0 : length - 1;
	  // Determine the initial value if none is provided.
	  if (arguments.length &amp;lt; 3) {
	    memo = obj[keys ? keys[index] : index];
	    index += dir;
	  }
	  return iterator(obj, iteratee, memo, keys, index, length);
	};
}

  _.reduce = _.foldl = _.inject = createReduce(1);
  _.reduceRight = _.foldr = createReduce(-1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果先看了underscore中关于函数的函数，再看这一段就会觉得没那么难以理解了。&lt;code&gt;createReduce&lt;/code&gt;是一个高阶函数，传入的是迭代的方向。类似的套路还有 &lt;code&gt;_.findIndex&lt;/code&gt;、&lt;code&gt;findLastIndex&lt;/code&gt;、&lt;code&gt;createPredicateIndexFinder&lt;/code&gt;这一组，还有&lt;code&gt;_.indexOf&lt;/code&gt; 、&lt;code&gt;_.lastIndexOf&lt;/code&gt;、&lt;code&gt;createIndexFinder&lt;/code&gt;这一组。&lt;/p&gt;

&lt;h4 id=&#34;sortby:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.sortBy&lt;/h4&gt;

&lt;p&gt;这个函数其实是叫我们如何优雅的使用underscore&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.sortBy = function(obj, iteratee, context) {
	iteratee = cb(iteratee, context);
	return _.pluck(_.map(obj, function(value, index, list) {
	  return {
	    value: value,
	    index: index,
	    criteria: iteratee(value, index, list)
	  };
	}).sort(function(left, right) {
	  var a = left.criteria;
	  var b = right.criteria;
	  if (a !== b) {
	    if (a &amp;gt; b || a === void 0) return 1;
	    if (a &amp;lt; b || b === void 0) return -1;
	  }
	  return left.index - right.index;
	}), &#39;value&#39;);
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在underscore中有不少函数就是在其他函数的基础上搭起来的。这个sortBy函数中用到的pluck就是一个基于map搭出来的函数。&lt;/p&gt;

&lt;h4 id=&#34;groupby-indexby-countby:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.groupBy _.indexBy _.countBy&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var group = function(behavior) {
	return function(obj, iteratee, context) {
	  var result = {};
	  iteratee = cb(iteratee, context);
	  _.each(obj, function(value, index) {
	    var key = iteratee(value, index, obj);
	    behavior(result, value, key);
	  });
	  return result;
	};
};

_.groupBy = group(function(result, value, key) {
	if (_.has(result, key)) result[key].push(value); else result[key] = [value];
});

_.indexBy = group(function(result, value, key) {
	result[key] = value;
});

_.countBy = group(function(result, value, key) {
	if (_.has(result, key)) result[key]++; else result[key] = 1;
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;groupBy、indexBy、countBy这三个在实现上没有太多难以理解的东西，但是注意这个抽象能力。&lt;/p&gt;

&lt;h2 id=&#34;数组相关函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;数组相关函数&lt;/h2&gt;

&lt;h4 id=&#34;uniq:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.uniq&lt;/h4&gt;

&lt;p&gt;数组去重算是一个经典问题了，对于一些特殊的数据我会将数组转化成hash结构(用object实现)然后再转回数组来实现(然而碰到的绝大多数是这种情况，算法复杂度O(n) )，underscore提供的去重方法更加通用，考虑的也更多，它提供一个可选参数isSorted，用于已经排序的元素，这时候算法的时间复杂度是O(n)，传入迭代器或者不传入迭代器的算法时间复杂度是O(n^2),判断是否是重复元素用的是&lt;code&gt;_.contains&lt;/code&gt;，它再调用&lt;code&gt;_.indexOf&lt;/code&gt;，看名字array的原型上就有这么一个方法，underscore的进步之处是它还考虑了NaN的情况(ES6的includes方法考虑了NaN的情况，但是这个糟心的兼容性问题，还有MDN上的polyfill有bug没考虑NaN的情况)。&lt;/p&gt;

&lt;p&gt;underscore去重算法的源码就不在这里贴了，但是很推荐去读一下源码&lt;/p&gt;

&lt;h4 id=&#34;intersection:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.intersection&lt;/h4&gt;

&lt;p&gt;这个函数是用来求交集的，原理也不复杂，交集的话一定是第一个集合的子集，只要遍历第一个集合的元素，看其他集合是否有这个元素即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.intersection = function(array) {
	var result = [];
	var argsLength = arguments.length;
	for (var i = 0, length = getLength(array); i &amp;lt; length; i++) {
	  var item = array[i];
	  if (_.contains(result, item)) continue;
	  for (var j = 1; j &amp;lt; argsLength; j++) {
	    if (!_.contains(arguments[j], item)) break;
	  }
	  if (j === argsLength) result.push(item);
	}
	return result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一提到交集，会联想到的另一个名词就是并集，并集的思路更简单了，把集合合并在一起，然后去重就好了。去重上面已经有代码了，现在需要的是合并，underscore内部的&lt;code&gt;flatten&lt;/code&gt;能够进行合并，而且看一下参数配置，你会发现union方法实际上考虑了传递的参数类型，并且只允许集合(数组)被合并。&lt;/p&gt;

&lt;h2 id=&#34;对象相关函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;对象相关函数&lt;/h2&gt;

&lt;h4 id=&#34;类型判断全家桶:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;类型判断全家桶&lt;/h4&gt;

&lt;p&gt;又是个js的常见问题，其实jQuery里也有相关的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === &#39;[object Array]&#39;;
  };

  _.isObject = function(obj) {
    var type = typeof obj;
    return type === &#39;function&#39; || type === &#39;object&#39; &amp;amp;&amp;amp; !!obj;
  };  

  _.each([&#39;Arguments&#39;, &#39;Function&#39;, &#39;String&#39;, &#39;Number&#39;, &#39;Date&#39;, &#39;RegExp&#39;, &#39;Error&#39;], function(name) {
    _[&#39;is&#39; + name] = function(obj) {
      return toString.call(obj) === &#39;[object &#39; + name + &#39;]&#39;;
    };
  });

  _.isFinite = function(obj) {
    return isFinite(obj) &amp;amp;&amp;amp; !isNaN(parseFloat(obj));
  };

  _.isNaN = function(obj) {
    return _.isNumber(obj) &amp;amp;&amp;amp; obj !== +obj;
  };

  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === &#39;[object Boolean]&#39;;
  };

  _.isNull = function(obj) {
    return obj === null;
  };

  _.isUndefined = function(obj) {
    return obj === void 0;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否是array的时候先尝试使用Array的静态方法&lt;code&gt;Array.isArray&lt;/code&gt;，兼容版本大家其实都熟。&lt;/p&gt;

&lt;p&gt;对于Object的判断就有些奇怪了，他把function object array都算作object了（null这个异端没算），虽然我不太认同这个规则（反过来想想在js的世界谁不是对象呢）。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;_.isFinite&lt;/code&gt;和&lt;code&gt;_.isNaN&lt;/code&gt;这两个的意思就是故意黑js了，记得Number对象上有了相关的判断静态方法，不过实际项目中真的有必要判断这两个？我反正没判断过。&lt;/p&gt;

&lt;p&gt;其实我个人认为把isArrayLike暴露出来的其实更好。&lt;/p&gt;

&lt;h4 id=&#34;keys-allkeys-values:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.keys  _.allKeys  _.values&lt;/h4&gt;

&lt;p&gt;看名字自行联想也能猜出来是干啥的，&lt;code&gt;Object.values&lt;/code&gt;目前还处于实验阶段，然而我更好奇当时出&lt;code&gt;Object.keys&lt;/code&gt;的时候为啥没把这货一起写上。实现起来没啥难的。&lt;/p&gt;

&lt;h4 id=&#34;invert:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.invert&lt;/h4&gt;

&lt;p&gt;php有一个内置方法&lt;code&gt;array_flip&lt;/code&gt;是用来交换键值的，underscore的这个方法就是模拟这个功能。自己可以试着实现一下。&lt;/p&gt;

&lt;h4 id=&#34;functions:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.functions&lt;/h4&gt;

&lt;p&gt;这是个特异化的keys功能，只返回方法名。&lt;/p&gt;

&lt;h4 id=&#34;extend-extendown-clone:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.extend _.extendOwn _.clone&lt;/h4&gt;

&lt;p&gt;让我想到了原生的&lt;code&gt;Object.assign&lt;/code&gt;和jQuery的&lt;code&gt;jQuery.extend&lt;/code&gt;，其实我觉得jQuery写的更好，功能强大多了，建议大家去读jQuery的extend&lt;/p&gt;

&lt;h2 id=&#34;其他函数:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;其他函数&lt;/h2&gt;

&lt;h4 id=&#34;shuffle:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.shuffle&lt;/h4&gt;

&lt;p&gt;在php中有一个系统方法shuffle用来将原数组打乱顺序，underscore也实现了这一功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index &amp;lt; length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里重要的是重排算法的实现。&lt;/p&gt;

&lt;h4 id=&#34;sortedindex:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;_.sortedIndex&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low &amp;lt; high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) &amp;lt; value) low = mid + 1; else high = mid;
    }
    return low;
  };

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法适用于已经从小到大排好序的数组，用的是二分法查找。&lt;/p&gt;

&lt;h4 id=&#34;mixin:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;mixin&lt;/h4&gt;

&lt;p&gt;这个方法是用来让用户扩展underscore的。看下源码其实不难理解，但我到现在依然怀疑把函数挂到underscore的原型上的必要性。&lt;/p&gt;

&lt;p&gt;而且这个方法本身很危险，因为他允许用户修改underscore暴露出来的的方法。想起来之前看的CI的一个library，有这么一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function initialize($params = array())
{
	if (count($params) &amp;gt; 0)
	{
		foreach ($params as $key =&amp;gt; $val)
		{
			if (isset($this-&amp;gt;$key))
			{
				$this-&amp;gt;$key = $val;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CI的做法是$this上挂载的才允许用户设置，多余的设置一律跳过，underscore可以使用类似的思路，underscore上没有挂载的才允许挂载，至少这样比较安全。&lt;/p&gt;

&lt;h2 id=&#34;总结:94bfca3b88507512aeb14566fa19a6d0&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于underscore我没有一个一个列出来解读，而是找了一些有代表性的重要的代码简单评价一下。有的功能其实看着上面的描述可以自行去尝试实现一下了，比如说&lt;code&gt;_.constant&lt;/code&gt;和&lt;code&gt;_.propertyOf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;读underscore源码对我来说最大的影响作者的抽象能力，还有暴露了我对函数这个概念理解地太弱。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>观察者模式的一次实践</title>
      <link>https://jiangshanmeta.github.io/post/js/observer/</link>
      <pubDate>Mon, 10 Oct 2016 20:05:11 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/observer/</guid>
      <description>&lt;p&gt;观察者模式是用来解除对象间的耦合同时保证对象间数据通信的一种设计模式，要实现对象间通信数据首先要订阅某个主题，然后监听某个主题发布信息。听起来云里雾里但是前端都见过其中的一个典型例子，就是事件，首先通过&lt;code&gt;addEventListener&lt;/code&gt;订阅事件，然后等待用户触发事件或者脚本触发事件，这时就发布了主题，此时各个对象执行相应的回调。&lt;/p&gt;

&lt;p&gt;我也实现了一个简单的观察者模式( &lt;a href=&#34;http://jiangshanmeta.github.io/blogdemo/jsdesignpattern/observer.js&#34;&gt;点击下载源码&lt;/a&gt; )：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Observer = (function(){
	var _message = {};
	return {
		register:function(typ,fn){
			if(!_message[typ]){
				_message[typ] = [];
			}
			_message[typ].push(fn);
			return this;
		},
		publish:function(typ,data){
			if(_message[typ]){
				for(var i=0,len=_message[typ].length;i&amp;lt;len;i++){
					_message[typ][i](data);
				}
			}
			return this;
		},
		remove:function(typ,fn){
			if(_message[typ]){
				for(var i=0,len=_message[typ].length;i&amp;lt;len;i++){
					_message[typ][i] ==fn &amp;amp;&amp;amp; _message[typ].splice(i,1);
				}
			}

			return this;
		}
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现是希望将对象之间的通信通过这一个对象进行，这个实现说实话只适用于小型的项目。&lt;/p&gt;

&lt;p&gt;我应用它的场景是这样的：多个对象都有选择地址这么一个操作，在选择地址中有一项是添加地址，然而添加地址这一操作对应一个新的对象，在添加地址对象完成添加后，需要通知其他选择地址对象新的地址array。最开始的实现是判断那几个选择地址的对象存不存在，如果存在就把数据传过去，每多一次引用就要多一个判断。然后我就使用观察者模式改写，更新地址array的时候发布一个更新地址主题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript中的继承、私有、静态</title>
      <link>https://jiangshanmeta.github.io/post/js/extend/</link>
      <pubDate>Sun, 04 Sep 2016 20:29:27 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/extend/</guid>
      <description>

&lt;p&gt;javascript是一门奇特的语言，想入门写点小东西很简单，但是一旦深入就觉得难度陡增。这里对比php，简单总结一下。&lt;/p&gt;

&lt;h2 id=&#34;继承:8151693739dce8237269a30642b03e79&#34;&gt;继承&lt;/h2&gt;

&lt;p&gt;先上两段代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Person{
	public function __construct($name=&#39;&#39;){
		$this-&amp;gt;name = $name;
	}

	public function genName(){
		return $this-&amp;gt;name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;php中的类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
}

Person.prototype.genName = function(){
	returrn this.name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js中的构造函数及prototype&lt;/p&gt;

&lt;p&gt;在使用new关键字的时候，两端代码其实功能是一致的，都会生成一个实例，实例具有name这一属性和genName这一方法。在javascript中没有类的概念，所以&lt;strong&gt;用构造函数结合prototype模拟类&lt;/strong&gt;。在第二段代码中，因为genName这一方法是每个实例所共享的，不需要再每个实例上都实现一遍，所以放在了构造函数的prototype上。&lt;strong&gt;js的构造函数，基本上可以类比于php的构造函数&lt;code&gt;__construct()&lt;/code&gt;,而php的其他部分大致对应js的prototype&lt;/strong&gt;。换句话说想要在js中模拟一个类，需要构造函数和prototype两部分。这也是为什么下面js实现继承的时候，需要在构造函数和原型上都做处理。&lt;/p&gt;

&lt;p&gt;在php中的继承是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Kid extends Person{
	public function __construct($name=&#39;&#39;,$age=1){
		parent::construct($name);
		$this-&amp;gt;age = $age;
	}

	public function genAge(){
		returrn $this-&amp;gt;age;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在javascript中要模拟php中的继承，需要模拟在构造函数和prototype两个地方分别模拟（毕竟这两者结合起来才像个类）。&lt;/p&gt;

&lt;p&gt;首先我们要实现构造函数的模拟：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Kid(name,age){
	Person.call(this,name); //相当于php代码的 parent::construct($name);
	this.age = age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们要实现对于基类中的方法的继承，这一点是通过原型链实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kid.prototype = Object.create(Person.prototype);
Kid.prototype.constructor = Kid;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们要实现的是对于子类方法的扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kid.prototype.genAge = function(){
	return this.age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对于js的Kid，我们使用new操作得到的实例，含有name和age两个属性，含有genName和genAge两个方法，与php的Kid类通过new生成的实例一样。&lt;/p&gt;

&lt;h2 id=&#34;私有:8151693739dce8237269a30642b03e79&#34;&gt;私有&lt;/h2&gt;

&lt;p&gt;在php中，静态属性和静态方法都可以直接通过&lt;code&gt;$this&lt;/code&gt;来调用，然而在js中，一旦能够通过&lt;code&gt;this&lt;/code&gt;访问，那么一定是公有的了。&lt;/p&gt;

&lt;p&gt;在js中实现静态属性和静态方法都必须在构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
	var privateName = name; //私有属性
	this.getPrivateName = function(){
		return privateName;
	}
	var sayPrivateName = function(){
		console.log(&amp;quot;private name is &amp;quot; + privateName);
	}  //私有方法
	this.sayPrivateName = function(){
		sayPrivateName();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到想要调用私有属性，对应方法必须写在构造函数内，想要调用私有方法的方法也必须写在构造函数内，总的来说为了实现私有化太折腾了，所以行业里的一个做法是私有的加下划线前缀然后按照公有的实现，我们只是人工认为这是私有的。&lt;/p&gt;

&lt;h2 id=&#34;静态:8151693739dce8237269a30642b03e79&#34;&gt;静态&lt;/h2&gt;

&lt;p&gt;相比较于继承和私有，在js中模拟静态就简单多了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name){
	this.name = name;
}
Person.publicStaticMethod1 = function(){
	console.log(&#39;this is a public static method&#39;);
}
Person.publicStaticProperty = &#39;naive&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码就实现了公有静态属性和公有静态方法。&lt;/p&gt;

&lt;p&gt;虽然实现起来不复杂但我没怎么见人用过。&lt;/p&gt;

&lt;p&gt;见得比较多的是静态私有属性的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window){
	var totalPerson = 0;
	function Person(name){
		this.name = name;
		totalPerson++;
	}
	window.Person = Person;
})(window);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/single/&#34;&gt;在js中实现单例模式也使用了静态私有变量&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;静态私有方法和静态私有属性的实现差不多(其实都是利用了js的作用域),而且之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/static/&#34;&gt;总结php的静态&lt;/a&gt;的时候我总结过静态方法基本可以被实例方法所替代，所以不多说了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>上网的不科学指南</title>
      <link>https://jiangshanmeta.github.io/post/computernetwork/summarize/</link>
      <pubDate>Tue, 16 Aug 2016 20:03:58 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/computernetwork/summarize/</guid>
      <description>&lt;p&gt;看计算机网络已经有一段时间了，对于应用层、传输层、网络层、链路层也有了基本的了解。但是感觉自己学的比较零碎，缺乏一个整体的概念，所以想写一篇总结，把这些东西串起来。&lt;/p&gt;

&lt;p&gt;想要上网的话，首先要通过&lt;strong&gt;&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;&lt;/strong&gt;获得一个IP地址。&lt;/p&gt;

&lt;p&gt;客户端这里首先生成一个DHCP发现报文，然后把这个报文交给传输层传输层的&lt;code&gt;UDP&lt;/code&gt;，DHCP有固定的源端口号和目的端口号。&lt;code&gt;UDP&lt;/code&gt;封装好之后，交给网络层去处理，网络层的IP报文需要填写目的IP地址和源IP地址，然而目前自身的IP待分配、目的IP地址也未知，这里就需要两个特殊的IP地址了，源IP地址为&lt;code&gt;0.0.0.0&lt;/code&gt;表示本机，目的IP地址为&lt;code&gt;255.255.255.255&lt;/code&gt;表示广播地址。网络层处理完交给数据链路层处理，需要源MAC地址和目的MAC地址，现在连DHCP服务器是谁都不知道怎么确定MAC地址？答案和刚提到的广播IP地址类似，目的MAC地址填上广播MAC地址&lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;局域网内部的每一台主机都能收到这个报文，但是只有DHCP服务器才会做出响应。对于DHCP服务器，数据自下传递到上层，然后把分配的IP地址、DNS服务器地址、默认网关地址、子网掩码 作为DHCP ACK报文，然后向下逐层封装。形成IP报文的时候目的地址依然为广播地址。在这里说一句无论是DHCP发现报文还是DHCP ACK报文，中间都经过&lt;code&gt;链路层交换机&lt;/code&gt;，链路层交换机会根据源MAC地址和输入链路的接口在交换机表中记录一条记录，作为转发的基础。&lt;/p&gt;

&lt;p&gt;现在我们这台主机获得了自己的IP地址，顺便还有默认DNS服务器地址、默认网关地址、子网掩码。当我们在地址栏中输入一个url的时候，比如 &lt;a href=&#34;http://jiangshanmeta.github.io&#34;&gt;http://jiangshanmeta.github.io&lt;/a&gt; ，就需要通过&lt;code&gt;DNS&lt;/code&gt;服务（至少对于chrome调用DNS不见得一定在输入url然后确认之后，我们没有必要关心这个调用的时机）。DNS服务器地址是在DHCP返回的，有可能和我们的主机在一个子网内，也可能不在一个子网内，这需要结合两者的IP地址和&lt;strong&gt;子网掩码&lt;/strong&gt;判断，通常不要指望在一个子网内。要和子网外部进行通信需要通过网关，我们已经有了默认网关地址（一个IP地址），但是数据链路层需要MAC地址，因而我们需要&lt;code&gt;ARP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;ARP是根据IP地址返回MAC地址，它也是利用广播，子网内每台主机都会收到ARP报文，但是只有IP地址对应的才会返回MAC地址。通过ARP获得默认网关MAC地址，这样在主机那里各层发送DNS报文所需要的基本信息就有了，DNS交给UDP、UDP交给IP然后交给链路层封装成帧，所形成的数据帧传递到路由器，路由器这里根据由&lt;code&gt;路由协议&lt;/code&gt;（这么复杂的协议我说这么一句话真的好吗）决定的转发表决定转发的输出链路，根据转发表提供的下一跳IP地址利用ARP获得新的目的MAC地址重写数据链路层（在路由器网络层首部和数据链路层都会有一些首部字段被修改，目的MAC地址是每经过一次路由器就修改，但是目的IP地址相一般不会修改，除非是经过了&lt;code&gt;NAT&lt;/code&gt;）。本地DNS服务器获得请求之后，可能&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;经过一系列请求&lt;/a&gt;，也可能直接根据缓存返回要查询的IP地址。这样我们的主机获得了请求域名的IP地址，对网页的请求的准备工作基本完成了。&lt;/p&gt;

&lt;p&gt;现在需要发起HTTP请求了，以我上面提到的网址为例就是发送一个GET请求，应用层把http报文交给TCP，TCP相比较上面提到的传输层协议UDP，提供可靠传输功能。它需要首先建立连接，然后才能传递上层传来的数据。再往下层的东西上面已经提及了，通过网关出子网，然后经过各种路由转发最终到达目标服务器，目标服务器根据请求的url提供文件，然后又是一层层封装路由转发解封装到达应用层，这样我们得到了请求的文件，比如html，剩下的就是浏览器如何解析返回的数据了，这就是另一个话题了。&lt;/p&gt;

&lt;p&gt;这样我基本上把所学到的计算机网络知识串了起来，包括&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dns/&#34;&gt;DNS&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httpmethodandstatuscode/&#34;&gt;http&lt;/a&gt;、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/transportlayer/&#34;&gt;传输层&lt;/a&gt;的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/httptransportcontrol/&#34;&gt;TCP&lt;/a&gt;和UDP、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/dhcp/&#34;&gt;DHCP&lt;/a&gt;、网络层的&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/ip/&#34;&gt;网际协议&lt;/a&gt;和路由协议、NAT、&lt;a href=&#34;http://jiangshanmeta.github.io/post/computernetwork/mac/&#34;&gt;链路层MAC地址、ARP协议（这是个跨层的协议）、链路层交换机&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;每一层都有了一定的了解，下面的任务是转入http协议的学习和设计模式的学习了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——tab.js</title>
      <link>https://jiangshanmeta.github.io/post/bootstrap/tab/</link>
      <pubDate>Thu, 14 Jul 2016 22:56:40 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/bootstrap/tab/</guid>
      <description>&lt;p&gt;tab切换是网页中的常见设计，从实现上讲也并不复杂，基本思路是导航监听事件，然后把之前显示的tab窗口隐藏掉，然后把导航对应的窗口展示出来，并且更新导航条的状态。bootstrap也对此提供了相应的插件支持，基本思路上都差不太多。先说一下依赖的html结构和css代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
  &amp;lt;!-- Nav tabs --&amp;gt;
  &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot; role=&amp;quot;tablist&amp;quot;&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;active&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#home&amp;quot; aria-controls=&amp;quot;home&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Home
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#profile&amp;quot; aria-controls=&amp;quot;profile&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
   			 Profile
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#messages&amp;quot; aria-controls=&amp;quot;messages&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Messages
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li role=&amp;quot;presentation&amp;quot;&amp;gt;
    	&amp;lt;a href=&amp;quot;#settings&amp;quot; aria-controls=&amp;quot;settings&amp;quot; role=&amp;quot;tab&amp;quot; data-toggle=&amp;quot;tab&amp;quot;&amp;gt;
    		Settings
    	&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;!-- Tab panes --&amp;gt; 
  &amp;lt;div class=&amp;quot;tab-content&amp;quot;&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane active&amp;quot; id=&amp;quot;home&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;profile&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;messages&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div role=&amp;quot;tabpanel&amp;quot; class=&amp;quot;tab-pane&amp;quot; id=&amp;quot;settings&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体上分为两大块，一部分是导航，一部分是tab窗口，tab窗口的css比较简单，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tab-content &amp;gt; .tab-pane {
  display: none;
}
.tab-content &amp;gt; .active {
  display: block;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说白了只要控制&lt;code&gt;active&lt;/code&gt;类就能控制tab窗口的切换。比较复杂的是导航条的样式，基本款式有两种&lt;code&gt;nav-tabs&lt;/code&gt;和&lt;code&gt;nav-pills&lt;/code&gt;，这两个都可以配合&lt;code&gt;nav-justified&lt;/code&gt;类形成两端对齐的导航。其实这些样式层面的东西对于js代码没什么影响，我就说几个比较好玩的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs &amp;gt; li {
  float: left;
  margin-bottom: -1px;
}
.nav-tabs &amp;gt; li &amp;gt; a {
  margin-right: 2px;
  line-height: 1.42857143;
  border: 1px solid transparent;
  border-radius: 4px 4px 0 0;
}
.nav-tabs &amp;gt; li.active &amp;gt; a,
.nav-tabs &amp;gt; li.active &amp;gt; a:hover,
.nav-tabs &amp;gt; li.active &amp;gt; a:focus {
  color: #555;
  cursor: default;
  background-color: #fff;
  border: 1px solid #ddd;
  border-bottom-color: transparent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tab标签页我觉得是写的比较好的，尤其是对于导航条下面那条线的处理上。每一个标签项都是浮动的，显然会有清除浮动影响，没写在这里。那条线是写在整个导航条上的。那么如何实现 当前标签页没有下面那条线的？首先是利用&lt;code&gt;margin-bottom:-1px&lt;/code&gt;把每个标签项向下移动1px，然后每个标签项都有一个透明的1px边框，这时候标签项的下边框和导航条的下边框正好是重合的，由于颜色是透明的所以可以看得到导航条的边框。对于当前标签页，加了一个白色背景颜色，相当于是用背景色把导航边框色给盖住了。然而，为什么不用边框色盖住呢？非要写一个白色背景色，因为要处理&lt;code&gt;:hover&lt;/code&gt;和&lt;code&gt;:focus&lt;/code&gt;的情况。&lt;/p&gt;

&lt;p&gt;样式的东西就写这些，其实我觉得&lt;code&gt;nav-justified&lt;/code&gt;写得也很好，既实现了所有标签项占据100%空间，又能兼顾标签项内容的长度分配剩余空间，&lt;a href=&#34;http://stackoverflow.com/a/27846774&#34;&gt;stackoverflow上面有评论&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;说js部分了，利用data形式绑定事件以前已经说过了，然而我怀疑有没有必要整出&lt;code&gt;[data-toggle=&amp;quot;tab&amp;quot;]&lt;/code&gt;和&lt;code&gt;[data-toggle=&amp;quot;pill&amp;quot;]&lt;/code&gt;两个来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data(&#39;bs.tab&#39;)

	  if (!data) $this.data(&#39;bs.tab&#39;, (data = new Tab(this)))
	  if (typeof option == &#39;string&#39;) data[option]()
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和以往一样是把生成的对象挂到了data上，然后根据传入的参数做一些操作。在&lt;code&gt;Tab&lt;/code&gt;的原型上主要挂了两个方法&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;activate&lt;/code&gt; , &lt;code&gt;show&lt;/code&gt;方法主要的功能是判断要不要进行tab切换，切换的对象是谁。具体的切换是&lt;code&gt;activate&lt;/code&gt;方法实现的，这个方法相当于是对切换这个操作剥离出来，导航条标签的切换、tab窗口的切换都通过这个方法实现，这两个切换没有耦合在一起，这一点很不错。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;show&lt;/code&gt;方法里确定要展示的tab窗口是通过tab标签的&lt;code&gt;data-target&lt;/code&gt;或者&lt;code&gt;href&lt;/code&gt;实现的，弱弱的说一句，在bootstrap的插件里，有的是&lt;code&gt;href&lt;/code&gt;优先，有的是&lt;code&gt;data-target&lt;/code&gt;优先，不过正常人是不会两个都加上的。在&lt;code&gt;show&lt;/code&gt;方法里还触发了一些事件，相较于之前看过的几个插件，这里的事件复杂在有&lt;code&gt;relatedTarget&lt;/code&gt;的概念。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;activate&lt;/code&gt;方法中，首先获取当前活动的元素，然后判断是否要过渡。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var transition = callback
  &amp;amp;&amp;amp; $.support.transition
  &amp;amp;&amp;amp; ($active.length &amp;amp;&amp;amp; $active.hasClass(&#39;fade&#39;) || !!container.find(&#39;&amp;gt; .fade&#39;).length)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而我不太明白的是为啥一定要有callback才支持过渡。然后就是判断是否要过渡，如果要过渡的首先把当前展示的页面过渡、逐渐淡出，淡出完成后当前的移除&lt;code&gt;active&lt;/code&gt;类，target元素添加&lt;code&gt;active&lt;/code&gt;类，如果target元素需要过渡出来的话，还要先强制重绘一次，再添加&lt;code&gt;in&lt;/code&gt;这个类，否则会直接进入最终状态。如果不需要过渡直接从移除&lt;code&gt;active&lt;/code&gt;类开始执行。&lt;/p&gt;

&lt;p&gt;说实话，bootstrap的插件长的差不多，一开始觉得写法很独特，后来就习惯了，熟悉了写法之后其实插件的业务逻辑很好懂。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——collapse.js</title>
      <link>https://jiangshanmeta.github.io/post/bootstrap/collapse/</link>
      <pubDate>Fri, 08 Jul 2016 20:33:24 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/bootstrap/collapse/</guid>
      <description>&lt;p&gt;最近工作忙，好不容易闲下来身体又出bug了，好久没更新了。接着读bootstrap的代码，今天要说的是collapse.js。这个插件实现的展开与收缩效果。&lt;/p&gt;

&lt;p&gt;先看一下data-api&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).on(&#39;click.bs.collapse.data-api&#39;, &#39;[data-toggle=&amp;quot;collapse&amp;quot;]&#39;, function (e) {
	var $this   = $(this)

	if (!$this.attr(&#39;data-target&#39;)) e.preventDefault()

	var $target = getTargetFromTrigger($this)
	var data    = $target.data(&#39;bs.collapse&#39;)
	var option  = data ? &#39;toggle&#39; : $this.data()

	Plugin.call($target, option)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体绑定的方式和之前分析的alert、button差不多，都是利用事件委托机制。具体的回调函数比较复杂了。collapse.js设定了两种绑定展开收缩对象的形式，一种是通过a标签的&lt;code&gt;href&lt;/code&gt;属性，另一种是通过&lt;code&gt;data-target&lt;/code&gt;属性，并且还封装了一个小函数&lt;code&gt;getTargetFromTrigger&lt;/code&gt;找到对应的绑定元素。如果是通过&lt;code&gt;href&lt;/code&gt;属性指定展开收缩对象的话，需要阻止默认事件，至于阻止的是啥，还用我说嘛。然后的三行就写的比较巧妙了，先获取data上面保存的信息，然后如果之前保存过collapse的实例，给*option*赋值为&amp;rsquo;toggle&amp;rsquo;,如果没有，赋值为一个对象。为什么要返回一个data的对象？一开始我也没想明白，看到插件的具体内容才想明白为什么要加这个，因为这个插件还负责实现手风琴效果，手风琴效果总归需要一个包裹元素吧，这里的实现是通过&lt;code&gt;data-parent&lt;/code&gt;来决定这个包裹元素是谁。如果是最简单的展开收缩效果，option里面的只会有toggle，对于手风琴效果会对一个parent，针对这个parent有一些额外的操作。&lt;/p&gt;

&lt;p&gt;然后是Plugin的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data(&#39;bs.collapse&#39;)
	  var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == &#39;object&#39; &amp;amp;&amp;amp; option)

	  if (!data &amp;amp;&amp;amp; options.toggle &amp;amp;&amp;amp; /show|hide/.test(option)) options.toggle = false
	  if (!data) $this.data(&#39;bs.collapse&#39;, (data = new Collapse(this, options)))
	  if (typeof option == &#39;string&#39;) data[option]()
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bootstrap的插件基本上是按照一个模板出来的。在bootstrap插件里第一次见到使用&lt;code&gt;$.extend&lt;/code&gt;方法，使用过jquery的人应该了解这是合并对象用的，原生js的一个实现是&lt;code&gt;Object.assign&lt;/code&gt;，只是有点兼容问题。而且这里重新利用了&lt;strong&gt;toggle&lt;/strong&gt;属性，通过判断是否需要调用toggle方法，看Collapse构造函数就会明白这样会保证如果传入的不是&lt;code&gt;show&lt;/code&gt;或者&lt;code&gt;hide&lt;/code&gt;这两个字符串，就会&lt;strong&gt;toggle&lt;/strong&gt;一次。如果传入的是字符串，会调用相关方法。&lt;/p&gt;

&lt;p&gt;上面说的是写法上的巧妙之处，然而重点是这个展开收缩是如何实现的，在文档上有这么一句&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Collapse requires the transitions plugin to be included in your version of Bootstrap.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就是说展开收缩效果是通过CSS3过渡实现的，我曾经想过如果用纯CSS实现这种展开收缩效果，但是由于&lt;code&gt;height&lt;/code&gt;无法从&lt;code&gt;auto&lt;/code&gt;过渡到一个具体数字，所以只能用有点hack意味的方案，我最终采用的是过渡&lt;code&gt;transform&lt;/code&gt;的&lt;code&gt;scale&lt;/code&gt;，这样有个问题的别的元素会认为这个元素依然是占据原来的大小。bootstrap的解决方案利用了js。&lt;/p&gt;

&lt;p&gt;当调用&lt;code&gt;show&lt;/code&gt;方法的时候，先做一些隔离，保证此时操作的元素处于hide状态。这时收缩状态的元素含有一个类&lt;code&gt;collapse&lt;/code&gt;，对应内容是&lt;code&gt;display:none&lt;/code&gt;，然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.$element
  .removeClass(&#39;collapse&#39;)
  .addClass(&#39;collapsing&#39;)[dimension](0)
  .attr(&#39;aria-expanded&#39;, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除&lt;code&gt;collapse&lt;/code&gt;这个类，这时候元素理应正常显示，这里强行设定高度为0，等一下我再吐槽这个&lt;code&gt;dimension&lt;/code&gt;，顺便吐槽&lt;code&gt;collapsing&lt;/code&gt;这个类。现在这个需要展开的元素高度为0，我们需要确定最终高度，bootstrap的实现我觉得挺巧的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scrollSize = $.camelCase([&#39;scroll&#39;, dimension].join(&#39;-&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是利用scrollHeight来确定最终高度的，初始高度、最终高度有了，过渡的最基本的条件就有了。过渡完成后的回调其实也比较有意思&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var complete = function () {
  this.$element
    .removeClass(&#39;collapsing&#39;)
    .addClass(&#39;collapse in&#39;)[dimension](&#39;&#39;)
  this.transitioning = 0
  this.$element
    .trigger(&#39;shown.bs.collapse&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除了&lt;code&gt;collapsing&lt;/code&gt;这个类，添加&lt;code&gt;collapse&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;两个类，并且把高度设置为默认值。为什么要这么做？因为以后这个展开收缩区域可能会动态添加或者删除内容，此时写死高度就有些不合适了。&lt;/p&gt;

&lt;p&gt;对应的&lt;code&gt;hide&lt;/code&gt;方法基本过程类似，其实只要看明白一个另一个也就差不多了。说一下要说的几点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.$element[dimension](this.$element[dimension]())[0].offsetHeight
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前说过，无法实现、&lt;strong&gt;height&lt;/strong&gt;的从&lt;strong&gt;auto&lt;/strong&gt;到一个数值的过渡，我们需要获取元素的具体高度，这里还强行重绘了一次，保证把高度值从auto转换为具体的数值，之前&lt;code&gt;show&lt;/code&gt;方法里其实也强行重绘了一次，是在利用&lt;code&gt;scrollHeight&lt;/code&gt;获得高度的时候。其他的基本上就是&lt;code&gt;show&lt;/code&gt;方法的逆过程了。&lt;/p&gt;

&lt;p&gt;下面开始预告的吐槽&lt;/p&gt;

&lt;p&gt;在上面的解说中，我是直接把&lt;code&gt;dimension&lt;/code&gt;说成是&lt;code&gt;height&lt;/code&gt;，我们还是看代码把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collapse.prototype.dimension = function () {
	var hasWidth = this.$element.hasClass(&#39;width&#39;)
	return hasWidth ? &#39;width&#39; : &#39;height&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dimension就是上面几行代码的返回值，水平方向的展开收缩虽然不多见，但也总归是有，但是呢，你看你的控制过渡的类&lt;code&gt;collapsing&lt;/code&gt;的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  -webkit-transition-timing-function: ease;
       -o-transition-timing-function: ease;
          transition-timing-function: ease;
  -webkit-transition-duration: .35s;
       -o-transition-duration: .35s;
          transition-duration: .35s;
  -webkit-transition-property: height, visibility;
       -o-transition-property: height, visibility;
          transition-property: height, visibility;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你们写js的和写css的看来不是一个人啊，根本没实现对于宽度过渡的支持啊，你们。。。。&lt;/p&gt;

&lt;p&gt;这其实都是小事，我觉得一个让我很迷惑的问题是为啥&lt;code&gt;visibility&lt;/code&gt;这个属性也能过渡？于是&lt;a href=&#34;http://www.zhangxinxu.com/wordpress/2013/05/transition-visibility-show-hide/&#34;&gt;张鑫旭大神又解释过这个问题了&lt;/a&gt;。其中张鑫旭前辈提到了应用场景&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;举个例子，我们要实现淡入淡出效果，显然是需要改变透明度的，但是，元素即使透明度变成0，虽然肉眼看不见，但是，在页面上，元素还是可以点击，还是可以覆盖其他元素的，这显然是有问题的，我们最最希望的是在元素淡出动画结束后，元素可以自动隐藏！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人觉得他对&lt;code&gt;opacity:0;&lt;/code&gt;和&lt;code&gt;visibility:hidden&lt;/code&gt;的区别没有说清楚。这时候就要搬出&lt;a href=&#34;http://stackoverflow.com/a/273076&#34;&gt;stackoverflow上的回答&lt;/a&gt;。这两个都是不脱离文档流，但是前者依然响应事件，而后者不响应事件。不过回到这个插件里来，并没有用到&lt;code&gt;visibility&lt;/code&gt;的过渡。&lt;/p&gt;

&lt;p&gt;主体内容差不多就完了，关于手风琴效果的具体实现，以及其他的细节自己去看源码吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——button.js</title>
      <link>https://jiangshanmeta.github.io/post/bootstrap/button/</link>
      <pubDate>Sun, 26 Jun 2016 20:22:23 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/bootstrap/button/</guid>
      <description>&lt;p&gt;button.js我个人觉得是属于从一开始就没想明白要做什么。和其他的bootstrap的插件一样，button也能用data的形式调用插件，但是我真心没想明白使用data调用的有什么实际用途。反而我觉得手动调用的对我来说更有实际意义，所以这里只说&lt;a href=&#34;http://v3.bootcss.com/javascript/#buttons-stateful&#34;&gt;button.js改变状态的部分&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在web应用中免不了用户触发ajax请求，比如提交表单（实际项目中没有用表单的直接提交，而是使用了ajax提交表单），点击加载更多。在ajax过程中我们需要告诉用户正在进行中，需要等待。在实际项目中为了实现这一个需求我们使用了一个插件blockUI,可以自行百度一下，我觉得挺好用的。另一种方案是改变button的状态，把他标记为不可点击。&lt;/p&gt;

&lt;p&gt;整体形式是标准的bootstrap插件的形式，关于如何绑定方法，如何防冲突，这些都在 &lt;a href=&#34;http://jiangshanmeta.github.io/post/bootstrap/alert/&#34;&gt;bootstrap源码解读——alert.js&lt;/a&gt;中分析过了，没有必要去做过多的说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.button&#39;)
    var options = typeof option == &#39;object&#39; &amp;amp;&amp;amp; option

    if (!data) $this.data(&#39;bs.button&#39;, (data = new Button(this, options)))

    if (option == &#39;toggle&#39;) data.toggle()
    else if (option) data.setState(option)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和alert.js类似，这里也是采用data的形式进行缓存&lt;code&gt;Button&lt;/code&gt;实例，我们不需要去关心&lt;code&gt;toggle&lt;/code&gt;的实现，因为我连应用场景都没想到，我们只需关心调用&lt;code&gt;setState&lt;/code&gt;方法。setState传入的参数其实只有&lt;code&gt;loading&lt;/code&gt;和&lt;code&gt;reset&lt;/code&gt;是有效的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Button.prototype.setState = function (state) {
  var d    = &#39;disabled&#39;
  var $el  = this.$element
  var val  = $el.is(&#39;input&#39;) ? &#39;val&#39; : &#39;html&#39;
  var data = $el.data()

  state += &#39;Text&#39;

  if (data.resetText == null) $el.data(&#39;resetText&#39;, $el[val]())

  // push to event loop to allow forms to submit
  setTimeout($.proxy(function () {
    $el[val](data[state] == null ? this.options[state] : data[state])

    if (state == &#39;loadingText&#39;) {
      this.isLoading = true
      $el.addClass(d).attr(d, d)
    } else if (this.isLoading) {
      this.isLoading = false
      $el.removeClass(d).removeAttr(d)
    }
  }, this), 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读起来并不是很难懂，一个要注意的地方是&lt;code&gt;setTimeout&lt;/code&gt;，这个函数一方面会改变&lt;code&gt;this&lt;/code&gt;的指向，我以前也分析过&lt;a href=&#34;http://jiangshanmeta.github.io/post/jsthis/&#34;&gt;javascript的this坑&lt;/a&gt;，另一方面是定时器的原理，不是相隔多长时间后执行，而是相隔多长时间后加入任务队列，这个&lt;a href=&#34;http://jiangshanmeta.github.io/post/browser/&#34;&gt;我以前也提及过&lt;/a&gt;。另一个要注意的点是data的使用，利用data保存button中原来的内容就不说了，很常规的一个写法。比较有趣的是对于加载时显示内容的处理。文档上说加载时保存的信息保存在了&lt;code&gt;data-loading-text&lt;/code&gt;中，但是我们在代码中读取的时候是以&lt;code&gt;loadingText&lt;/code&gt;的形式读写，这就比较有意思了，一个中划线没了，然后一个大小写改变了。查了查MDN找到了答案：&lt;/p&gt;

&lt;p&gt;data-*,*可以被任何符合以下限制的the producton rule of xml names(xml的命名规则)代替：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;名字不能以xml开头，除此之外其他任何情形都可是使用这3个字母；&lt;/li&gt;
&lt;li&gt;名字不能含有分号；&lt;/li&gt;
&lt;li&gt;名字不能含有大写字母。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：HTMLElement.dataset是一个 StringMap。一个名叫data-test-value的自定义属性可以通过HTMLElment.dataset.testValue来访问，属性的名字中的中线(U+002D)被挨着它字母的大写字母代替了（驼峰命名）。&lt;/p&gt;

&lt;p&gt;自定义的data 属性名称转化成 DOMStringMap 的键值时会遵循下面的规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;前缀  data- 被去除(包括减号)；&lt;/li&gt;
&lt;li&gt;对于每个在ASCII小写字母 a到 z前面的减号 (U+002D)，减号会被去除，并且字母会转变成对应的大写字母。其他字符（包含其他减号）都不发生变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体链接: &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-data-*&#34;&gt;data-*&lt;/a&gt;,&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset&#34;&gt;dataset&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——alert.js</title>
      <link>https://jiangshanmeta.github.io/post/bootstrap/alert/</link>
      <pubDate>Thu, 23 Jun 2016 21:59:53 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/bootstrap/alert/</guid>
      <description>&lt;p&gt;之前已经&lt;a href=&#34;http://jiangshanmeta.github.io/post/bootstrap/transition/&#34;&gt;解读过bootstrap的transition.js&lt;/a&gt;，今天继续解读alert插件。&lt;/p&gt;

&lt;p&gt;bootstrap的alert插件从功能上看并不复杂，就是让一个警告框消失，所以重要的不是这个功能。重要的是bootstrap如何通过data属性使用插件的，以及bootstrap的插件是如何暴露方法和事件的。&lt;/p&gt;

&lt;p&gt;先解答第一个问题，直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dismiss = &#39;[data-dismiss=&amp;quot;alert&amp;quot;]&#39;
$(document).on(&#39;click.bs.alert.data-api&#39;, dismiss, Alert.prototype.close)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用事件委托，监听&lt;code&gt;document&lt;/code&gt;的click事件，然后子元素的选择器是&lt;code&gt;[data-dismiss=&amp;quot;alert&amp;quot;]&lt;/code&gt;。第一个问题回答完毕。利用data的形式使用bootstrap的插件是官方推荐的，当然也可以手动调用，虽然我觉得这样的需求很少。手动调用需要了解方法是如何暴露的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data(&#39;bs.alert&#39;)

	  if (!data) $this.data(&#39;bs.alert&#39;, (data = new Alert(this)))
	  if (typeof option == &#39;string&#39;) data[option].call($this)
	})
}

$.fn.alert             = Plugin
$.fn.alert.Constructor = Alert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果写过jquery插件，对这种形式应该很熟悉，在jquery的prototype上添加了alert方法，这样就暴露了&lt;code&gt;alert&lt;/code&gt;方法。手动调用&lt;code&gt;alert&lt;/code&gt;方法的时候，首先会确保data上面挂着一个&lt;code&gt;Alert&lt;/code&gt;实例，挂在data上面是为了缓存这么一个实例。如果传入了参数，则调用&lt;code&gt;Alert&lt;/code&gt;对应方法。个人认为不传参数的情况其实用的不多，传参手动关闭警告框有实际应用价值。以前自己写jq插件的时候，对于面向对象的理解不是很到位，对于jq插件的写法了解的也少，这种写法值得学习。&lt;/p&gt;

&lt;p&gt;看一下Alert构造函数的具体内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Alert   = function (el) {
$(el).on(&#39;click&#39;, dismiss, this.close)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和上面在&lt;code&gt;document&lt;/code&gt;上做的差不多，都是监听click事件做事件委托。&lt;/p&gt;

&lt;p&gt;Alert的原型上有具体的&lt;code&gt;close&lt;/code&gt;方法，在这个方法里定义了两个事件&lt;code&gt;close.bs.alert&lt;/code&gt; 和&lt;code&gt;closed.bs.alert&lt;/code&gt;，看一下源代码吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Alert.prototype.close = function (e) {
	var $this    = $(this)

	var selector = $this.attr(&#39;data-target&#39;)
	if (!selector) {
	  selector = $this.attr(&#39;href&#39;)
	  selector = selector &amp;amp;&amp;amp; selector.replace(/.*(?=#[^\s]*$)/, &#39;&#39;) 
	}
	var $parent = $(selector)
	if (e) e.preventDefault()
	if (!$parent.length) {
	  $parent = $this.closest(&#39;.alert&#39;)
	}

	$parent.trigger(e = $.Event(&#39;close.bs.alert&#39;))

	if (e.isDefaultPrevented()) return

	$parent.removeClass(&#39;in&#39;)

	function removeElement() {
	  // detach from parent, fire event then clean up data
	  $parent.detach().trigger(&#39;closed.bs.alert&#39;).remove()
	}

	$.support.transition &amp;amp;&amp;amp; $parent.hasClass(&#39;fade&#39;) ?
	  $parent
	    .one(&#39;bsTransitionEnd&#39;, removeElement)
	    .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	  removeElement()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先做的是寻找关闭时要移除的元素，查找的优先顺序是 data-target、href、最近的含有&lt;code&gt;alert&lt;/code&gt;类的元素。在官方文档里其实并没有提及前两种情况，事实上第三种情况更接近实际需求。对于警告框的删除，一种是有过渡效果的，一种是没有过渡效果的。有过渡效果的情况警告框含有&lt;code&gt;fade&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;两个类并支持过渡，可以在相关css文件看一下代码，就是实现透明度从1过渡到0 。没过渡效果的情况可能是根本不支持css3过渡，也可能是没有&lt;code&gt;fade&lt;/code&gt;这个类。有过渡效果的是在过渡完成后删除警告框，没有过渡的直接删除了，无过渡代码里没有尝试对淡出效果进行模拟。两个事件分别是在移除前和移除后触发的，注意&lt;code&gt;removeElement&lt;/code&gt;的具体实现，先是detach，然后触发事件，最后remove，说实话这两个方法的区别我还体会不深，求大神指教。在实现过渡时使用了transition.js里提供的emulateTransitionEnd，为的是保证回调能够顺利执行。&lt;/p&gt;

&lt;p&gt;最后是防冲突，自己看源码吧，写的挺巧妙的，旧的函数和新的函数都能很好地得到保存。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bootstrap源码解读——transition.js</title>
      <link>https://jiangshanmeta.github.io/post/bootstrap/transition/</link>
      <pubDate>Wed, 22 Jun 2016 19:07:30 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/bootstrap/transition/</guid>
      <description>&lt;p&gt;bootstrap是一个出名的前端框架，它预制了一些常见的js插件。从头开始解读吧。&lt;/p&gt;

&lt;p&gt;这里要介绍的是transition.js，它的作用是对css3的过渡的兼容处理。&lt;/p&gt;

&lt;p&gt;立即执行的匿名函数就不说了，算是基本常识了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function transitionEnd() {
	var el = document.createElement(&#39;bootstrap&#39;)

	var transEndEventNames = {
	  WebkitTransition : &#39;webkitTransitionEnd&#39;,
	  MozTransition    : &#39;transitionend&#39;,
	  OTransition      : &#39;oTransitionEnd otransitionend&#39;,
	  transition       : &#39;transitionend&#39;
	}

	for (var name in transEndEventNames) {
	  if (el.style[name] !== undefined) {
	    return { end: transEndEventNames[name] }
	  }
	}

	return false 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一段是对transitionend事件做兼容，如果浏览器支持各种形式的transitionend，就以对象的形式返回兼容后的结果，否则返回false，表明不支持transitionend事件，另一层意思就是不支持css3过渡。&lt;/p&gt;

&lt;p&gt;之前我收集过一个类似功能的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function whichTransitionEvent(){  
    var t;  
    var el = document.createElement(&#39;p&#39;);  
    var transitions = {  
      &#39;transition&#39;:&#39;transitionend&#39;,  
      &#39;OTransition&#39;:&#39;oTransitionEnd&#39;,  
      &#39;MozTransition&#39;:&#39;mozTransitionEnd&#39;,  
      &#39;WebkitTransition&#39;:&#39;webkitTransitionEnd&#39;,  
      &#39;MsTransition&#39;:&#39;msTransitionEnd&#39;  
    }  
    for(t in transitions){  
        if( el.style[t] !== undefined ){  
            return transitions[t];  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是调用上面那个函数，并且为transitionend起了一个别名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function () {
$.support.transition = transitionEnd()

if (!$.support.transition) return

$.event.special.bsTransitionEnd = {
  bindType: $.support.transition.end,
  delegateType: $.support.transition.end,
  handle: function (e) {
    if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
  }
}
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里把最终的transitionend事件挂到了$.support.transition上，相当于一个缓存。然后是一段让我很纠结的代码，$.event.special.bsTransitionEnd是干啥的的？搜索了一下中文文章发现虽然有提的但是完全不靠谱（这么不靠谱的文章竟然有一堆转载），然后我就在&lt;a href=&#34;http://stackoverflow.com/questions/29861597/what-is-jquery-event-special/29867037#29867037&#34;&gt;stackoverflow上找到了答案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它的意思是这里的bsTransitionEnd相当于兼容后的transitionend事件的别名。为什么要去一个别名而不是直接使用兼容后的transitionend呢？因为怕你我手抖移除transitionend事件的时候不传具体的回调而是直接移除整个事件然后bootstrap插件的回调也一并移除然后报bug。算是为了代码的健壮性吧。&lt;/p&gt;

&lt;p&gt;还有一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.emulateTransitionEnd = function (duration) {
	var called = false
	var $el = this
	$(this).one(&#39;bsTransitionEnd&#39;, function () { called = true })
	var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	setTimeout(callback, duration)
	return this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$.fn.emulateTransitionEnd，看这个形式是直接挂到了jquery的prototype上了。看函数名猜测这一段代码是为了模拟transitionend事件的。不理解作者想干啥，但是&lt;a href=&#34;https://blog.alexmaccaw.com/css-transitions&#34;&gt;源码中给了一个连接&lt;/a&gt;，于是我就找来这篇博客看，原作者是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Be aware that sometimes this event doesn’t fire, usually in the case when properties don’t change or a paint isn’t triggered. To ensure we always get a callback, let’s set a timeout that’ll trigger the event manually.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换句话说作者是为了保证即使没有过渡也要触发transitionend事件保证相应的回调能够执行。其实我很怀疑为什么要这么做，毕竟这种情况下应该测试会报bug。&lt;/p&gt;

&lt;p&gt;具体实现上called变量保存的是transitionend是否被触发，这个变量的存在是为了保证transitionend只触发一次。可能触发多次的情况一个是transition多个属性会触发多个transitionend事件，另一个是真的transitionend事件已经触发，不需要模拟transitionend。一些具体的细节上可以结合setTimeout以及jquery的相关内容理解。突然想到之前写的&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/org/h5page/h5page.html&#34;&gt;h5页面&lt;/a&gt;里面也是监听了transitionend事件，可以参照这个思路改一改。&lt;/p&gt;

&lt;p&gt;顺便提一句，上面那篇文章提到了强制重绘，有一句话我觉得很好&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This will work in most browsers, but I’ve had occasions in Android where this hasn’t been enough. The alternative is to either use timeouts, or by toggling a class name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就在上个周我就遇到了这个问题，强制重绘在pc上测试没问题，在微信内置浏览器上就报bug，最终解决方案也是使用定时器，&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/lottery/index.html&#34;&gt;实现的代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;transition.js内容不多，就只有三块，但是却是bootstap js插件非常重要的一环，后面只要用到css过渡的插件都依赖transition.js。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>百度Touch.js代码解读</title>
      <link>https://jiangshanmeta.github.io/post/js/touchjs/</link>
      <pubDate>Mon, 06 Jun 2016 20:46:09 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/touchjs/</guid>
      <description>

&lt;p&gt;在移动端各种手势事件很常见，然而不幸的是原生的js只提供了touchstart、touchmove、touchend、touchcancel这么几个事件的。所以我们需要手势库帮助我们判断手势。&lt;a href=&#34;https://github.com/Clouda-team/touch.code.baidu.com&#34;&gt;百度的touch&lt;/a&gt;是其中一个例子。之所以选择它是因为在之前的hammer我连文档都读不下去，中文文档实在是太有诱惑力了。然而hammer推荐的比例挺高的，还是抽空去看看吧。&lt;/p&gt;

&lt;p&gt;touch.js主要分为以下几块，第一个是工具函数，第二个是底层事件代理，第三个是手势判断。虽然这是一个手势库，但是自己资历尚浅，没有从具体的手势判断中读出多少东西，所以主要说一下前两个部分。&lt;/p&gt;

&lt;p&gt;先看一下封装的一些工具函数，代码中把工具函数封装到了&lt;code&gt;utils&lt;/code&gt;这个对象中。&lt;/p&gt;

&lt;h2 id=&#34;工具函数:8c3dfd5f7a431f6dbb28cd40ffd93e79&#34;&gt;工具函数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;utils.PCevts = {
    &#39;touchstart&#39;: &#39;mousedown&#39;,
    &#39;touchmove&#39;: &#39;mousemove&#39;,
    &#39;touchend&#39;: &#39;mouseup&#39;,
    &#39;touchcancel&#39;: &#39;mouseout&#39;
};
utils.hasTouch = (&#39;ontouchstart&#39; in window);
utils.getPCevts = function(evt) {
    return this.PCevts[evt] || evt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这几个函数是为了兼容PC的，&lt;code&gt;&#39;ontouchstart&#39; in window&lt;/code&gt;是用来检测是否有touch事件的，进而判断是移动端还是pc端，这个写法其实挺常见的，而PCevts相当于是一个兼容PC事件的config，getPCevts这一工具函数会获得pc对应事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.getType = function(obj) {
    return Object.prototype.toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个工具函数是用来判断变量类型的，这是js的一个很坑的地方，最简单的&lt;code&gt;typeof&lt;/code&gt;关键字只能判断基本类型，引用类型没法区别。&lt;code&gt;Object.prototype.toString.call(obj)&lt;/code&gt;返回的是一个形如&lt;code&gt;[object Number]&lt;/code&gt;的字符串，后面的正则是用来匹配字符串中的&lt;code&gt;Number&lt;/code&gt;这一区域的，并将其小写化。这一个方法可以用来判断基本类型和引用类型。我见过的类似的实现不是使用正则而是使用截取字符串的方法，其实大同小异，都是对字符串进行处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.matchSelector = function(target, selector) {
    return target.webkitMatchesSelector(selector);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;a href=&#34;http://caniuse.com/#search=matchess&#34;&gt;can I use&lt;/a&gt;查到的兼容性来看兼容性问题还勉强能接受，然而touch是大约两年前写的。这里的&lt;code&gt;webkitMatchesSelector&lt;/code&gt;只考虑了webkit内核，根据&lt;a href=&#34;https://dom.spec.whatwg.org/#dom-element-matches&#34;&gt;文档的说法&lt;/a&gt;，这个方法只是历史遗留下来，是&lt;code&gt;matches&lt;/code&gt;方法的等价品。&lt;/p&gt;

&lt;p&gt;如果从现在的角度来看应该这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.matchSelector = function(target, selector) {
    if(target.matches){
        return target.matches(selector);
    }else if(target.webkitMatchesSelector){
        return target.webkitMatchesSelector(selector);
    }else if(target.msMatchesSelector){
        return target.msMatchesSelector(selector);
    }
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chrome浏览器没问题，但是安卓浏览器，IE，还有万恶的微信内置浏览器都要兼容一下。这个方法以前也知道，但是没有用过，通常都是判断是否满足某个class。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.forceReflow = function() {
    var tempDivID = &amp;quot;reflowDivBlock&amp;quot;;
    var domTreeOpDiv = document.getElementById(tempDivID);
    if (!domTreeOpDiv) {
        domTreeOpDiv = document.createElement(&amp;quot;div&amp;quot;);
        domTreeOpDiv.id = tempDivID;
        document.body.appendChild(domTreeOpDiv);
    }
    var parentNode = domTreeOpDiv.parentNode;
    var nextSibling = domTreeOpDiv.nextSibling;
    parentNode.removeChild(domTreeOpDiv);
    parentNode.insertBefore(domTreeOpDiv, nextSibling);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看名字也能看的出来是用来强制重绘的，重绘的原理是一个没内容的空div，先移除，再插回到原来的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.simpleClone = function(obj) {
    return Object.create(obj);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原型式继承，实现对obj的浅复制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.getPosOfEvent = function(ev) {
    if (this.hasTouch) {
        var posi = [];
        var src = null;

        for (var t = 0, len = ev.touches.length; t &amp;lt; len; t++) {
            src = ev.touches[t];
            posi.push({
                x: src.pageX,
                y: src.pageY
            });
        }
        return posi;
    } else {
        return [{
            x: ev.pageX,
            y: ev.pageY
        }];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个工具函数的作用是获得事件的坐标，并存在一个array中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;utils.getXYByElement = function(el) {
    var left = 0,
        top = 0;

    while (el.offsetParent) {
        left += el.offsetLeft;
        top += el.offsetTop;
        el = el.offsetParent;
    }
    return {
        left: left,
        top: top
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法返回了元素相对于页面的位置。具体内容可以参见&lt;strong&gt;《JavaScript 高级程序设计（第三版）》&lt;/strong&gt;第十二章的有关内容&lt;/p&gt;

&lt;p&gt;还有几个工具函数是关于数学计算的，以及判断事件类型的，没什么太大提及的必要。&lt;/p&gt;

&lt;h2 id=&#34;整体结构及手势判断:8c3dfd5f7a431f6dbb28cd40ffd93e79&#34;&gt;整体结构及手势判断&lt;/h2&gt;

&lt;p&gt;曾经我在写一个h5页面页面之间切换的js的时候，尝试着写手势判断，但是我写的太笨了。我当时是在element上绑定了touchstart、touchmove、touchend几个事件，在我自己的应用场景下没什么问题，因为最终我只是绑定在了document这一个元素之上。但是如果要绑定手势事件的元素特别多，就有性能问题了。touch的处理就比较巧妙，它只在document上绑定了touchstart、touchmove、touchend、touchcancel几个事件，然后利用&lt;code&gt;event.target&lt;/code&gt;获取触发事件的元素，在相应元素上触发手势事件。道理大家都懂，只是别人用的巧啊。&lt;/p&gt;

&lt;p&gt;整体结构的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(root, factory) {
    if (typeof define === &#39;function&#39; &amp;amp;&amp;amp; (define.amd || define.cmd)) {
        define(factory); //Register as a module.
    } else {
        root.touch = factory();
    }
}(this, function() {

    function init(){
        var mouseEvents = &#39;mouseup mousedown mousemove mouseout&#39;,
            touchEvents = &#39;touchstart touchmove touchend touchcancel&#39;;
        var bindingEvents = utils.hasTouch ? touchEvents : mouseEvents;

        bindingEvents.split(&amp;quot; &amp;quot;).forEach(function(evt) {
            document.addEventListener(evt, handlerOriginEvent, false);
        });
    }
    init();
    var exports = {};

    exports.on = exports.bind = exports.live = _on;
    exports.off = exports.unbind = exports.die = _off;
    exports.config = config;
    exports.trigger = _dispatch;

    return exports;

}))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体上是一个匿名函数自执行。一开始判断define是否为函数，如果是则注册为模块，如果不是则向window对象上添加一个全局变量touch，touch的内容是返回的exports，在文档里看到的on、off、config、trigger就是出自这里。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init函数&lt;/code&gt; 首先判断环境是移动环境还是PC环境，据此绑定事件。绑定事件到&lt;code&gt;document&lt;/code&gt;上，具体的回调函数是&lt;code&gt;handlerOriginEvent&lt;/code&gt;，在这个函数内部根据具体条件调用封装在&lt;code&gt;gesture&lt;/code&gt;里的方法，算是对手势事件的整体掌控+分流吧。在gesture内部根据条件在&lt;code&gt;event.target&lt;/code&gt;上触发手势事件。&lt;/p&gt;

&lt;p&gt;具体的手势判断过于复杂，我也没读出太多的东西出来，等以后理解深入了再说吧。&lt;/p&gt;

&lt;h2 id=&#34;底层事件处理:8c3dfd5f7a431f6dbb28cd40ffd93e79&#34;&gt;底层事件处理&lt;/h2&gt;

&lt;p&gt;底层事件处理是判断手势的基础，也是暴露给开发者的几个接口&lt;code&gt;on&lt;/code&gt;,&lt;code&gt;off&lt;/code&gt;,&lt;code&gt;trigger&lt;/code&gt;的基础。事实上只要能够理解底层事件是如何处理的，就自然明白那几个暴露的接口是如何写的了。&lt;/p&gt;

&lt;p&gt;作者封装了一个&lt;code&gt;engine&lt;/code&gt;，进行了对事件的底层处理。
基本结构是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var engine = {
	proxyid: 0,
    proxies: [],
    trigger: function(el, evt, detail) {

	},
	bind: function(el, evt, handler) {

	},
	unbind: function(el, evt, handler) {

	},
	delegate: function(el, evt, sel, handler) {

	},
	undelegate: function(el, evt, sel, handler) {

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我向来喜欢手动代理事件，所以后两个方法直接没用过，也没有什么想用的欲望。主要讲前三个方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trigger: function(el, evt, detail) {

    detail = detail || {};
    var e, opt = {
            bubbles: true,
            cancelable: true,
            detail: detail
        };

    try {
        if (typeof CustomEvent !== &#39;undefined&#39;) {
            e = new CustomEvent(evt, opt);
            if (el) {
                el.dispatchEvent(e);
            }
        } else {
            e = document.createEvent(&amp;quot;CustomEvent&amp;quot;);
            e.initCustomEvent(evt, true, true, detail);
            if (el) {
                el.dispatchEvent(e);
            }
        }
    } catch (ex) {
        console.warn(&amp;quot;Touch.js is not supported by environment.&amp;quot;);
    }
},

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器内置的事件类型数量有限，所幸允许我们自定义事件，这也是我们能够写手势库的前提。&lt;/p&gt;

&lt;p&gt;我曾经封过一个类似的小函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var triggerEvent = function (el, eventName, detail) {
    var event = document.createEvent(&amp;quot;CustomEvent&amp;quot;);
    event.initCustomEvent(eventName, true, true, detail);
    if(typeof detail == &amp;quot;object&amp;quot;){
    	for( k in detail){
    		if(detail.hasOwnProperty(k)){
    			event[k]=detail[k]
    		}
    	}
    }
    el.dispatchEvent(event);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本思路大差不差，只是这里为了模仿jQuery里的event将detail里的内容都挂到了event上面。在touch.js里面也有类似的操作，是在绑定事件里面，稍后就会提到。看到这里基本就已经把相关的&lt;code&gt;_dispatch&lt;/code&gt;函数给讲完了。说实话，我看到的资料里没有讲到过&lt;code&gt;new CustomEvent(evt, opt)&lt;/code&gt;,只有其中的&lt;code&gt;document.createEvent(&amp;quot;CustomEvent&amp;quot;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后是绑定事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind: function(el, evt, handler) {
    el.listeners = el.listeners || {};
    if (!el.listeners[evt]) {
        el.listeners[evt] = [handler];
    } else {
        el.listeners[evt].push(handler);
    }
    var proxy = function(e) {
        if (utils.env.ios7) {
            utils.forceReflow();
        }
        e.originEvent = e;
        for (var p in e.detail) {
            if (p !== &#39;type&#39;) {
                e[p] = e.detail[p];
            }
        }
        e.startRotate = function() {
            __rotation_single_finger = true;
        };
        
        var returnValue = handler.call(e.target, e);
        if (typeof returnValue !== &amp;quot;undefined&amp;quot; &amp;amp;&amp;amp; !returnValue) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    handler.proxy = handler.proxy || {};
    if (!handler.proxy[evt]) {
        handler.proxy[evt] = [this.proxyid++];
    } else {
        handler.proxy[evt].push(this.proxyid++);
    }
    this.proxies.push(proxy);
    if (el.addEventListener) {
        el.addEventListener(evt, proxy, false);
    }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实我觉得这是整个touch.js里最关键的一个方法。&lt;/p&gt;

&lt;p&gt;我以前尝试写的时候直接在元素上绑定了相应的回调函数，但是touch给这个回调函数包裹了一层代理，在这个代理内部调用了对应的回调函数。element身上绑定的不是原来的回调函数，而是这一层代理。这样做有什么好处呢？一个是改写event对象。上面提及的我封装的&lt;code&gt;triggerEvent&lt;/code&gt;也做了类似的事情。这里作者把&lt;code&gt;detail&lt;/code&gt;对象上的东西挂到了&lt;code&gt;event&lt;/code&gt;对象上，这也是为什么文档里提及的&lt;code&gt;event&lt;/code&gt;对象上新增的属性的来源。在jQuery也有类似的改写event对象，原理目测大同小异。另一方面做一些兼容，这里判断是否是iOS7然后强制重绘了，不知道hack的是什么。看库有时候就这样，完全不清楚作者想hack什么地方。&lt;/p&gt;

&lt;p&gt;具体调用原始回调函数是使用&lt;code&gt;call&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var returnValue = handler.call(e.target, e);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作者还对调用原始回调的返回值做了处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (typeof returnValue !== &amp;quot;undefined&amp;quot; &amp;amp;&amp;amp; !returnValue) {
    e.stopPropagation();
    e.preventDefault();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我认为作者考虑到有人喜欢用&lt;code&gt;return false&lt;/code&gt;阻止默认事件和阻止事件冒泡。然后手动做了这两个操作。然而我不太明白的是判断的写法，直接判断返回值是否为&lt;code&gt;false&lt;/code&gt;不行吗？不知道作者还在考虑什么。&lt;/p&gt;

&lt;p&gt;proxyid和proxies这两个是为了接触绑定而存在的，这是因为实际绑定的回调不是原来的回调，我们要解除事件绑定需要解除的是绑定的代理事件，明确这一点就知道他的解除绑定是如何写的了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript的this坑</title>
      <link>https://jiangshanmeta.github.io/post/js/jsthis/</link>
      <pubDate>Thu, 02 Jun 2016 21:36:26 +0800</pubDate>
      
      <guid>https://jiangshanmeta.github.io/post/js/jsthis/</guid>
      <description>&lt;p&gt;JavaScript有许多坑，一个典型的代表就是this，动不动this的指向就变了。&lt;/p&gt;

&lt;p&gt;我也不想扯太多理论性的东西，那些是属于看着明白看完就忘的。我想干脆找个例子去说一下吧。今天在某个前端群里看到有人问相关问题。干脆就借用别人遇到的问题说一下吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/right.png&#34; alt=&#34;最原始的代码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是最原始的代码。目测是在一个构造函数里截取的一段。这张图里的this我想大家都很明白，而在回调函数里，出现的不是this，而是_this,目测是对上面this的保存。因为在回调里，this已经指向了ul_wrap，和外面的this不一样了。&lt;/p&gt;

&lt;p&gt;然后群里的人想改这段代码称为如下的样子&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/wrong.png&#34; alt=&#34;想要改成的代码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是报错信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/error.png&#34; alt=&#34;报错信息&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是里面提到的几个回调的具体实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/prototype.png&#34; alt=&#34;prototype&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看报错信息是出在 touchMove 和touchEnd两个内部对move方法的调用上。
那么，目测应该有一段是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UcanSlide.prototype.move=function(){
	//do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那就很明确问题在哪里了。修改代码之后，其实就相当于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.ul_wrap.addEventListener(&amp;quot;touchmove&amp;quot;,function(e){
	e.preventDefault();
	this.autoScroll = false;
	this.dirX+=e.targetTouches[0].clientX-this.startX;
	this.startX=e.targetTouches[0].clientX;
	this.move();
},false);
this.ul_wrap.addEventListener(&amp;quot;touchend&amp;quot;,function(e){
	var _this = this;
	this.autoScroll = true;
	this.setTime = setInterval(function(){
		_this.move();
	},_this.scrollSpeed)
},false)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写就看的明白多了。现在回调内部的this指的是ul_wrap，而不是外面的this，而move方法是在外面的this上的，而不是ul_wrap上的，所以内部调用move方法相当于调用ul_wrap的move方法，显然会报错。&lt;/p&gt;

&lt;p&gt;还有值得一提的是在touchend的回调里先是缓存了当前的this，因为在setInterval的回调里this也飘了，指向了window。&lt;/p&gt;

&lt;p&gt;js的this坑其实也不算什么坑，熟悉了就好了。&lt;/p&gt;

&lt;p&gt;//话说我的表达能力还是too young啊&lt;/p&gt;

&lt;p&gt;//update 2016/6/3
于是今天的项目中就用到了缓存this&lt;/p&gt;

&lt;p&gt;update 2016/08/16&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/this/annoythis.png&#34; alt=&#34;又一个this坑&#34; /&gt;&lt;/p&gt;

&lt;p&gt;又有一个小朋友问我this的问题了，这真的是个坑。上面是她发给我的代码。首先让我吐槽一下这缩进风格，这已经不是tab党和空格党之间的战争了。这段代码看起来应该就是写着自己玩的，那个小朋友说alert弹出来的结果是 &lt;code&gt;[object Window]&lt;/code&gt;。顺着代码看是调用getInfo方法，这个方法里面有个立即执行的匿名函数，getInfo返回的是立即执行的匿名函数返回的结果。匿名函数中有个this，这里的this不是她所写的对象&lt;code&gt;myObject&lt;/code&gt;，而是指向&lt;code&gt;window&lt;/code&gt;，所以toString的结果是&lt;code&gt;[object Window]&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>