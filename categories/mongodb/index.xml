<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mongodb on jsmeta</title>
    <link>http://jiangshanmeta.github.io/categories/mongodb/</link>
    <description>Recent content in Mongodb on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Oct 2016 20:20:18 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/categories/mongodb/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>mongodb的复杂查询和聚合</title>
      <link>http://jiangshanmeta.github.io/post/mongodb/aggregate/</link>
      <pubDate>Sun, 23 Oct 2016 20:20:18 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/mongodb/aggregate/</guid>
      <description>

&lt;p&gt;之前&lt;a href=&#34;http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/&#34;&gt;总结过mongodb常用的增删查改&lt;/a&gt;，随着使用的深入自己的工作不在局限在简单地增删查改上，还处理一部分的统计性工作。统计所需要的查询条件就比较复杂了，而mongodb的聚合又是mongodb的一个很大的话题了。这里算是对工作中遇到的一些情况进行总结吧。因为平时都是通过php操作数据库，所以下面的代码都是php，不过并不影响我想表达的。&lt;/p&gt;

&lt;h2 id=&#34;1-限制数组长度查询:233b6dd901ca06898e3895bff0f956d4&#34;&gt;1.限制数组长度查询&lt;/h2&gt;

&lt;p&gt;mongodb可以存储数组，我遇到的一个需求是筛选出数组长度大于某个值的。首先想到的是使用&lt;code&gt;$size&lt;/code&gt;，但是&lt;code&gt;$size&lt;/code&gt;不支持&lt;code&gt;$gt&lt;/code&gt;这样的操作，仅支持等于某个长度。&lt;/p&gt;

&lt;p&gt;最终的解决方案是查询数组中第N个元素是否存在，比如限制field字段数组中至少有一个元素，则where条件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;fiele.0&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-addtoset在聚合中的使用:233b6dd901ca06898e3895bff0f956d4&#34;&gt;2.$addToSet在聚合中的使用&lt;/h2&gt;

&lt;p&gt;需求场景是这样的：在流水表里有一些数据是进货记录，每条这样的数据都包含店铺id和供应商id，现在需要拿出每家供应商所供货的店铺。暴力的做法是拿出数据来在php处理（写起来并不复杂），然而用聚合实现更简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
	&#39;$match&#39;=&amp;gt;[
		&#39;typ&#39;=&amp;gt;1
	]
];
$group = [
	&#39;$group&#39;=&amp;gt;[
		&#39;_id&#39;=&amp;gt;&#39;$supplier&#39;,
		&#39;orgs&#39;=&amp;gt;[&#39;$addToSet&#39;=&amp;gt;&#39;$orgId&#39;]
	]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bPeijianFlow&#39;,[$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是实现代码，首先在&lt;code&gt;bPeijianFlow&lt;/code&gt;这张表中只有typ为1的才是进货记录，据此筛选，然后我们要根据供应商id进行聚合，所以聚合中的&lt;code&gt;_id&lt;/code&gt;是&lt;code&gt;$supplier&lt;/code&gt;，因为一个供应商对一家店可能多次供货，但我们仅需保留一次门店id，所以采用&lt;code&gt;$addToSet&lt;/code&gt;而不是&lt;code&gt;$push&lt;/code&gt;，把每家供应商供货的店铺id保存到&lt;code&gt;orgs&lt;/code&gt;这个数组中。&lt;/p&gt;

&lt;h2 id=&#34;3-根据多个字段进行聚合:233b6dd901ca06898e3895bff0f956d4&#34;&gt;3.根据多个字段进行聚合&lt;/h2&gt;

&lt;p&gt;上面的聚合仅仅是根据供应商一个字段进行，我遇到的场景是这样的：有一张用户考试的表，存储着用户id，考试类型，需要根据用户和考试类型进行聚合，拿到每个用户每个考试类型通过（通过是在筛选处理的）的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$match = array(
    &#39;$match&#39;=&amp;gt;[
        &#39;status&#39;=&amp;gt;2,
    ],
);
$group = array(
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;array(&#39;adminuserId&#39;=&amp;gt;&#39;$adminuserId&#39;,&#39;typ&#39;=&amp;gt;&#39;$typ&#39;),
        &#39;count&#39;=&amp;gt;array(&#39;$sum&#39;=&amp;gt;1),
        &#39;name&#39;=&amp;gt;array(&#39;$first&#39;=&amp;gt;&#39;$uName&#39;),
        &#39;orgId&#39;=&amp;gt;array(&#39;$first&#39;=&amp;gt;&#39;$orgId&#39;),
    ]

);

$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;aExam&#39;,[$match,$group]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是筛选通过的考试，用status为2表示，然后是进行聚合，聚合是根据&lt;code&gt;adminuserId&lt;/code&gt;和&lt;code&gt;typ&lt;/code&gt;两个字段来的，所以&lt;code&gt;_id&lt;/code&gt;是一个array，而不是上面那个聚合的string，&lt;code&gt;&#39;count&#39;=&amp;gt;array(&#39;$sum&#39;=&amp;gt;1),&lt;/code&gt;是用来统计数量的，剩下的两行是用来做展示数据用的。&lt;/p&gt;

&lt;h2 id=&#34;4-聚合中的管线化操作:233b6dd901ca06898e3895bff0f956d4&#34;&gt;4.聚合中的管线化操作&lt;/h2&gt;

&lt;p&gt;目前遇到的大部分业务场景下的聚合都是两步：先筛选，再聚合。上面两个例子都是这个模式。mongodb的聚合其实是有一个管线化操作，即上一步的输出作为下一步的输入，在上面例子中是match的输出作为group的输入。
复杂场景所需要的管线化操作就比较多了，先举两个实际场景&lt;/p&gt;

&lt;p&gt;第一个场景是这样的，有一张订单表，一个用户可以有多个订单，现在需要统计用户订单数量分布，即我需要统计一张订单的用户有多少、两张订单的用户有多少&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;crmId&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true],
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;50],
    ]
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$crmId&#39;,
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$group2 = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$count&#39;,
        &#39;sum&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$sort = [
    &#39;$sort&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;-1,
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bBook&#39;, [$match,$group,$group2,$sort]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是实现代码，match条件不说了，第一个group是根据用户(crmId)进行聚合，得到每个用户拥有的订单数量，然后再一次聚合以订单数量为&lt;code&gt;_id&lt;/code&gt;进行聚合，得到订单数量分布。&lt;/p&gt;

&lt;p&gt;第二个场景也是处理订单表，需要统计有两张及以上订单的用户的数量，下面是代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db-&amp;gt;clear();
$match = [
    &#39;$match&#39;=&amp;gt;[
        &#39;crmId&#39;=&amp;gt;[&#39;$exists&#39;=&amp;gt;true],
        &#39;status&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;50],
        &#39;$or&#39;=&amp;gt;[
            [&#39;totalPrice&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]],
            [&#39;totalJiesuan&#39;=&amp;gt;[&#39;$gt&#39;=&amp;gt;0]],
        ],
    ],
];
$group = [
    &#39;$group&#39;=&amp;gt;[
        &#39;_id&#39;=&amp;gt;&#39;$crmId&#39;,
        &#39;count&#39;=&amp;gt;[&#39;$sum&#39;=&amp;gt;1],
    ]
];
$match2 = [
    &#39;$match&#39;=&amp;gt;[
        &#39;count&#39;=&amp;gt;[&#39;$gte&#39;=&amp;gt;2],
    ]
];
$rst = $this-&amp;gt;db-&amp;gt;aggregate(&#39;bBook&#39;,[$match,$group,$match2]);
$data[&#39;daodianTwiceUserCount&#39;] = count($rst[&#39;result&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次聚合也是根据用户id(crmId)进行聚合，得到每个用户订单数量，到这里和第一个场景的操作一样，然后再向下操作不是聚合而是进行筛选，我们要筛选出订单数量大于等于2的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongoDB的增删查改</title>
      <link>http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/</link>
      <pubDate>Fri, 27 May 2016 20:42:40 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/mongodb/mongodbcrud/</guid>
      <description>

&lt;p&gt;mongoDB的增删查改&lt;/p&gt;

&lt;h2 id=&#34;基本概念:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;mongoDB以document的形式存储数据，document类似于编程语言中的键值对的形式。document的集合成为collection，类似于一些数据库中表的概念。&lt;/p&gt;

&lt;p&gt;一下代码中均以users作为表名&lt;/p&gt;

&lt;h2 id=&#34;插入数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;插入数据&lt;/h2&gt;

&lt;h4 id=&#34;插入一条记录:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;插入一条记录&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.insert({name:&#39;jsmeta&#39;,&#39;age&#39;:23})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mongoDB的一个好处是自动生成_id,并且全局唯一。还有一个好处是有些字段可以没有值。&lt;/p&gt;

&lt;p&gt;再插入一条记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.insert({name:&#39;jsmeta2&#39;,gender:&#39;male&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在插入第一条记录时，已经有了 name 和 age两个字段名，如果是在mysql中，再插入一条信息除非设置默认值或者自增长，其他所有字段都要赋值，但是在mongodb中，并不需要都赋值，空着也可以。&lt;/p&gt;

&lt;p&gt;插完这两条记录数据库的结果是这样的：&lt;img src=&#34;http://jiangshanmeta.github.io/blogimg/insert0.jpg&#34; alt=&#34;insert&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;插入多条数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;插入多条数据&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.insert([{name:&#39;xiaoming&#39;,age:33,money:12345},{name:&#39;nobida&#39;,tech:[&#39;html&#39;,&#39;css&#39;,&#39;javascript&#39;]}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与插入一条记录很类似，只是将记录用一个数组组合。&lt;/p&gt;

&lt;p&gt;从上面的代码可以看出，mongoDB可以存一个array，这就有点意思了。在mysql中，对于上面的信息，我们可能需要拆除一张表来表明一个人会的技能，但是在mongoDB里直接存一个array就好了，顿时感觉省事多了。&lt;/p&gt;

&lt;h2 id=&#34;查找数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;查找数据&lt;/h2&gt;

&lt;h4 id=&#34;查找全部的记录:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;查找全部的记录&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以简写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而正常情况下是用不到把整张表都拿出来的&lt;/p&gt;

&lt;h4 id=&#34;相等条件:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;相等条件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({name:&#39;jsmeta&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({name:&#39;jsmeta&#39;,age:10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询名称为jsmeta且年龄为10的&lt;/p&gt;

&lt;h4 id=&#34;常见运算符:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;常见运算符&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({age:{$gte:10,$lte:30}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面筛选的是用户年龄大于等于10且小于等于30的&lt;/p&gt;

&lt;p&gt;常见的运算符还有 $gt、$lt、$ne、$in、$nin、$gte、$lte&lt;/p&gt;

&lt;h4 id=&#34;or:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;or&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({$or:[{age:{$gte:10,$lte:30}},{gender:&#39;male&#39;}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码筛选出年龄大于等于10小于等于30或者性别为男的用户&lt;/p&gt;

&lt;h4 id=&#34;查询数组:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;查询数组&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({tech:&#39;html&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tech字段存的是一个数组，上面的代码筛选出数组中含有&amp;rsquo;html&amp;rsquo;的document&lt;/p&gt;

&lt;p&gt;如果想限制的更严格一点，比如数组中第一个元素为&amp;rsquo;html&amp;rsquo;的，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({&#39;tech.0&#39;:&#39;html&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mongoDB中存的array是一个有序array&lt;/p&gt;

&lt;h4 id=&#34;and:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;and&lt;/h4&gt;

&lt;p&gt;在查询时，逗号连接的表达式默认关系为and，但是看同事写的复杂查询的代码经常首先写个&lt;code&gt;$and&lt;/code&gt;，然后其他条件向这个大and里面放，一直没用到过太复杂的查询，所以就没管，最近遇到了，&lt;a href=&#34;https://docs.mongodb.com/manual/reference/operator/query/and/&#34;&gt;文档上是这么说的&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Using an explicit AND with the $and operator is necessary when the same field or operator has to be specified in multiple expressions.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;改数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;改数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.users.update({&#39;name&#39;:&#39;jsmeta&#39;},{$set:{age:55,gender:&#39;female&#39;,tech:[&#39;php&#39;,&#39;mongodb&#39;,&#39;javascript&#39;]}},{multi:true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数是筛选条件，第二个参数是含义是把 age设为55 把gender设为female 把tech设为[&amp;lsquo;php&amp;rsquo;,&amp;lsquo;mongodb&amp;rsquo;,&amp;lsquo;javascript&amp;rsquo;]，最后一个参数的意思是更新多条数据&lt;/p&gt;

&lt;p&gt;第二个参数中的&lt;code&gt;$set&lt;/code&gt;是把相应字段的相应值设定为传入的值，如果不加&lt;code&gt;$set&lt;/code&gt;，相当于完全重写查询出来的结果。除了&lt;code&gt;$set&lt;/code&gt;，还有几个常用的操作：&lt;code&gt;$inc&lt;/code&gt;、&lt;code&gt;$push&lt;/code&gt;、&lt;code&gt;$pull&lt;/code&gt;。&lt;code&gt;$inc&lt;/code&gt;的含义是根据传入的值对相应字段增加/减少，一般是为了应对高并发的情况。&lt;code&gt;$push&lt;/code&gt;和&lt;code&gt;$pull&lt;/code&gt;应对的情形是字段是一个array，向这个array中添加或者删除数据。与&lt;code&gt;$push&lt;/code&gt;操作类似的是&lt;code&gt;$addToSet&lt;/code&gt;，两者的不同是后者保证了数组中数据的唯一性，前者不关心唯一性只管向数组中添加数据。&lt;/p&gt;

&lt;h2 id=&#34;删除数据:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;删除数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.users.remove({age:33},1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的意思是删除age字段值为33的记录，并且只删一条。第二参数可选，如果不传，则删除全部满足条件的数据&lt;/p&gt;

&lt;h2 id=&#34;limit与skip:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;limit与skip&lt;/h2&gt;

&lt;p&gt;limit和skip最常用于分页&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find({}).limit(1).skip(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样跳过一条限制查询结果只有一条，得到的是第二条，对于写代码的明明是第一条&lt;/p&gt;

&lt;h2 id=&#34;sort:e26229a1d4143975e4d61b9e4403a9c5&#34;&gt;sort&lt;/h2&gt;

&lt;p&gt;sort用来对数据进行排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.find().sort({age:1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照age字段升序排列&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>