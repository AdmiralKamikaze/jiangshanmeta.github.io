<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php on jsmeta</title>
    <link>http://jiangshanmeta.github.io/categories/php/</link>
    <description>Recent content in Php on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Sep 2016 15:42:17 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>单例模式</title>
      <link>http://jiangshanmeta.github.io/post/php/single/</link>
      <pubDate>Sun, 18 Sep 2016 15:42:17 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/single/</guid>
      <description>&lt;p&gt;重新学习最好的编程语言的时候看到了&lt;code&gt;static&lt;/code&gt;关键字，于是就想到了可以用这个做单例模式。单例模式的作用是保证一个类最多只有一个实例对象。这里不仅讲php中如何实现单例模式，还顺便说一下在js中如何实现单例模式。&lt;/p&gt;

&lt;p&gt;首先讲一下在php中如何实现单例模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person{
	private static $instance = null;
	private function __construct($name){
		$this-&amp;gt;name = $name;
	}

	public function gen_name(){
		var_dump($this-&amp;gt;name);
	}

	public static function get_instance($name){
		if(!(self::$instance instanceof self)){
			self::$instance = new self($name);
		}
		return self::$instance;
	}

}

$a = Person::get_instance(&#39;a&#39;);
$b = Person::get_instance(&#39;b&#39;);
$a-&amp;gt;gen_name();  // a
$b-&amp;gt;gen_name();	 // a

var_dump($a===$b); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们把构造函数&lt;code&gt;__construct()&lt;/code&gt;加上修饰词&lt;code&gt;private&lt;/code&gt;，这样在外部使用&lt;code&gt;new&lt;/code&gt;关键字实例化一个对象就会报错。然后我们添加一个私有的静态变量&lt;code&gt;$instance&lt;/code&gt;，用来缓存实例化的对象。静态方法&lt;code&gt;get_instance&lt;/code&gt;用来提供单例实例对象。首先判断&lt;code&gt;$instance&lt;/code&gt;有没有缓存的实例，如果有就返回这个缓存的实例对象，如果没有就手动new一个实例对象然后缓存返回该对象。单例模式在php中的实现并不复杂。&lt;/p&gt;

&lt;p&gt;对于js实现上稍微有点复杂，因为js没有&lt;code&gt;static&lt;/code&gt;关键词，但是我们可以模拟它。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = (function(){
	var instance = null;

	return function(name){
		// 安全模式，保证是使用new关键字
		if(! (this instanceof Person)){
			return new Person(name);
		}

		// 还没有创建实例对象，需要创建并缓存
		if(!(instance instanceof Person)){
			this.name = name;

			instance = this;
		}
		return instance
	}
})();

var a = Person(&#39;a&#39;);
var b = new Person(&#39;b&#39;);
console.log(a.name); // a
console.log(b.name); // b
console.log(a===b);  // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js中实现单例模式的原理类似，只是使用闭包存了一个变量&lt;code&gt;instance&lt;/code&gt;用来缓存实例对象。顺便说一句在这里被js的操作符优先级给坑了一下，默默加括号。&lt;/p&gt;

&lt;p&gt;其实单例模式的核心是保证最多只有一个实例对象，对于灵活的js其实还有一种更简单粗暴的方法，就是直接暴露一个对象，根本不给你new的机会。&lt;/p&gt;

&lt;p&gt;比如在我们的项目中有这样的一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var AlertPlug = {
	alert:function(){},
	close:function(){},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是使用单例模式的一个例子。&lt;/p&gt;

&lt;p&gt;update 2016/09/21&lt;/p&gt;

&lt;p&gt;上面的js虽然实现了但是模式，但是有一个很严重的问题，就是如果我们想在Person原型上添加一些方法，这些方法由于作用域的原因是无法获取到闭包内的静态私有变量，对于以后的扩展是很不利的。我们可以这样修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(window){
	var instance = null;
	var otherStaticPrivateVar = null;

	function Person(name){
		// 安全模式，保证是使用new关键字
		if(! (this instanceof Person)){
			return new Person(name);
		}

		// 还没有创建实例对象，需要创建并缓存
		if(!(instance instanceof Person)){
			this.name = name;

			instance = this;
		}
		return instance
	}

	Person.prototype.logOtherStaticPrivateVar=function(){
		console.log(otherStaticPrivateVar);
	}
	window.Person = Person;
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的结果依然是向全局暴露一个构造函数。&lt;/p&gt;

&lt;p&gt;update 2016/09/21&lt;/p&gt;

&lt;p&gt;后来想了想，prototype是为了不同实例之间共享一些属性和方法才存在的，既然我要做的是单例，那又何必把方法加在prototype上。&lt;/p&gt;

&lt;p&gt;不过，上面的补充其实可以作为在js中模拟静态私有变量的通用写法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重新学习最好的编程语言</title>
      <link>http://jiangshanmeta.github.io/post/php/relearnphp/</link>
      <pubDate>Thu, 25 Aug 2016 21:07:38 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/relearnphp/</guid>
      <description>

&lt;p&gt;从前端入的行，现在前端和后端php一起写，虽然日常的业务逻辑对我来说很轻松，但是感觉自己被框架宠坏了。业务中用的框架是封装过的CI，想着从一个空的CI（3.1.0）开始做起，至少要脱离现在高度封装过的框架。跟着教程看起，发现了自己对于php很多地方理解不足，这里一条条记录下来。&lt;/p&gt;

&lt;h2 id=&#34;1-构造函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;1.构造函数&lt;/h2&gt;

&lt;p&gt;CI框架默认的&lt;code&gt;controller&lt;/code&gt;是welcome，不过业界习惯还是index，我就照着welcome这个&lt;code&gt;controller&lt;/code&gt;写了一个index的&lt;code&gt;controller&lt;/code&gt;,然后就报错了。我说我这种动不动就建个&lt;code&gt;controller&lt;/code&gt;写个几百行的咋建个&lt;code&gt;controller&lt;/code&gt;就报错啊。然后百度了一下有人在博客里说是因为这是CI的保留名称所以会报错，可是项目中明明就有controller名为index的啊。后来我发现根本不是这么回事。&lt;/p&gt;

&lt;p&gt;问题出在&lt;strong&gt;构造函数&lt;/strong&gt;上。在php4的时代，构造函数是和类名同名的函数，但是在php5引入了&lt;code&gt;__construct&lt;/code&gt;的概念作为构造函数，同时为了保证向下兼容所以如果没有找到&lt;code&gt;__construct&lt;/code&gt;就把同名函数作为构造函数。在这里，我的controller名称是index，方法名称也是index，并且没有&lt;code&gt;__construct&lt;/code&gt;所以会把index方法当成构造函数。解决方案也就很明了了：写上构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __construct(){
	parent::__construct();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为继承的基类&lt;code&gt;CI_Controller&lt;/code&gt;里有构造函数，显然不作死的方案是调用基类的构造函数。看了一眼项目里的代码，我们是一个类继承了&lt;code&gt;CI_Controller&lt;/code&gt;，调用了&lt;code&gt;CI_Controller&lt;/code&gt;的构造函数，然后做了一些其他的操作。&lt;/p&gt;

&lt;h2 id=&#34;2-view-template:960e085aadb29182f9448019a6b3c8f1&#34;&gt;2.view &amp;amp;&amp;amp; template&lt;/h2&gt;

&lt;p&gt;CI是一个MVC框架，最开始我只会画画页面写写js，所以最一开始做的是view层。关于CI的view层&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/views.html&#34;&gt;官方文档里已经给出了很好的说明&lt;/a&gt;，仅仅从用的角度来说已经足够了。然而如果不对其进行封装很容易做一些重复性的操作，比如说声明对header的加载，声明对footer的加载，而真正业务逻辑对应的页面加载只需要一行，对此我们引入了一个新的类&lt;code&gt;template&lt;/code&gt;，把那些header、footer之类的全都放在模板里，在模板里输出真的业务逻辑界面。&lt;/p&gt;

&lt;p&gt;下面代码是从项目代码里按照自己的书写习惯稍微改造的，如果不明白其中一些CI的东西可以看上面链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Template{
	public function __construct(){
		$this-&amp;gt;templateData = [];
		$this-&amp;gt;CI = &amp;amp;get_instance();
	}

	public function set($name,$value){
		$this-&amp;gt;templateData[$name] = $value;
	}

	public function load($template,$view,$view_data = array(),$return = FALSE){
		$this-&amp;gt;set(&#39;contents&#39;,$this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($view,$view_data,TRUE));
		return $this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($template,$this-&amp;gt;templateData,$return);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把这个类放在&lt;code&gt;application/libraries&lt;/code&gt;目录下&lt;code&gt;template.php&lt;/code&gt;文件中，并在autoload中的libraries数组中添加&lt;code&gt;template&lt;/code&gt;,这样我们就可以愉快的使用&lt;code&gt;template&lt;/code&gt;类了，例如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;template-&amp;gt;load(&amp;quot;default_page&amp;quot;,&amp;quot;index/index&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-my-controller:960e085aadb29182f9448019a6b3c8f1&#34;&gt;3.MY_Controller&lt;/h2&gt;

&lt;p&gt;面向对象一大特征是继承，对于controller里的类也适用。CI官方文档里所讲的controller所继承的都是&lt;code&gt;CI_Controller&lt;/code&gt;，如果需求简单确实足够了，想要封装一层的话可以让这个子类继承自&lt;code&gt;CI_Controller&lt;/code&gt;，在这个类里面进行所需要的封装，controller里的类再继承自这个子类。&lt;/p&gt;

&lt;p&gt;如果熟悉面向对象的话上面所说的实现起来并不复杂，唯一的问题是目录。其实CI已经考虑过这个问题了。把自己封装好的类放到&lt;code&gt;application/core&lt;/code&gt;目录下，文件名称为xxController，然后在&lt;code&gt;application/config/config.php&lt;/code&gt;中找到&lt;code&gt;$config[&#39;subclass_prefix&#39;]&lt;/code&gt;，将其值赋为刚才文件名中的xx，然后你就会发现这个文件会自动被加载（至于具体的子类名称，对于我这种命名困难户显然是选文件名啦）。话说回来，真不嫌麻烦还可以每个controller里手动加载这个文件（何必呢）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/core_classes.html&#34;&gt;扩展核心系统类&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-uri类:960e085aadb29182f9448019a6b3c8f1&#34;&gt;4.URI类&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://codeigniter.org.cn/user_guide/libraries/uri.html&#34;&gt;URI类&lt;/a&gt;可以帮助从URI字符串中获得一些基本的信息，结合项目中所用到的说一下。&lt;/p&gt;

&lt;p&gt;根据CI的路由规则，第一个参数是控制器的名称，第二个参数是方法名，有的时候会用到这两个名称，最开始的时候我是在controller的构造函数手动声明控制器名称是啥，在具体方法里手动声明方法名是啥。看了文档个人觉得可以封装到上面提到的subclass的构造函数中，毕竟用到的还是比较多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;controller_name = $this-&amp;gt;uri-&amp;gt;segment(1)==null?&#39;index&#39;:$this-&amp;gt;uri-&amp;gt;segment(1);
$this-&amp;gt;method_name = $this-&amp;gt;uri-&amp;gt;segment(2)==null?&#39;index&#39;:$this-&amp;gt;uri-&amp;gt;segment(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外还用到比较多的是&lt;code&gt;$this-&amp;gt;uri-&amp;gt;uri_string()&lt;/code&gt;，这个主要是用在重定向上（因为样式问题以及兼容性、推广等问题对于手机和PC做了两个子站）。&lt;/p&gt;

&lt;h2 id=&#34;5-mongodb-cimongo:960e085aadb29182f9448019a6b3c8f1&#34;&gt;5.mongoDB &amp;amp;&amp;amp; cimongo&lt;/h2&gt;

&lt;p&gt;WEB开发离不开数据库，没记错的话新手是首推mysql，然后我就点错科技树学了mongoDB。开始连接数据库吧。&lt;/p&gt;

&lt;p&gt;先说个mongoDB的可视化工具&lt;a href=&#34;https://robomongo.org/&#34;&gt;robomongo&lt;/a&gt;，从一开始写后端程序就在用，毕竟图形界面大法好。&lt;/p&gt;

&lt;p&gt;然后说一下用的库&lt;a href=&#34;https://github.com/vesparny/cimongo-codeigniter-mongodb-library&#34;&gt;cimongo-codeigniter-mongodb-library&lt;/a&gt;，目测作者弃坑了。这个库为我们封装了许多操作数据库的方法。我们需要把config目录下的cimongo.php移动到ci项目 application/config目录下，然后把libraries目录下的cimongo文件夹移动到我们的ci项目中application/libraries目录下。迁移过来之后需要进行一些配置操作，打开cimongo.php配置host、port和db，然后和上面的template类一样作为autoload的libraries，这样我们就可以通过&lt;code&gt;$this-&amp;gt;cimongo&lt;/code&gt;操作数据库了。在实际项目中目测是因为觉得这样写比较长在subclass中做了这个操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;db = $this-&amp;gt;cimongo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话我们就可以进行数据库操作了，现在可以随手插入两条数据看看了，然而这样操作数据库是比较危险的操作，随后我们需要进行的是在model层对数据操作进行封装。&lt;/p&gt;

&lt;h2 id=&#34;6-创建类库:960e085aadb29182f9448019a6b3c8f1&#34;&gt;6.创建类库&lt;/h2&gt;

&lt;p&gt;今天遇到一个需求是根据权重产生随机结果，实现起来其实并不复杂，我只是想借着这个引出话题 &lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/creating_libraries.html&#34;&gt;在CI中创建类库&lt;/a&gt;。之前的template类就是这个主题的一个体现，不过那个类我是配置成了自动加载，那现在我有一个&lt;code&gt;Utility&lt;/code&gt;类，我想在需要的时候加载，我应该怎么办&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;load-&amp;gt;library(&#39;Utility&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后这个类就挂在了$CI上面。稍微有点开发经验的人应该对utility这个词不陌生，从此可以收集各种小函数啦（我不生产代码，我只是代码的搬运工）。&lt;/p&gt;

&lt;h2 id=&#34;7-field:960e085aadb29182f9448019a6b3c8f1&#34;&gt;7.field&lt;/h2&gt;

&lt;p&gt;对于从数据库里拿出来的数据，CI并没有做什么别的操作，我们项目中采用了一系列field类，用于对字段进行处理。&lt;/p&gt;

&lt;p&gt;首先我们实现了对CI的load的扩展，类似于上面说的MY_Controller,在同一目录下我们可以建立我们的Loader，其命名规则和自己建的controller一致，都是根据&lt;code&gt;application/config/config.php&lt;/code&gt;中的&lt;code&gt;$config[&#39;subclass_prefix&#39;]&lt;/code&gt;。这样我们就可以通过&lt;code&gt;$this-&amp;gt;load-&amp;gt;field($show_name,$name,$is_must_input=false)&lt;/code&gt;加载field对象了。&lt;/p&gt;

&lt;p&gt;然后我们需要做的是根据我们对不同字段类型的设定，加载不同的field，进行初始化操作，然后我们就可以在各种field上封装各种方法对数据进行处理啦。&lt;/p&gt;

&lt;h2 id=&#34;8-链式调用:960e085aadb29182f9448019a6b3c8f1&#34;&gt;8.链式调用&lt;/h2&gt;

&lt;p&gt;最早接触链式调用是在使用jQuery的时候，其实我觉得使用链式调用能使代码看起来更紧凑一点，除此之外看不出来有什么好处。&lt;/p&gt;

&lt;p&gt;要实现链式调用技术上也并不复杂，最核心的就是&lt;code&gt;return $this;&lt;/code&gt;这一句话。&lt;/p&gt;

&lt;p&gt;很不幸的是在工作项目中除了引用的第三方库中实现过链式调用，我们的后端代码中真心没有自行实现过链式调用，都是使用别人提供的链式调用。&lt;/p&gt;

&lt;p&gt;目前也就发现在model层实现链式调用有点用处，这也提醒我以后一些操作封装在model层，而不是仅仅在controller层实现功能就完了。公司代码里有的没有返回值直接添加 &lt;code&gt;return $this;&lt;/code&gt;就好了，但是有的。。想改就要改一大堆东西，有的甚至都挂在&lt;code&gt;$this&lt;/code&gt;上了还要手动返回一次。历史包袱这种东西真心纠结。&lt;/p&gt;

&lt;p&gt;因为有的代码从controller层迁移到了model层，一些controller里的return在model层就要转化为exit，这个&lt;a href=&#34;http://jiangshanmeta.github.io/post/php/exit/&#34;&gt;已经有了一些经验&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;9-protected:960e085aadb29182f9448019a6b3c8f1&#34;&gt;9.protected&lt;/h2&gt;

&lt;p&gt;javascript没有类的概念，因而也没有private、protected、public的概念，但是在php中有啊，在平时的开发中public和private用的比较多，但是真的没找到&lt;code&gt;protected&lt;/code&gt;的使用痕迹（第三封库的不算），但其实我觉得这个概念很好用啊。&lt;/p&gt;

&lt;p&gt;在controller层，写多了就会发现有一些业务上的通用小函数，最开始可能就只在一个controller里面用，显然封装成private就已经足够了，随着业务逻辑的复杂，这样的小函数可能会复制粘贴多次，显然应该向基类里进行封装，最合适的关键词就是&lt;code&gt;protected&lt;/code&gt;。封装到上面提到的&lt;strong&gt;MY_Controller&lt;/strong&gt;里面其实也不是很合适，个人认为那里适合放一些对CI框架的封装及操作，属于框架扩展层面的，而不应该存放业务逻辑。因此我个人认为应该写个专门的类继承&lt;strong&gt;MY_Controller&lt;/strong&gt;，里面放这些业务逻辑通用代码，都是protected的，然后具体的业务类都继承这个类。&lt;/p&gt;

&lt;p&gt;在model层，本身就有一些变量只应该内部使用，比如表名之类的，开发工作中的model层这些变量基本没有被限制过，都是暴露出去的，只有一些私有方法。sign&lt;/p&gt;

&lt;h2 id=&#34;10-get:960e085aadb29182f9448019a6b3c8f1&#34;&gt;10.__get()&lt;/h2&gt;

&lt;p&gt;为啥我会提到这个，这是个悲伤的故事。&lt;/p&gt;

&lt;p&gt;上面说到利用&lt;code&gt;protected&lt;/code&gt;的概念改写了一些公司对CI封装的代码，在controller层其实没什么问题，在model层有些问题，因为有些情况下还是会需要访问极个别被保护起来的变量，为了实现这个需求一个方案是在业务model类里面重新设定这些变量的修饰词，但这样就可以修改这些变量了，另一个方案是仅仅给这些变量读的权限，于是我就想到了魔术方法&lt;code&gt;__get()&lt;/code&gt;，然后我就在model层基类写下了以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __get($name){
	if(in_array($name,[&#39;tableName&#39;])) {
		return $this-&amp;gt;$name;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里逻辑上没什么问题，然后我就去测试了，然后就报错了。直接说原因：我封装的model层基类继承自&lt;code&gt;CI_Model&lt;/code&gt;，在这个类里面有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __get($key){
	return get_instance()-&amp;gt;$key;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看代码就差不多明白了吧，同时通过这段代码，CI实现了在model层调用&lt;code&gt;CodeIgniter&lt;/code&gt;的属性和方法。所以修改后的代码是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __get($name){
	if(in_array($name, [&#39;is_inited&#39;])){
		return $this-&amp;gt;$name;
	}else{
		return parent::__get($name);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-final:960e085aadb29182f9448019a6b3c8f1&#34;&gt;11.final&lt;/h2&gt;

&lt;p&gt;之所以会提及这个关键词也是很偶然的，今天老板吐槽一个同事经常重载诸如&lt;code&gt;insert_db&lt;/code&gt;之类的基础函数，然后就谈到了稍微大型的项目就不会让每个人都接触整个项目代码了，很有可能一个人只负责几个controller或者model，基类整体就是只暴露可以调用的方法，内部实现根本看不到，那问题就是如何防止重载基础函数，老板说跑脚本检测之类的，但是最简单的实现就是在想要防止重载的方法加上&lt;code&gt;final&lt;/code&gt;修饰词，能用语言本身解决的问题还需要跑脚本之类的折腾吗。&lt;/p&gt;

&lt;p&gt;之所以要重载是因为想做些额外的事情，那在使用final关键词的情况下解决如何做这些额外的事情？答案是使用&lt;strong&gt;钩子函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;12-model:960e085aadb29182f9448019a6b3c8f1&#34;&gt;12.model&lt;/h2&gt;

&lt;p&gt;根据CI的文档，model层是用来负责和数据库打交道的，在我们的项目中，把model分成了两类，一类是record_model,负责处理一条数据，另一类是list_model，负责处理多条数据，record_model是list_model的基础。这两个类都是继承自CI_model，作为对CI的进一步封装，这两个类上封装了一系列方法，用于对数据进行加载和处理，同时作为业务类的基础。由于一些历史原因，里面有许多方法封装的并不是很合适以至于，所以我要各种修修补补。&lt;/p&gt;

&lt;h2 id=&#34;13-改变应用路径:960e085aadb29182f9448019a6b3c8f1&#34;&gt;13.改变应用路径&lt;/h2&gt;

&lt;p&gt;在CI中原始的项目代码是放在&lt;code&gt;application&lt;/code&gt;目录下，而&lt;code&gt;index.php&lt;/code&gt;和该目录同级，出于安全及复杂应用的考虑，我们可以考虑改变入口文件&lt;code&gt;index.php&lt;/code&gt;的位置及项目代码目录的名称。
比如说我们把原来的application目录修改为app_user，在和该目录同级建立一个www_user目录，把入口文件放到该目录下，
为此，我们需要再index.php中进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$application_folder = getcwd().&#39;/../app_user&#39;;
$system_path = &#39;../system&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;14-辅助函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;14.辅助函数&lt;/h2&gt;

&lt;p&gt;CI提供了一些使用面向过程写的辅助函数，我扩展的是url_helper，毕竟web开发离不开url的处理。首先是对这个文件的自动加载，在autoload文件中的&lt;code&gt;autoload[&#39;helper&#39;]&lt;/code&gt;数组中添加一项&lt;code&gt;url&lt;/code&gt;这样就能自动加载了。&lt;/p&gt;

&lt;p&gt;然后是添加我的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;static_url&#39;))
{
	function static_url($uri = &#39;&#39;)
	{
		$CI =&amp;amp; get_instance();
		return $CI-&amp;gt;config-&amp;gt;static_url($uri);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数的目标是处理对本地文件的引用路径（比如js、css还有图片）。&lt;/p&gt;

&lt;p&gt;具体实现是在&lt;strong&gt;system/core/config.php&lt;/strong&gt;中。&lt;/p&gt;

&lt;h2 id=&#34;15-static:960e085aadb29182f9448019a6b3c8f1&#34;&gt;15.static&lt;/h2&gt;

&lt;p&gt;在使用CI的时候，经常会调用&lt;code&gt;get_instance&lt;/code&gt;这个函数，看一下具体实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_instance()
{
	return CI_Controller::get_instance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来在CI_Controller上有一个静态方法&lt;code&gt;get_instance&lt;/code&gt;，我们再去找CI_Controller的相关代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function &amp;amp;get_instance()
{
	return self::$instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来CI_Controller里面有一个受保护的的静态成员&lt;code&gt;$instance&lt;/code&gt;,再去找它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static $instance;
public function __construct()
{
	self::$instance =&amp;amp; $this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那结果很显然，这个静态私有变量保存着对controller实例的引用。&lt;/p&gt;

&lt;h2 id=&#34;16-spl-autoload-register:960e085aadb29182f9448019a6b3c8f1&#34;&gt;16.spl_autoload_register&lt;/h2&gt;

&lt;p&gt;这个函数其实不是CI中使用的，而是项目中对CI进行扩展的时候使用的，其作用相当于是对于&lt;code&gt;__autoload&lt;/code&gt;的加强版。其实稍微大点的项目用得到，小项目用&lt;code&gt;__autoload&lt;/code&gt;就行了。&lt;/p&gt;

&lt;p&gt;我们用它做了什么？在CI中，如果要加载并实例化某个类并挂到CI上，我们需要使用load方法，但是有的时候我们只想使用这个类的实例，并不想挂到CI指针上，比如说在一个model中加载另一个model，我们该怎么办？一个方法是需要的时候手动include或者require，当然这样比较累，另一种方法就是__autoload啦。最终的结果是我们可以使用new关键字实例化一个model而不需要手动加载文件。&lt;/p&gt;

&lt;h2 id=&#34;17-date:960e085aadb29182f9448019a6b3c8f1&#34;&gt;17.date&lt;/h2&gt;

&lt;p&gt;之所以说它是因为出了一个小bug，我想要处理时间戳显示时间，然后第一个参数填了&lt;code&gt;&#39;Y-m-d h:i&#39;&lt;/code&gt;,然后就出bug了，因为这里的h是指12小时制。这个函数常用的其实就那么几个参数。&lt;a href=&#34;http://php.net/manual/zh/function.date.php&#34;&gt;手册&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;18-json-decode:960e085aadb29182f9448019a6b3c8f1&#34;&gt;18.json_decode&lt;/h2&gt;

&lt;p&gt;一般来说&lt;code&gt;json_decode&lt;/code&gt;用到的很少，主要用到的是&lt;code&gt;json_encode&lt;/code&gt;。以前不知道前端如何向后端传递复杂数据类型，然后就前端转成json然后给后端，后端decode，然后当时也不知道还有第二个参数所以后端以对象的语法访问。后来看其他人的代码，知道在jquery中可以传递数组和对象然后jquery格式化。    今天在看jquery如何实现序列化，突然想到了这个话题。&lt;/p&gt;

&lt;h2 id=&#34;19-json-encode-转义:960e085aadb29182f9448019a6b3c8f1&#34;&gt;19.json_encode 转义&lt;/h2&gt;

&lt;p&gt;在写&lt;a href=&#34;http://jiangshanmeta.github.io/demo/myWork/mobile/lottery/index.html&#34;&gt;抽奖效果&lt;/a&gt;的时候遇到一个需求，对于奖项进行换行显示，因为canvas本身不支持文字换行，所以我们最开始约定使用\n作为分隔符，人工进行换行处理。然而最开始并不能正常进行分割，一开始以为是中文的问题，然后查了查&lt;a href=&#34;http://php.net/manual/zh/function.json-encode.php&#34;&gt;发现&lt;code&gt;json_encode&lt;/code&gt;有第二个参数（通过json_encode传递奖项array）&lt;/a&gt;，对中文不转义之后发现依然无法正常显示，然后就猜是转义的问题。确实有转义的问题但不仅仅是转义的问题，因为在单引号下，json_encode的结果无法正常分割但是直接php输出这一子项的结果可以正常分割，双引号下json_encode的结果可以分割但是直接输出的结果直接报错。总之，为啥当初用\n这种符号分割呢。&lt;/p&gt;

&lt;h2 id=&#34;20-变量作用域:960e085aadb29182f9448019a6b3c8f1&#34;&gt;20.变量作用域&lt;/h2&gt;

&lt;p&gt;之所以会提及这个问题是因为看CI源码时遇到了这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function &amp;amp;get_config(Array $replace = array())
{
	static $config;
	if (empty($config))
	{
		$file_path = APPPATH.&#39;config/config.php&#39;;
		$found = FALSE;
		if (file_exists($file_path))
		{
			$found = TRUE;
			require($file_path);
		}
	}
	return $config;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数首先声明了一个静态局部变量&lt;code&gt;$config&lt;/code&gt;，然后如果这个变量为空就去加载对应文件，文件中有一个名为&lt;code&gt;$config&lt;/code&gt;的变量。觉得这里写的比较巧妙，如果直接加在这个文件，就会设立一个全局变量&lt;code&gt;$config&lt;/code&gt;，容易被修改或者覆盖，这里将其转化为局部静态变量，从而起到了保护的作用，类似于js的闭包。&lt;/p&gt;

&lt;p&gt;说起作用域，js和php还是有点差异的，比如js局部变量没有会沿着作用域链向上查找，而在php中在局部想要访问全局变量需要手动添加&lt;code&gt;global&lt;/code&gt;关键字。php中的静态变量和js中闭包中的变量很类似。写php面向对象惯了反而对作用域关注的少了。&lt;/p&gt;

&lt;h2 id=&#34;21-server:960e085aadb29182f9448019a6b3c8f1&#34;&gt;21.$_SERVER&lt;/h2&gt;

&lt;p&gt;以前一直不明白CI是如何根据url确定需要初始化的controller是哪个、调用的方法是哪个、以及参数。看CI源码就明白了，在超全局变量&lt;code&gt;$_SERVER&lt;/code&gt;保存着请求的url，通过&lt;code&gt;CI_Router&lt;/code&gt;和&lt;code&gt;CI_URI&lt;/code&gt;两个类进行字符串处理就可以得到controller、method以及参数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>php中exit()的一个用法——记一次无聊的封装</title>
      <link>http://jiangshanmeta.github.io/post/php/exit/</link>
      <pubDate>Thu, 28 Jul 2016 19:00:23 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/exit/</guid>
      <description>&lt;p&gt;熟悉最好的编程语言php（手动滑稽）的人应该对于&lt;code&gt;exit()&lt;/code&gt;或者&lt;code&gt;die()&lt;/code&gt;函数不陌生，根据&lt;a href=&#34;http://php.net/manual/zh/function.die.php&#34;&gt;手册的说法&lt;/a&gt;这两个函数其实是别名关系，功能上是一样的。一般这两个函数是在调试的时候用的比较多，我的一个同事就比较习惯用&lt;code&gt;die()&lt;/code&gt;，然而作为前端入行的我显然是更习惯使用&lt;code&gt;return&lt;/code&gt;的方式进行调试。其实我对php的最主要调试方法是写两行然后用&lt;code&gt;var_dump()&lt;/code&gt;调试，一小步一小步往前推进。对于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数，有的人认为出错了用前者，提前退出用后者，我觉得没有太大的必要去区分这一点。&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数的用法，我觉得这一句话说得很好&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在设计工具类和工具函数时，die()/exit() 应该严令禁止，因为它们无权决定整个程序的生死。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这句话其实也反映了这两个函数与&lt;code&gt;return&lt;/code&gt;的区别，前者是程序级别的，后者仅仅是函数级别的。&lt;/p&gt;

&lt;p&gt;在我们的项目中后端是一个MVC框架(就是CI)，model层会根据前端传过来的各种信息进行初始化，为了容错，controller里经常会有这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!$this-&amp;gt;dataInfo-&amp;gt;is_inited){
	$jsonRst = -1;
	$jsonData = array();
	$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
	echo $this-&amp;gt;exportData($jsonData,$jsonRst);
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码是ajax请求时常用的代码，然而，一个controller里的action里面可能会加载多个model，这样上面的代码就会重复N遍，以至于可能真正的业务部分真的没有几行大部分都是在容错，虽说每次都是复制粘贴，但复制粘贴多了就想着封装这个功能。&lt;/p&gt;

&lt;p&gt;需求就有了，我希望能在model层里面封装一个小方法，专门用来检查初始化是否成功，如果初始化失败返回数据错误，controller里的其他代码就不运行了。为什么要单独写一个函数而不是封装在初始化函数中呢？一是因为初始化是初始化、查错是查错，二是因为上面的的代码只适用于ajax返回错误。那&lt;code&gt;return false;&lt;/code&gt;能不能满足我的需求？答案是不能，这只是终止这个小方法的运行，controller还会继续，除非手动写ifelse判断，然而这样和没封装似乎也差不了几行。我的解决方案是使用&lt;code&gt;exit()&lt;/code&gt;,这样如果初始化失败controller里的代码也不会往下走了。最终封装在model基类里的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function check_inited_for_ajax{
	$CI =&amp;amp; get_instance();
	if(!$this-&amp;gt;is_inited){
		$jsonRst = -1;
		$jsonData = array();
		$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
		echo $CI-&amp;gt;exportData($jsonData,$jsonRst);
		exit();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，对于非ajax请求，可以封装一个类似的函数，导入到404页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function check_inited_for_href(){
    $CI =&amp;amp; get_instance();
    if(!$this-&amp;gt;is_inited){
        $CI-&amp;gt;topTyp = &amp;quot;gobacktop&amp;quot;;
        $CI-&amp;gt;top_title = &amp;quot;出错啦&amp;quot;;
        echo $CI-&amp;gt;load-&amp;gt;view(&#39;default_page&#39; ,[&#39;contents&#39;=&amp;gt;$CI-&amp;gt;load-&amp;gt;view(&#39;common/notFound&#39;,[],true)], true);
        exit();
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改动并不多，真的只是做了一点微小的贡献，然而每个model初始化容错只需要一行，看起来好爽啊。&lt;/p&gt;

&lt;p&gt;//做一个有代码洁癖的bug开发者真不容易。话说同事都是有N年开发经验是怎么忍受这样的代码的。。。&lt;/p&gt;

&lt;p&gt;update 2016/08/02&lt;/p&gt;

&lt;p&gt;一个简单地想法是ajax请求的出错信息，直接写死在代码里不是很合适，可以在model基类里面封装一个相关函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function gen_err_msg(){
	return &#39;数据有误&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可行性上没问题，但是觉得没太大的用处，算是对用户体验的一点改进吧。&lt;/p&gt;

&lt;p&gt;另一个想法是扩大适用范围，不仅仅是在初始化的时候，在model有一些业务逻辑判断，比如常见的权限判断，需要导入到一个类似于404页面的无权限页面，诸如此类都可以封装到model层而不是在controller里手动判断。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>