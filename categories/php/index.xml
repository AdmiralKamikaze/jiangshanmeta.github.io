<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php on jsmeta</title>
    <link>http://jiangshanmeta.github.io/categories/php/</link>
    <description>Recent content in Php on jsmeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Aug 2016 21:07:38 +0800</lastBuildDate>
    <atom:link href="http://jiangshanmeta.github.io/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>重新学习最好的编程语言</title>
      <link>http://jiangshanmeta.github.io/post/php/relearnphp/</link>
      <pubDate>Thu, 25 Aug 2016 21:07:38 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/relearnphp/</guid>
      <description>

&lt;p&gt;从前端入的行，现在前端和后端php一起写，虽然日常的业务逻辑对我来说很轻松，但是感觉自己被框架宠坏了。业务中用的框架是封装过的CI，想着从一个空的CI开始做起，至少要脱离现在高度封装过的框架。跟着教程看起，发现了自己对于php很多地方理解不足，这里一条条记录下来。&lt;/p&gt;

&lt;h2 id=&#34;1-构造函数:960e085aadb29182f9448019a6b3c8f1&#34;&gt;1.构造函数&lt;/h2&gt;

&lt;p&gt;CI框架默认的&lt;code&gt;controller&lt;/code&gt;是welcome，不过业界习惯还是index，我就照着welcome这个&lt;code&gt;controller&lt;/code&gt;写了一个index的&lt;code&gt;controller&lt;/code&gt;,然后就报错了。我说我这种动不动就建个&lt;code&gt;controller&lt;/code&gt;写个几百行的咋建个&lt;code&gt;controller&lt;/code&gt;就报错啊。然后百度了一下有人在博客里说是因为这是CI的保留名称所以会报错，可是项目中明明就有controller名为index的啊。后来我发现根本不是这么回事。&lt;/p&gt;

&lt;p&gt;问题出在&lt;strong&gt;构造函数&lt;/strong&gt;上。在php4的时代，构造函数是和类名同名的函数，但是在php5引入了&lt;code&gt;__construct&lt;/code&gt;的概念作为构造函数，同时为了保证向下兼容所以如果没有找到&lt;code&gt;__construct&lt;/code&gt;就把同名函数作为构造函数。在这里，我的controller名称是index，方法名称也是index，并且没有&lt;code&gt;__construct&lt;/code&gt;所以会把index方法当成构造函数。解决方案也就很明了了：写上构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function __construct(){
	parent::__construct();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为继承的基类&lt;code&gt;CI_Controller&lt;/code&gt;里有构造函数，显然不作死的方案是调用基类的构造函数。看了一眼项目里的代码，我们是一个类继承了&lt;code&gt;CI_Controller&lt;/code&gt;，调用了&lt;code&gt;CI_Controller&lt;/code&gt;的构造函数，然后做了一些其他的操作。&lt;/p&gt;

&lt;h2 id=&#34;2-view-template:960e085aadb29182f9448019a6b3c8f1&#34;&gt;2.view &amp;amp;&amp;amp; template&lt;/h2&gt;

&lt;p&gt;CI是一个MVC框架，最开始我只会画画页面写写js，所以最一开始做的是view层。关于CI的view层&lt;a href=&#34;http://codeigniter.org.cn/user_guide/general/views.html&#34;&gt;官方文档里已经给出了很好的说明&lt;/a&gt;，仅仅从用的角度来说已经足够了。然而如果不对其进行封装很容易做一些重复性的操作，比如说声明对header的加载，声明对footer的加载，而真正业务逻辑对应的页面加载只需要一行，对此我们引入了一个新的类&lt;code&gt;template&lt;/code&gt;，把那些header、footer之类的全都放在模板里，在模板里输出真的业务逻辑界面。&lt;/p&gt;

&lt;p&gt;下面代码是从项目代码里按照自己的书写习惯稍微改造的，如果不明白其中一些CI的东西可以看上面链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Template{
	public function __construct(){
		$this-&amp;gt;templateData = [];
		$this-&amp;gt;CI = &amp;amp;get_instance();
	}

	public function set($name,$value){
		$this-&amp;gt;templateData[$name] = $value;
	}

	public function load($template,$view,$view_data = array(),$return = FALSE){
		$this-&amp;gt;set(&#39;contents&#39;,$this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($view,$view_data,TRUE));
		return $this-&amp;gt;CI-&amp;gt;load-&amp;gt;view($template,$this-&amp;gt;templateData,$return);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把这个类放在&lt;code&gt;application/libraries&lt;/code&gt;目录下&lt;code&gt;template.php&lt;/code&gt;文件中，并在autoload中的libraries数组中添加&lt;code&gt;template&lt;/code&gt;,这样我们就可以愉快的使用&lt;code&gt;template&lt;/code&gt;类了，例如以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;template-&amp;gt;load(&amp;quot;default_page&amp;quot;,&amp;quot;index/index&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>php中exit()的一个用法——记一次无聊的封装</title>
      <link>http://jiangshanmeta.github.io/post/php/exit/</link>
      <pubDate>Thu, 28 Jul 2016 19:00:23 +0800</pubDate>
      
      <guid>http://jiangshanmeta.github.io/post/php/exit/</guid>
      <description>&lt;p&gt;熟悉最好的编程语言php（手动滑稽）的人应该对于&lt;code&gt;exit()&lt;/code&gt;或者&lt;code&gt;die()&lt;/code&gt;函数不陌生，根据&lt;a href=&#34;http://php.net/manual/zh/function.die.php&#34;&gt;手册的说法&lt;/a&gt;这两个函数其实是别名关系，功能上是一样的。一般这两个函数是在调试的时候用的比较多，我的一个同事就比较习惯用&lt;code&gt;die()&lt;/code&gt;，然而作为前端入行的我显然是更习惯使用&lt;code&gt;return&lt;/code&gt;的方式进行调试。其实我对php的最主要调试方法是写两行然后用&lt;code&gt;var_dump()&lt;/code&gt;调试，一小步一小步往前推进。对于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数，有的人认为出错了用前者，提前退出用后者，我觉得没有太大的必要去区分这一点。&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;die()&lt;/code&gt;和&lt;code&gt;exit()&lt;/code&gt;两个函数的用法，我觉得这一句话说得很好&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在设计工具类和工具函数时，die()/exit() 应该严令禁止，因为它们无权决定整个程序的生死。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这句话其实也反映了这两个函数与&lt;code&gt;return&lt;/code&gt;的区别，前者是程序级别的，后者仅仅是函数级别的。&lt;/p&gt;

&lt;p&gt;在我们的项目中后端是一个MVC框架(就是CI)，model层会根据前端传过来的各种信息进行初始化，为了容错，controller里经常会有这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!$this-&amp;gt;dataInfo-&amp;gt;is_inited){
	$jsonRst = -1;
	$jsonData = array();
	$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
	echo $this-&amp;gt;exportData($jsonData,$jsonRst);
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码是ajax请求时常用的代码，然而，一个controller里的action里面可能会加载多个model，这样上面的代码就会重复N遍，以至于可能真正的业务部分真的没有几行大部分都是在容错，虽说每次都是复制粘贴，但复制粘贴多了就想着封装这个功能。&lt;/p&gt;

&lt;p&gt;需求就有了，我希望能在model层里面封装一个小方法，专门用来检查初始化是否成功，如果初始化失败返回数据错误，controller里的其他代码就不运行了。为什么要单独写一个函数而不是封装在初始化函数中呢？一是因为初始化是初始化、查错是查错，二是因为上面的的代码只适用于ajax返回错误。那&lt;code&gt;return false;&lt;/code&gt;能不能满足我的需求？答案是不能，这只是终止这个小方法的运行，controller还会继续，除非手动写ifelse判断，然而这样和没封装似乎也差不了几行。我的解决方案是使用&lt;code&gt;exit()&lt;/code&gt;,这样如果初始化失败controller里的代码也不会往下走了。最终封装在model基类里的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function check_inited_for_ajax{
	$CI =&amp;amp; get_instance();
	if(!$this-&amp;gt;is_inited){
		$jsonRst = -1;
		$jsonData = array();
		$jsonData[&#39;err&#39;][&#39;msg&#39;] =&#39;数据有误&#39;;
		echo $CI-&amp;gt;exportData($jsonData,$jsonRst);
		exit();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，对于非ajax请求，可以封装一个类似的函数，导入到404页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function check_inited_for_href(){
    $CI =&amp;amp; get_instance();
    if(!$this-&amp;gt;is_inited){
        $CI-&amp;gt;topTyp = &amp;quot;gobacktop&amp;quot;;
        $CI-&amp;gt;top_title = &amp;quot;出错啦&amp;quot;;
        echo $CI-&amp;gt;load-&amp;gt;view(&#39;default_page&#39; ,[&#39;contents&#39;=&amp;gt;$CI-&amp;gt;load-&amp;gt;view(&#39;common/notFound&#39;,[],true)], true);
        exit();
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改动并不多，真的只是做了一点微小的贡献，然而每个model初始化容错只需要一行，看起来好爽啊。&lt;/p&gt;

&lt;p&gt;//做一个有代码洁癖的bug开发者真不容易。话说同事都是有N年开发经验是怎么忍受这样的代码的。。。&lt;/p&gt;

&lt;p&gt;update 2016/08/02&lt;/p&gt;

&lt;p&gt;一个简单地想法是ajax请求的出错信息，直接写死在代码里不是很合适，可以在model基类里面封装一个相关函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function gen_err_msg(){
	return &#39;数据有误&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可行性上没问题，但是觉得没太大的用处，算是对用户体验的一点改进吧。&lt;/p&gt;

&lt;p&gt;另一个想法是扩大适用范围，不仅仅是在初始化的时候，在model有一些业务逻辑判断，比如常见的权限判断，需要导入到一个类似于404页面的无权限页面，诸如此类都可以封装到model层而不是在controller里手动判断。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>